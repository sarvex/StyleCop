/****************************************************************************
*   The VSSHELL Interfaces
*   Copyright (c) 1997-1998, Microsoft Corporation, All Rights Reserved
****************************************************************************/

// imports

import "oaidl.idl";
import "oleidl.idl";
import "servprov.idl";
import "docobj.idl";

#ifndef INTEROPLIB

import "designer.idl";
import "textmgr.idl";
import "oleipc.idl";

#endif

#include "vsshelluuids.h"

/****************************************************************************
********      IMPORTANT!!   *********

All guids for interfaces and co-creatable objects in this file should be defined
in vsshelluuids.h

****************************************************************************/

// forward declares
interface IVsPackage;
interface IVsSolution;
interface IVsSolutionEvents;
interface IVsHierarchy;
interface IVsHierarchyEvents;
interface IVsPersistSolutionOpts;
interface IVsPersistSolutionProps;
interface IVsSolutionPersistence;
interface IVsSelectionEvents;
interface IVsDebuggerEvents;
interface IEnumPackages;
interface IEnumHierarchies;
interface IEnumWindowFrames;
interface IVsAsyncEnumCallback;
interface IVsToolbox;
interface IVsToolboxDataProvider;
interface IVsToolboxUser;
interface IEnumToolboxItems;
interface IEnumToolboxTabs;
interface IVsRunningDocTableEvents;
interface IVsBroadcastMessageEvents;
interface IVsShellPropertyEvents;
interface IVsEditorFactory;
interface IVsWindowFrame;
interface IVsWindowFrameNotify;
interface IVsWindowView;
interface IVsLiteTreeList;
interface IVsLiteTree;
interface IVsLiteTreeEvents;
interface IVsLibrary;
interface IVsLibraryMgr;
interface IVsObjectBrowserList;
interface IVsObjectBrowserDescription;
interface IVsObjectBrowserDescription2;
interface IVsObjectList;
interface IVsLanguageInfoPackage;
interface IVsLaunchPad;
interface IVsLaunchPadEvents;
interface IVsCodeShareHandler;
interface IVsCmdNameMapping;
interface IVsUIHierWinClipboardHelper;
interface IVsUIHierWinClipboardHelperEvents;
interface IVsTextOut;
interface IVsFontAndColorDefaults;
interface IVsFontAndColorDefaultsProvider;
interface IVsFontAndColorGroup;
interface IVsFontAndColorEvents;
interface IVsFontAndColorStorage;
interface IVsProject;
interface IVsProjectFactory;
interface IVsProjectStartupServices;
interface IEnumProjectStartupServices;
interface IVsDocumentLockHolder;
interface IEnumHierarchyItems;
interface IVsEnumHierarchyItemsFactory;
interface IVsSwatchClient;
interface IVsBackForwardNavigation;
interface IVsPerPropertyBrowsing;
interface IVsMultiItemSelect;
interface IVsRegisterPriorityCommandTarget;
interface IVsSingleFileGenerator;
interface IVsGeneratorProgress;
interface IVsUIShellDocumentWindowMgr;
interface IVsEnumOutputs;
interface IVsOutput;
interface IVsHierarchicalOutput;
interface IVsOutputGroup;
interface IVsOutput2;   
interface IVsProjectCfgProvider;
interface IVsProjectCfg;
interface IVsCfgProviderEvents;
interface IVsDeployDependency;
interface IVsProjectDeployDependency;
interface IVsProjectSpecialFiles;
interface IVsXMLMemberData;
interface IVsBatchUpdate;
interface IVsFilterKeys;

/****************************************************************************
Portable macros for passing pointers and handles in VARIANTs
****************************************************************************/

cpp_quote("#undef V_INT_PTR")
cpp_quote("#undef VT_INT_PTR")

cpp_quote("#ifdef _WIN64")
cpp_quote("#define V_INT_PTR(ptr) V_I8(ptr)")
cpp_quote("#define VT_INT_PTR VT_I8")
cpp_quote("#else")
cpp_quote("#define V_INT_PTR(ptr) V_I4(ptr)")
cpp_quote("#define VT_INT_PTR VT_I4")
cpp_quote("#endif // _WIN64")

cpp_quote("#undef V_UINT_PTR")
cpp_quote("#undef VT_UINT_PTR")

cpp_quote("#ifdef _WIN64")
cpp_quote("#define V_UINT_PTR(ptr) V_UI8(ptr)")
cpp_quote("#define VT_UINT_PTR VT_UI8")
cpp_quote("#else")
cpp_quote("#define V_UINT_PTR(ptr) V_UI4(ptr)")
cpp_quote("#define VT_UINT_PTR VT_UI4")
cpp_quote("#endif // _WIN64")

/****************************************************************************
PLEASE READ: Note on enumerators and bitwise flags passed as parameters:

When a parameter must be exactly one of a set of values (a true enumerator),
the values should be defined and used as follows:

typedef enum __VSSAMPLETYPE
{
ST_THISTYPE   = 0,   // first value should be zero or one, except
ST_THATTYPE   = 1,   // in special cases, and following values
ST_THEOTHERTYPE =   2,   // should use consecutive numbers
} VSSAMPLETYPE;

interface IVsSample : IUnknown
{
HRESULT SampleMethod([in]   VSSAMPLETYPE stType);
}

When a parameter must be exactly one of a set of values (a true enumerator),
and is considered a PROPID, the values should be defined and used as follows:

enum __VSSAMPLEPROPID
{
VSSAMPPROPID_LAST       = -7000,  // first value should be a unique
VSSAMPPROPID_This       = -7000,  // number not used by any other
VSSAMPPROPID_That       = -7001,  // PROPID, and following values
VSSAMPPROPID_FIRST  = -7001,  // should use consecutive numbers
};
typedef LONG VSSAMPLEPROPID;

interface IVsSample : IUnknown
{
HRESULT GetProperty([in] VSSAMPLEPROPID propid, [out]   VARIANT *pvar);
HRESULT SetProperty([in] VSSAMPLEPROPID propid, [in] VARIANT var);
}

When a parameter can be none of or a combination of values (bitwise),
the values should be defined and used as follows:

enum __VSSAMPLEOPTS
{
SO_THISOPTION       = 0x00000001,   // first value should be one,
SO_THATOPTION       = 0x00000002,   // following values should use
SO_THEOTHEROPTION   = 0x00000004,   // consecutive powers of two
};
typedef DWORD VSSAMPLEOPTS;

interface IVsSample : IUnknown
{
HRESULT SampleMethod([in]   VSSAMPLEOPTS grfOptions);
}

****************************************************************************/

// CLSID for VS Environment Package {DA9FB551-C724-11d0-AE1F-00A0C90FFFC3}
cpp_quote("DEFINE_GUID(CLSID_VsEnvironmentPackage, 0xda9fb551, 0xc724, 0x11d0, 0xae, 0x1f, 0x00, 0xa0, 0xc9, 0x0f, 0xff, 0xc3);")
// GUID for "Visual Studio" pseudo-folder in registry {DCF2A94A-45B0-11d1-ADBF-00C04FB6BE4C}
cpp_quote("DEFINE_GUID(GUID_VsNewProjectPseudoFolder, 0xdcf2a94a, 0x45b0, 0x11d1, 0xad, 0xbf, 0x00, 0xc0, 0x4f, 0xb6, 0xbe, 0x4c);")
// string resource ID for "Visual Studio" pseudo-folder
cpp_quote("#define RESID_VsNewProjectPseudoFolderName 13016")
// priority for "Visual Studio" pseudo-folder
cpp_quote("#define Priority_VsNewProjectPseudoFolder 900")

// project type CLSID for Miscellaneous Files project {A2FE74E1-B743-11d0-AE1A-00A0C90FFFC3}
cpp_quote("DEFINE_GUID(CLSID_MiscellaneousFilesProject, 0xa2fe74e1, 0xb743, 0x11d0, 0xae, 0x1a, 0x00, 0xa0, 0xc9, 0x0f, 0xff, 0xc3);")
// project type CLSID for Solution Items project {D1DCDB85-C5E8-11d2-BFCA-00C04F990235}
cpp_quote("DEFINE_GUID(CLSID_SolutionItemsProject, 0xd1dcdb85, 0xc5e8, 0x11d2, 0xbf, 0xca, 0x0, 0xc0, 0x4f, 0x99, 0x2, 0x35);")

// Pseudo service that returns a IID_IVsOutputWindowPane interface of the General output pane in the VS environment.
// Querying for this service will cause the General output pane to be created if it hasn't yet been created.
// The General output pane is an appropriate place to display general status messages to the user
// (e.g. this is a fine place to display messages relating to such operations as opening a project).
cpp_quote("DEFINE_GUID(SID_SVsGeneralOutputWindowPane, 0x65482c72, 0xdefa, 0x41b7, 0x90, 0x2c, 0x11, 0xc0, 0x91, 0x88, 0x9c, 0x83);")

// Debugger guids
cpp_quote("DEFINE_GUID(guidAttachToProcess, 0x6bba8740, 0xacc0, 0x11d1, 0x9f, 0xe8, 0x0, 0xa0, 0xc9, 0x11, 0x0, 0x4f);")

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
#ifndef INTEROPLIB
typedef DWORD_PTR VSCOOKIE;
#endif 
cpp_quote("#define VSCOOKIE_NIL (0)")

typedef DWORD_PTR VSDOCCOOKIE;
cpp_quote("#define VSDOCCOOKIE_NIL  (0)")

//----------------------------------------------------------------------------
// Hiword values for IOleCommandTarget::Exec cmd exec opt param
//----------------------------------------------------------------------------
typedef enum __VSOLECMDEXECOPT_HIWORD
{
    EXECOPTHW_FILTERKEYS = 1,
    EXECOPTHW_GETSWATCH  = 2
} VSOLECMDEXECOPT_HIWORD;


//----------------------------------------------------------------------------
// Out param flags for controls filtering keyboard event messages
//----------------------------------------------------------------------------
typedef enum __VSFILTERKEYSFLAGS
{
    VSFILTERKEYS_DODEFAULT = 0,
    VSFILTERKEYS_HANDLED     = 1,
    VSFILTERKEYS_TRANSLATE = 2
} VSFILTERKEYSFLAGS;


//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
cpp_quote("#if 0")
typedef DWORD_PTR DLGPROC;
typedef DWORD_PTR LPFNPSPCALLBACKA;
typedef DWORD_PTR HINSTANCE;
cpp_quote("#endif")
cpp_quote("#include <prsht.h>")

// the dwFlags takes the same flags as the PROPSHEETPAGE params
// except for PSP_USEHICON, PSP_USEICONID, PSP_USETITLE
cpp_quote("#define VSPSP_INVALID (PSP_USEHICON | PSP_USEICONID | PSP_USETITLE)")

typedef struct _VSPROPSHEETPAGE
{
    DWORD               dwSize;
    DWORD               dwFlags;        // same flags as PROPSHEETPAGE except PSP_USEHICON, PSP_USEICONID, PSP_USETITLE
    HINSTANCE           hInstance;
    WORD                wTemplateId;    // note: can't use named res
    DWORD               dwTemplateSize; // use dwTemplateSize & pTemplate with PSP_DLGINDIRECT
    [size_is(dwTemplateSize)]
    BYTE               *pTemplate;
    DLGPROC         pfnDlgProc;
    LPARAM          lParam;
    LPFNPSPCALLBACKA    pfnCallback;
    UINT               *pcRefParent;
    DWORD               dwReserved;
    HWND                hwndDlg;        // if you can't pass a dialog template, pass hInstance of NULL and
    // fill in this field instead, we'll dummy up a page and stick 
    // your hwnd on it.  If you do this, don't use lParam for anything
} VSPROPSHEETPAGE;

//----------------------------------------------------------------------------
// IVsPackage
//----------------------------------------------------------------------------
enum __VSPKGRESETFLAGS
{
    PKGRF_TOOLBOXITEMS = 0x00000001,      // Package to add its default items to toolbox
    PKGRF_TOOLBOXSETUP = 0x00000002,      // Package to add additional default items to toolbox
    PKGRF_ADDSTDPREVIEWER   = 0x00000004  // Package to add additional previewers to list for OpenStandardPreviewer(OSP_UsePreviewWithDialog,...)
};
typedef DWORD VSPKGRESETFLAGS;

cpp_quote("#define PKGRESETFLAGS VSPKGRESETFLAGS")     // obsolete name, use VSPKGRESETFLAGS

[
    uuid(uuid_IVsPackage),
    version(1.0),
    pointer_default(unique)
]
interface IVsPackage : IUnknown
{
    HRESULT SetSite([in] IServiceProvider   *pSP);
    HRESULT QueryClose([out] BOOL   *pfCanClose);
    HRESULT Close(void);
    HRESULT GetAutomationObject([in] LPCOLESTR  pszPropName, [out] IDispatch **ppDisp);
    HRESULT CreateTool([in] REFGUID rguidPersistenceSlot);
    HRESULT ResetDefaults([in] VSPKGRESETFLAGS grfFlags);
    HRESULT GetPropertyPage([in] REFGUID rguidPage, [in, out]   VSPROPSHEETPAGE *ppage);
}

//----------------------------------------------------------------------------
// IVsToolWindowFactory
//----------------------------------------------------------------------------
// Implemented by Package that supports multi-instance tool windows.
// Interface retrieved by QI from IVsPackage.
[
    uuid(uuid_IVsToolWindowFactory),
    version(1.0),
    pointer_default(unique)
]
interface IVsToolWindowFactory : IUnknown
{
    HRESULT CreateToolWindow([in]   REFGUID rguidPersistenceSlot, [in] DWORD dwToolWindowId);
}


//----------------------------------------------------------------------------
// IVsPersistSolutionOpts
//----------------------------------------------------------------------------
// Implemented by Package that supports saving information in .SUO file.
// Interface retrieved by QI from IVsPackage.
enum __VSLOADUSEROPTS
{
    LUO_OPENEDDSW       = 0x00000001,   // loading MSDev .DSW file as a solution
};
typedef DWORD VSLOADUSEROPTS;

[
    uuid(uuid_IVsPersistSolutionOpts),
    version(1.0),
    pointer_default(unique)
]
interface IVsPersistSolutionOpts : IUnknown
{
    HRESULT SaveUserOptions([in] IVsSolutionPersistence *pPersistence);
    HRESULT LoadUserOptions([in] IVsSolutionPersistence *pPersistence, [in] VSLOADUSEROPTS grfLoadOpts);
    HRESULT WriteUserOptions([in]   IStream *pOptionsStream, [in] LPCOLESTR pszKey);
    HRESULT ReadUserOptions([in] IStream *pOptionsStream,   [in] LPCOLESTR pszKey);
}

//----------------------------------------------------------------------------
// IVsPersistSolutionProps
//----------------------------------------------------------------------------
// Implemented by Package that supports saving information in .SLN file.
// Interface retrieved by QI from IVsPackage.
typedef enum __VSQUERYSAVESLNPROPS
{
    QSP_HasNoProps    = 0,
    QSP_HasDirtyProps     = 1,
    QSP_HasNoDirtyProps =   2,
} VSQUERYSAVESLNPROPS;

[
    uuid(uuid_IVsPersistSolutionProps),
    version(1.0),
    pointer_default(unique)
]
interface IVsPersistSolutionProps : IVsPersistSolutionOpts
{
    HRESULT QuerySaveSolutionProps([in] IVsHierarchy *pHierarchy,   [out] VSQUERYSAVESLNPROPS *pqsspSave);
    HRESULT SaveSolutionProps([in] IVsHierarchy *pHierarchy, [in]   IVsSolutionPersistence *pPersistence);
    HRESULT WriteSolutionProps([in] IVsHierarchy *pHierarchy,   [in] LPCOLESTR pszKey,
        [in] IPropertyBag *pPropBag);
    HRESULT ReadSolutionProps([in] IVsHierarchy *pHierarchy, [in]   LPCOLESTR pszProjectName,
        [in] LPCOLESTR pszProjectMk, [in] LPCOLESTR pszKey,
        [in] BOOL fPreLoad, [in] IPropertyBag *pPropBag);
    HRESULT OnProjectLoadFailure([in]   IVsHierarchy *pStubHierarchy, [in] LPCOLESTR pszProjectName,
        [in]    LPCOLESTR pszProjectMk, [in] LPCOLESTR pszKey);
}

//----------------------------------------------------------------------------
// IVsSolutionPersistence
//----------------------------------------------------------------------------
// Implemented by the Environment.
[
    uuid(uuid_IVsSolutionPersistence),
    version(1.0),
    pointer_default(unique)
]
interface IVsSolutionPersistence : IUnknown
{
    HRESULT SavePackageSolutionProps([in]   BOOL fPreLoad, [in] IVsHierarchy *pHierarchy,
        [in]    IVsPersistSolutionProps *pPSP, [in] LPCOLESTR pszKey);
    HRESULT SavePackageUserOpts([in] IVsPersistSolutionOpts *pPSO, [in] LPCOLESTR   pszKey);
    HRESULT LoadPackageUserOpts([in] IVsPersistSolutionOpts *pPSO, [in] LPCOLESTR   pszKey);
}

cpp_quote("#define SID_SVsSolutionPersistence IID_IVsSolutionPersistence")

//----------------------------------------------------------------------------
// IVsProjectFactory
//----------------------------------------------------------------------------
// Implemented by Package that implements a project type.
// Interface is passed to Environment via IVsRegisterProjectTypes::RegisterProjectType.
enum __VSCREATEPROJFLAGS
{
    CPF_CLONEFILE       = 0x00000001,
    CPF_OPENFILE        = 0x00000002,
    CPF_OPENDIRECTORY   = 0x00000004,
    CPF_SILENT          = 0x00000008,
    CPF_OVERWRITE       = 0x00000010,
    CPF_NOTINSLNEXPLR   = 0x00000020,    // project is not shown as a normal project in Solution Explorer
    CPF_NONLOCALSTORE   = 0x00000040,    // project uses non-local storage and different save mechanism
};
typedef DWORD VSCREATEPROJFLAGS;

[
    uuid(uuid_IVsProjectFactory),
    version(1.0),
    pointer_default(unique)
]
interface IVsProjectFactory : IUnknown
{
    HRESULT CanCreateProject([in]   LPCOLESTR pszFilename,
        [in]    VSCREATEPROJFLAGS grfCreateFlags,
        [out] BOOL *pfCanCreate);
    HRESULT CreateProject([in] LPCOLESTR pszFilename,
        [in] LPCOLESTR pszLocation,
        [in] LPCOLESTR pszName,
        [in] VSCREATEPROJFLAGS grfCreateFlags,
        [in] REFIID iidProject,
        [out, iid_is(iidProject)] void **ppvProject,
        [out] BOOL *pfCanceled);
    HRESULT SetSite([in] IServiceProvider   *pSP);
    HRESULT Close(void);
}

// If the project factory supports the following interface, then the projects/files
// created/loaded are not part of the solution.
[
    uuid(uuid_IVsNonSolutionProjectFactory),
    version(1.0),
    pointer_default(unique)
]
interface IVsNonSolutionProjectFactory : IUnknown
{
}

//----------------------------------------------------------------------------
// IVsRegisterProjectTypes
//----------------------------------------------------------------------------
// Implemented by the Environment.
// Used by Packages that implement a project type. RegisterProjectType is usually  
// called in IVsPackage::SetSite; UnregisterProjectType is called in IVsPackage::Close.
[
    uuid(uuid_IVsRegisterProjectTypes),
    version(1.0),
    pointer_default(unique)
]
interface IVsRegisterProjectTypes : IUnknown
{
    HRESULT RegisterProjectType([in] REFGUID rguidProjType,
        [in] IVsProjectFactory *pVsPF,
        [out]   VSCOOKIE *pdwCookie);
    HRESULT UnregisterProjectType([in] VSCOOKIE dwCookie);                 
}

cpp_quote("#define SID_SVsRegisterProjectTypes IID_IVsRegisterProjectTypes")

//----------------------------------------------------------------------------
// IVsOwnedProjectFactory
//----------------------------------------------------------------------------
// Projects that support being aggregated by an Owner must persist the OwnerKey in 
// their project file. When CreateProject is called on a project with an OwnerKey, 
// the owned project should convert its OwnerKey to a (project factory) GUID then 
// call CreateProject on this project factory to do the actual creation.
// 
// An owner will create its owned project in two phases:
// 1. Call IVsOwnedProjectFactory.PreCreateForOwner. This gives the owned project a 
//    chance to create an aggregated project object based on the input controlling 
//    IUnknown (pUnkOwner). The owned project passes back the inner IUnk and the 
//    aggregated object to the owner project, giving it a chance to store the inner IUnk.
// 2. Call IVsOwnedProjectFactory.InitializeForOwner. The owned project does all its 
//    instantiation here (what usually goes into IVsProjectFactory.CreateProject on 
//    unowned projects). The input VSOWNEDPROJECTOBJECT is typically the aggregated 
//    owned project. The owned project can use this variable to determine if its project 
//    object has already been created (cookie!=NULL) or needs to be created (cookie==NULL).
//
// Related Property:
// Only projects that implement IVsOwnedProjectFactory should support the property:
//    VSHPROPID_OwnerKey  
//----------------------------------------------------------------------------

typedef DWORD_PTR VSOWNEDPROJECTOBJECT;

[
    uuid(uuid_IVsOwnedProjectFactory),
    version(1.0),
    pointer_default(unique)
]
interface IVsOwnedProjectFactory : IUnknown
{
    // Called   by the owner/outer so that the owned/inner project can create an aggregated
    // version of   itself, using pOwner as the controlling IUnknown.
    // The owned project should only create its project object instance here.   All the heavy 
    // initialisation   work should occur in InitializeForOwner. That ensures the owner/outer project will work
    // work correctly   during the owned/inner initialisation.
    // The owned project must   return its inner IUnknown and its Project object (cast as a VSOWNEDPROJECTOBJECT 
    // cookie) back to the owning   project.
    HRESULT PreCreateForOwner( [in]  IUnknown                   *pUnkOwner,
        [out] IUnknown                  **ppUnkInner,
        [out] VSOWNEDPROJECTOBJECT* pCookie );

    // Called   by the owner to tell the owned project to do all it's initialisation.
    // The owned project should do all its CreateProject work   in here. 
    // The cookie   parameter is just the cookie which the owned project passed back in PreCreateForOwner. This allows the 
    // owned project to create its project object
    HRESULT InitializeForOwner( [in] LPCOLESTR               pszFilename,
        [in] LPCOLESTR               pszLocation,
        [in] LPCOLESTR               pszName,
        [in] VSCREATEPROJFLAGS       grfCreateFlags,
        [in] REFIID                  iidProject,
        [in] VSOWNEDPROJECTOBJECT        cookie,    // additional parameter over IVsProjectFactory.CreateProject
        [out,   iid_is(iidProject)] void **ppvProject,
        [out]   BOOL                     *pfCanceled); 
};

//---------------------------------------------------------------------------
// IVsHierarchy, VSITEMIDs and related structs
//---------------------------------------------------------------------------
// An IVsHierarchy is a generic interface to a hierarchy of nodes, where
//     each node (including the root node) can have arbitrary properties
//     associated with it.  Since the only COM object required is for the
//     hierarchy itself (each node is not necessarily a COM object), a node
//     is identified via the pointer to the IVsHierarchy, paired with a
//     DWORD_PTR "cookie" (VSITEMID) indicating a particular node.  This cookie
//     is opaque from the consumer of the IVsHierarchy's perspective, but
//     will typically be a pointer to some private data maintained by the
//     hierarchy's implementation.
// A VSITEMID is a DWORD uniquely identifying a node within a IVsHierarchy.
//     Itemids from one IVsHierarchy may *not* be passed to another
//     hierarchy.  Also note that itemids have a limited lifetime, as
//     indicated by events fired by the hierarchy, so holding on to itemids
//     for long durations will require either the "sinking" of these events,
//     or the conversion of the itemid into a canonical, persistable form.
// An item in a hierarchy can be a leaf node, a container of other items
//     ,or a link into some other hierarchy (use GetNestedHierarchy).
// There are times when it is useful to query a hierarchy about various
//     "virtual" nodes, such as the hierarchy itself, the selected nodes
//     within the hierarchy, etc.  Where such virtual nodes are potentially
//     interesting, one of the pre-defined ITEMID_ values may be passed.
//---------------------------------------------------------------------------
typedef DWORD_PTR VSITEMID;


//---------------------------------------------------------------------------
// Use VSITEMID_NIL to represent no nodes.
// Use VSITEMID_ROOT to represent the hierarchy itself (as opposed to an item
//     in the hierarchy).
// Use VSITEMID_SELECTION to represent all of the currently selected items
//      (which might include the root itself). This is returned by
//      IVsMonitorSelection::GetCurrentSelection to indicate a selection of
//      multiple VSITEMID's.
//---------------------------------------------------------------------------
const VSITEMID VSITEMID_NIL               = ((VSITEMID)((INT_PTR)-1));
const VSITEMID VSITEMID_ROOT              = ((VSITEMID)((INT_PTR)-2));
const VSITEMID VSITEMID_SELECTION         = ((VSITEMID)((INT_PTR)-3));



//---------------------------------------------------------------------------
// Misc. structs
//---------------------------------------------------------------------------
// Each VSHPROPID must return a VARIANT struct filled in with the proper VT_
//     type.  The caller may *assume* the VT_ is correct (i.e. that there is
//     no need to call VariantChangeType(), or verify the type, beyond an
//     ASSERT() to make sure there weren't header-file mismatches, etc.
// This same logic applies to the caller when setting a property: the
//     hierarchy will assume that the *caller* has passed a VARIANT already
//     converted to the proper VT_.
//---------------------------------------------------------------------------

// WARNING: VSHPROPID values must not overlap any other *PROPID group values!

enum __VSHPROPID
{
    VSHPROPID_NIL   = -1,

    // !!!! NOTE !!!!   THIS MUST BE THE SAME AS THE FIRST PROP DEFINED
    VSHPROPID_LAST                = -1000,
    VSHPROPID_Parent                  = -1000, // I4   itemid of Parent node (ITEMID_NIL if no parent)

    // These properties are defined to deterministically walk   the entire contents of the Hierarchy 
    // (or project) independent of which view   is displayed in a UIHierarchyWindow.  Hierarchies 
    // that support special views   that either show a subset of items or a superset of member 
    // items and non-member items   must implement 
    // VSHPROPID_   FirstVisibleChild/NextVisibleSibling/IsHiddenItem/IsNonMemberItem.
    VSHPROPID_FirstChild              = -1001, // INT_PTR itemid of 1st child node (ITEMID_NIL if no children)
    VSHPROPID_NextSibling             = -1002, // INT_PTR itemid of next sibling node (ITEMID_NIL if no more siblings) 

    VSHPROPID_Root                = -1003, // INT_PTR [obsolete] itemid of Root must be VSITEMID_ROOT.
    VSHPROPID_TypeGuid            = -1004, // GUID to identify type of node/hierarchy, search on GUID_ItemType
    VSHPROPID_SaveName            = -2002, // BSTR Needed so Shell (i.e. File.Save menu) can display UI.
    VSHPROPID_Caption                 = -2003, // BSTR Needed so Shell (i.e. project window) can display UI.
    VSHPROPID_IconImgList             = -2004, // I4   For icon. Handle to imagelist (Only for itemid==VSITEMID_ROOT)
    VSHPROPID_IconIndex           = -2005, // I4   For icon.  If Expandable=TRUE, then IconIndex+1 is used for open icon.
    // Hierarchy    should support IconHandle or IconImageList/IconIndex but not both.
    VSHPROPID_Expandable              = -2006, // BOOL Should Shell display the "open-this-folder" plus sign?
    VSHPROPID_ExpandByDefault         = -2011, // BOOL Should Shell expand this item?
    VSHPROPID_ProjectName             = -2012, // BSTR [obsolete] use VSHPROPID_Name instead
    VSHPROPID_Name                = -2012, // BSTR Name for project (VSITEMID_ROOT) or item
    VSHPROPID_IconHandle              = -2013, // I4   handle of an icon, UIHierarchyWindow will NOT call DestroyIcon on it
    // Hierarchy    should support IconHandle or IconImageList/IconIndex but not both.
    VSHPROPID_OpenFolderIconHandle  =   -2014, // I4   [optional] handle of an icon for an open folder, UIHierarchyWindow will NOT call DestroyIcon on it
    VSHPROPID_OpenFolderIconIndex     = -2015, // I4   [optional] for icon
    VSHPROPID_CmdUIGuid           = -2016, // GUID for cmdbars (for root only)
    VSHPROPID_SelContainer        = -2017, // UNK  [optional] Returns an ISelectionContainer for property browsing
    VSHPROPID_BrowseObject        = -2018, // DISP [optional] Returns an IDispatch for property browsing
    // Hierarchy    should support SelContainer or BrowseObject but not both.
    VSHPROPID_AltHierarchy        = -2019, // UNK  [optional] Returns an IVsHierarchy for SVsTrackSelectionEx
    VSHPROPID_AltItemid           = -2020, // I4   [optional] Returns an itemid for SVsTrackSelectionEx
    VSHPROPID_ProjectDir              = -2021, // BSTR [optional] full path to project directory (for VSITEMID_ROOT only)
    VSHPROPID_SortPriority        = -2022, // I4   [optional] Sort priority in UIHierarchyWindow. Standard projects have priority 0 (default).
    //                MiscFiles project has priority 10000, SolutionItems project has priority 9999.
    VSHPROPID_UserContext             = -2023, // UNK  [optional] IVsUserContext for project/item
    VSHPROPID_EditLabel           = -2026, // BSTR [optional] string displayed for in-place editing node caption
    VSHPROPID_ExtObject           = -2027, // DISP [optional] For ITEMID_ROOT this is the ext.object of the project (Project).
    // For other    itemids it is that item's ext object (ProjectItem), if any.
    VSHPROPID_ExtSelectedItem         = -2028, // DISP [optional] Returns a custom SelectedItem object for the given itemid.
    // If not supported,    then a default implementation will be provided.
    VSHPROPID_StateIconIndex          = -2029, // I4   For state icon index. Use VsStateIcon enumeration
    VSHPROPID_ProjectType             = -2030, // BSTR [obsolete] use VSHPROPID_TypeName instead
    VSHPROPID_TypeName            = -2030, // BSTR display name to identify type of node/hierarchy (used in title bar)
    VSHPROPID_ReloadableProjectFile =   -2031, // BOOL [obsolete] use VSHPROPID_HandlesOwnReload
    VSHPROPID_HandlesOwnReload    = -2031, // BOOL [optional] project handles unload/reload itself (otherwise environment handles)
    // (Defaults    to FALSE)
    VSHPROPID_ParentHierarchy         = -2032, // UNK  IVsHierarchy that owns this hierarchy.  Hold as UNADDREF'ed ptr in SetProperty.
    VSHPROPID_ParentHierarchyItemid =   -2033, // INT_PTR The itemid of this hierarchy in it's parent hierarchy
    VSHPROPID_ItemDocCookie       = -2034, // INT_PTR [optional] the doc cookie (VSCOOKIE) of the hierarchy item
    VSHPROPID_Expanded            = -2035, // BOOL whether the node is currently expanded in the UIHierarchyWindow, start as FALSE
    // and UIHierarchyWindow    will update
    VSHPROPID_ConfigurationProvider =   -2036, // UNK  OBSOLETE. Use IVsGetCfgProvider interface instead
    VSHPROPID_ImplantHierarchy    = -2037, // UNK  [optional] IVsHierarchy implant for this hierarchy. Hold as UNADDREF'ed ptr in SetProperty.
    // Implant can implement    IVsFilterAddProjectItemDlg and/or IVsToolboxUser.
    VSHPROPID_OwnerKey            = -2038, // BSTR [optional] owner key string that identifies the project GUID of the owning project.
    // only projects    that implement IVsOwnedProjectFactory should support SetProperty for this property.
    VSHPROPID_StartupServices         = -2040, // UNK  [optional] Returns an IVsProjectStartupServices* to add services to be 
    // started on next project load (for    VSITEMID_ROOT only)
    VSHPROPID_FirstVisibleChild   = -2041, // INT_PTR [optional] similar to FirstChild but only walks items to be displayed in UIHierarchyWindow.
    // required if hierarchy    supports multiple (subsetted or supersetted)  views of its contents.
    VSHPROPID_NextVisibleSibling      = -2042, // INT_PTR [optional] similar to NextSibling but only walks items to be displayed in UIHierarchyWindow.
    // required if hierarchy    supports multiple (subsetted or supersetted)  views of its contents. 
    VSHPROPID_IsHiddenItem        = -2043, // BOOL [optional] is item not displayed in current UIHierarchyWindow view. required if hierarchy 
    // supports multiple    (subsetted)  views of its contents.
    VSHPROPID_IsNonMemberItem         = -2044, // BOOL [optional] is item not considered a member of the hierarchy. required if hierarchy supports 
    // (supersetted)    views of its contents (e.g. ShowAllFiles displaying files in directory that are not members of the project).
    VSHPROPID_IsNonLocalStorage   = -2045, // BOOL [optional] is project storage local? IPersistFileFormat is used for 
    // saving project regardless    of whether it is a local "file" or not.
    VSHPROPID_StorageType             = -2046, // BSTR [optional] non-localize string representing storage type. same as string used in VSDIR file
    // to differentiate between different location MRU lists.
    VSHPROPID_ItemSubType             = -2047, // BSTR [optional] non-localize string representing the subtype of the item.
    // It is    up to each package to agree on the meaning of this string.
    VSHPROPID_OverlayIconIndex    = -2048, // I4 [optional] Use VSOVERLAYICON enum.  Overlay for the item's main icon
    VSHPROPID_DefaultNamespace    = -2049, // BSTR [optional] string representing the items folder based namespace: rootnamespace.folder.subfolder
    VSHPROPID_IsNonSearchable         = -2051, // BOOL [optional] is item not search-and-replace-able via Find/Replace in Files. Should be true for project file itself.
    VSHPROPID_IsFindInFilesForegroundOnly   =  -2052, // BOOL [optional] if true, Find In Files runs in main thread
    VSHPROPID_CanBuildFromMemory      = -2053, // BOOL [optional] if TRUE, we dont need to prompt to save before building
    VSHPROPID_PreferredLanguageSID  =   -2054, // GUID [optional] preferred SID of (text editor) language service for project.
    // (e.g.    used to determine default language for BreakPoint dialog)
    VSHPROPID_ShowProjInSolutionPage = -2055,// BOOL [optional] used to filter project when vb/c#   call the component picker for add-reference.
    // Return VARIANT_TRUE to show the project in the list.
    VSHPROPID_AllowEditInRunMode      = -2056, // BOOL [optional] If FALSE or E_NOTIMPL, the compiler will disallow edits during run mode
    // (this    is the most common expected behavior).  TRUE allows edits.  This property enables VSA scenarios.
    VSHPROPID_IsNewUnsavedItem    = -2057, // BOOL [optional] If TRUE, this is a new unsaved item (as obtained from File.New.File) 
    // so the moniker will be a temporary name and the caption should be    used in the UI instead.
    VSHPROPID_ShowOnlyItemCaption     = -2058, // BOOL [optional] If TRUE, this is an item for which only the caption should be shown in the UI instead of the full moniker.
    VSHPROPID_ProjectIDGuid       = -2059, // GUID [optional] Identifies a project across solutions.  Generated and set when project is created.  Retrieved when project is opened.

    VSHPROPID_DesignerVariableNaming = -2060,   // I4 [optional] from the VSDESIGNER_VARIABLENAMING enumeration
    VSHPROPID_DesignerFunctionVisibility = -2061,   // I4 [optional] from the VSDESIGNER_FUNCTIONVISIBILITY enum

    VSHPROPID_HasEnumerationSideEffects =   -2062, // BOOL [optional] If TRUE, then this hierarchy will not be enumerated for FindInFiles and  similar
    // hierarchy    enumerations. (useful if enumerating might cause a login dialog or is unacceptably slow)

    VSHPROPID_DefaultEnableBuildProjectCfg = -2063, // BOOL [optional] Should   "Build" be initially checked by default in the solution cfg
    // Normally "Build" is checked by   default if the project supports IVsBuildableProjectCfg

    VSHPROPID_DefaultEnableDeployProjectCfg =   -2064, // BOOL [optional] Should "Deploy" be initially checked by default in the solution cfg
    // Normally "Deploy" is checked by default if   the project supports IVsDeployableProjectCfg

    // !!!! NOTE !!!!   THIS MUST BE THE SAME AS THE LAST PROP DEFINED
    VSHPROPID_FIRST               = -2064
};
typedef LONG VSHPROPID;

typedef enum __VSDESIGNER_VARIABLENAMING
{
    VSDVN_Camel,                        // variables are generated with camel case: eg: button1
    VSDVN_VB,                           // variables are generated with VB-like case: eg Button1
}VSDESIGNER_VARIABLENAMING;

typedef enum __VSDESIGNER_FUNCTIONVISIBILITY
{
    VSDFV_Private,                      // Designer functions are marked private
    VSDFV_Friend,                       // Designer functions are marked friend
    VSDFV_Public,                       // Designer functions are marked public (current not supported)
}VSDESIGNER_FUNCTIONVISIBILITY;

//--------------------------------------------------------------------
// standard item types, to be returned from VSHPROPID_TypeGuid
//--------------------------------------------------------------------

// physical file on disk or web (IVsProject::GetMkDocument returns a file path)
cpp_quote("extern const __declspec(selectany) GUID GUID_ItemType_PhysicalFile =  { 0x6bb5f8ee, 0x4483, 0x11d3, { 0x8b, 0xcf, 0x0, 0xc0, 0x4f, 0x8e, 0xc2, 0x8c } };")
// physical folder on disk or web (IVsProject::GetMkDocument returns a directory path)
cpp_quote("extern const __declspec(selectany) GUID GUID_ItemType_PhysicalFolder = { 0x6bb5f8ef, 0x4483, 0x11d3, { 0x8b, 0xcf, 0x0, 0xc0, 0x4f, 0x8e, 0xc2, 0x8c } };")
// non-physical folder (folder is logical and not a physical file system directory)
cpp_quote("extern const __declspec(selectany) GUID GUID_ItemType_VirtualFolder = { 0x6bb5f8f0, 0x4483, 0x11d3, { 0x8b, 0xcf, 0x0, 0xc0, 0x4f, 0x8e, 0xc2, 0x8c } };")
// A nested hierarchy project.
cpp_quote("extern const __declspec(selectany) GUID GUID_ItemType_SubProject = { 0xEA6618E8, 0x6E24, 0x4528, { 0x94, 0xBE, 0x68, 0x89, 0xFE, 0x16, 0x48, 0x5C } };")

//---------------------------------------------------------------------------
// IVsHierarchy
//---------------------------------------------------------------------------
// Implemented by project object or some other hierarchy that may open DocumentWindows.
// NOTE: Not all IVsHierarchy objects are standard IVsProject objects in a Solution.
// E.g. Server Explorer hierarchies are examples of non-project hierarchies.
[
    uuid(uuid_IVsHierarchy),
    version(1.0),
    pointer_default(unique)
]
interface IVsHierarchy : IUnknown
{
    // Hierarchy management.  SetSite()/Close() methods may only be called
    // by the code owning this instance of the hierarchy (i.e. the Site).
    HRESULT SetSite([in]  IServiceProvider  *pSP);
    HRESULT GetSite([out] IServiceProvider **ppSP);
    HRESULT QueryClose([out] BOOL *pfCanClose);
    HRESULT Close(void);

    // Identifies the "type" of a particular node.
    HRESULT GetGuidProperty([in] VSITEMID itemid, [in] VSHPROPID propid, [out] GUID *pguid);
    HRESULT SetGuidProperty([in] VSITEMID itemid, [in] VSHPROPID propid, [in] REFGUID rguid);

    // Generic way to get/set properties of a particular node, or of the
    //     hierarchy itself.
    HRESULT GetProperty([in] VSITEMID itemid, [in] VSHPROPID propid, [out] VARIANT *pvar);
    HRESULT SetProperty([in] VSITEMID itemid, [in] VSHPROPID propid, [in]  VARIANT  var);

    // This method allows a leaf node of this hierarchy to be a "short-cut"
    //     into the middle of some other IVsHierarchy.  If itemid is not
    //     a nested hierarchy, this method returns E_FAIL.  If the requested
    //     interface is not supported on the hierarchy object, E_NOINTERFACE
    //     is returned.  The caller would then treat this node as if it had
    //     no children, if the requested interface had been essential (as
    //     is often the case when the requested interface is
    //     IID_IVsUIHierarchy).
    HRESULT GetNestedHierarchy(
        [in]  VSITEMID  itemid,
        [in]  REFIID    iidHierarchyNested,
        [out, iid_is(iidHierarchyNested)] void **ppHierarchyNested,
        [out] VSITEMID *pitemidNested);

    // Used for workspace persistence, e.g. for remembering window positions, etc.
    HRESULT GetCanonicalName([in] VSITEMID itemid, [out] BSTR *pbstrName);
    HRESULT ParseCanonicalName([in] LPCOLESTR pszName, [out] VSITEMID *pitemid);

    // Obsolete method. Return E_NOTIMPL.
    HRESULT Unused0(void);

    // Allows clients to hook up for event notifications without making
    // hierarchy implement IConnectionPointContainer.
    HRESULT AdviseHierarchyEvents([in] IVsHierarchyEvents *pEventSink, [out] VSCOOKIE *pdwCookie);
    HRESULT UnadviseHierarchyEvents([in] VSCOOKIE dwCookie);

    // Obsolete methods. Return E_NOTIMPL.
    HRESULT Unused1(void);
    HRESULT Unused2(void);
    HRESULT Unused3(void);
    HRESULT Unused4(void);
};

//---------------------------------------------------------------------------
// IVsUIHierarchy
//---------------------------------------------------------------------------
// Implemented by IVsHierarchy object that are displayed in an IVsUIHierarchyWindow.
// Interface retrieved by QI from IVsHierarchy.
// This interface is similar to IOleCommandTarget; it handles dispatching of 
// commands that only apply when the corresponding UIHierarchyWindow (e.g. Solution 
// Explorer) has focus (e.g. Cut, Copy, Paste commands). Commands that apply also
// when the UIHierarchyWindow does not have focus (e.g. AddNewItem command) should
// be handled in IOleCommandTarget that is access by QI from the IVsHierarchy interface.
[
    uuid(uuid_IVsUIHierarchy),
    version(1.0),
    pointer_default(unique)
]
interface IVsUIHierarchy : IVsHierarchy
{
    HRESULT QueryStatusCommand(
        [in]         VSITEMID     itemid,
        [in, unique] const GUID * pguidCmdGroup,
        [in]         ULONG cCmds,
        [in, out, size_is(cCmds)] OLECMD prgCmds[],
        [in, out, unique] OLECMDTEXT *pCmdText);

    HRESULT ExecCommand(
        [in]         VSITEMID     itemid,
        [in, unique] const GUID * pguidCmdGroup,
        [in]         DWORD        nCmdID,
        [in]         DWORD        nCmdexecopt,
        [in, unique] VARIANT *    pvaIn,
        [in, out, unique]VARIANT* pvaOut);
};

// The following commands are special commands that only apply to the UIHierarchyWindow.
// They are defined as part of the command group GUID: GUID_VsUIHierarchyWindowCmds.
//---------------------------------------------------------------------------
//
// The UIHWCMDID_RightClick is what tells an IVsUIHierarchy in a UIHierarchyWindow 
// to put up the context menu.  Since the mouse may have moved between the 
// mouse down and the mouse up, GetCursorPos won't tell you the right place 
// to put the context menu (especially if it came through the keyboard).  
// So we pack the proper menu position into pvaIn by
// memcpy'ing a POINTS struct into the VT_UI4 part of the pvaIn variant.  The
// code to unpack it looks like this:
//            ULONG ulPts = V_UI4(pvaIn);
//            POINTS pts;
//            memcpy((void*)&pts, &ulPts, sizeof(POINTS));
// You then pass that POINTS into ShowContextMenu.
// It's also useful to notice that to ensure proper command handling
// you should pass a NULL cmd target into ShowContext menu so that the UIHierarchyWindow
// will have first chance at any commands it handles (delete, for example).
cpp_quote("#define UIHWCMDID_RightClick   1")
cpp_quote("#define UIHWCMDID_DoubleClick  2")
cpp_quote("#define UIHWCMDID_EnterKey     3")

// these three are to allow you to do something if the
// label edit is cancelled.  They just tell you the
// change in state, the changing of the name of your
// item will be handled through SetProperty(VSHPROPID_EditLabel,...).
cpp_quote("#define UIHWCMDID_StartLabelEdit     4")
cpp_quote("#define UIHWCMDID_CommitLabelEdit    5")
cpp_quote("#define UIHWCMDID_CancelLabelEdit    6") 

// Command Group GUID for commands that only apply to the UIHierarchyWindow
cpp_quote("extern const __declspec(selectany) GUID GUID_VsUIHierarchyWindowCmds = { 0x60481700, 0x78b, 0x11d1, {0xaa, 0xf8, 0x0, 0xa0, 0xc9, 0x5, 0x5a, 0x90} };")

// SUIHostCommandDispatcher service returns an object that implements IOleCommandTarget.
// This object handles command routing for the Environment. Use this service if you need to 
// route a command based on the current selection/state of the Environment.
cpp_quote("extern const __declspec(selectany) GUID SID_SUIHostCommandDispatcher = { 0xe69cd190, 0x1276, 0x11d1, { 0x9f, 0x64, 0x0, 0xa0, 0xc9, 0x11, 0x0, 0x4f } };")

const USHORT VSHPROJICON_WIDTH  = 16;   // width of every icon/bitmap passed to the shell image list.

//---------------------------------------------------------------------------
// IVsHierarchyEvents
//---------------------------------------------------------------------------
// All IVsHierarchy implementations must source this set of events.
[
    uuid(uuid_IVsHierarchyEvents),
    version(1.0),
    pointer_default(unique)
]
interface IVsHierarchyEvents : IUnknown // Events are "after" events
{
    HRESULT OnItemAdded(      [in] VSITEMID itemidParent, [in] VSITEMID itemidSiblingPrev, [in] VSITEMID itemidAdded);
    HRESULT OnItemsAppended(  [in] VSITEMID itemidParent);
    HRESULT OnItemDeleted(    [in] VSITEMID itemid);
    HRESULT OnPropertyChanged([in] VSITEMID itemid, [in] VSHPROPID propid, [in] DWORD flags); // 0x1=This node & all children have changed.  Use VSHPROPID_NIL to indicate all properties.
    HRESULT OnInvalidateItems([in] VSITEMID itemidParent);
    [local] HRESULT OnInvalidateIcon([in] HICON hicon);
};


//---------------------------------------------------------------------------
// IVsParentHierarchy
//---------------------------------------------------------------------------
// Unsupported interface.
typedef enum __VSEXTENDSHIERARCHY
{
    EH_NONE                     = 0x00000001,
    EH_ROOT                     = 0x00000002,
    EH_ITEM                     = 0x00000004,
} VSEXTENDSHIERARCHY;

[
    uuid(uuid_IVsParentHierarchy),
    version(1.0),
    pointer_default(unique)
]
interface IVsParentHierarchy : IUnknown
{
    HRESULT ExtendsBrowseObjects([out] VSEXTENDSHIERARCHY *peExtends);
    HRESULT GetBrowseExtender([in] IVsHierarchy *pHierarchyChild, [in] VSITEMID itemid, [out] IDispatch **ppDispatchExtension);
};

//---------------------------------------------------------------------------
// IVsSolution
//---------------------------------------------------------------------------
// Implemented by the Environment.
// Each VSPROPID must return a VARIANT struct filled in with the proper VT_
//     type.  The caller may *assume* the VT_ is correct (i.e. that there is
//     no need to call VariantChangeType(), or verify the type, beyond an
//     ASSERT() to make sure there weren't header-file mismatches, etc.
// This same logic applies to the caller when setting a property: the
//     solution will assume that the *caller* has passed a VARIANT already
//     converted to the proper VT_.
//---------------------------------------------------------------------------

// WARNING: VSPROPID values must not overlap any other *PROPID group values!

enum __VSPROPID
{
    VSPROPID_LAST                          = -8000,
    VSPROPID_SolutionDirectory         = -8000, // BSTR directory where solution file is saved
    VSPROPID_SolutionFileName              = -8001, // BSTR full path to solution file
    VSPROPID_UserOptionsFileName           = -8002, // BSTR full path to user options file
    VSPROPID_SolutionBaseName              = -8003, // BSTR (Get/Set) base name of solution file
    VSPROPID_IsSolutionDirty               = -8004, // BOOL is solution file dirty
    VSPROPID_IsSolutionOpen            = -8005, // BOOL is a solution file open
    VSPROPID_ProjectCount                  = -8006, // I4 count of projects open in solution
    VSPROPID_RegisteredProjExtns           = -8007, // BSTR semicolon-separated list of all project extensions
    VSPROPID_OpenProjectFilter         = -8008, // BSTR filter/entension list used in Open Project dialog
    VSPROPID_FileDefaultCodePage           = -8009, // I4 codepage for saving files (CP_ACP/CP_WINUNICODE)
    VSPROPID_SolutionFileNameBeingLoaded = -8010,   // BSTR full path to file being opened (valid only during open)
    VSPROPID_SolutionNodeCaption           = -8011, // BSTR caption for solution node in Project Explorer
    VSPROPID_IsSolutionOpening         = -8013, // BOOL is a solution file being opened
    VSPROPID_IsSolutionSaveAsRequired      = -8014, // BOOL will saving the solution require a Save As dialog
    VSPROPID_CountOfProjectsBeingLoaded  = -8015,   // I4 count of projects in file being opened (valid only during open)
    VSPROPID_SolutionPropertyPages     = -8016, // BSTR a semi-colon delimited list of clsid's of sln level prop pages
    VSPROPID_FIRST                     = -8016
};
typedef LONG VSPROPID;

enum __VSENUMPROJFLAGS
{
    EPF_LOADEDINSOLUTION           = 0x00000001, // normal projects referenced in the solution file and currently loaded
    EPF_UNLOADEDINSOLUTION     = 0x00000002, // normal projects referenced in the solution file and currently NOT loaded
    EPF_ALLINSOLUTION              = (EPF_LOADEDINSOLUTION | EPF_UNLOADEDINSOLUTION),
    //  all normal projects referenced in the solution file
    EPF_MATCHTYPE                  = 0x00000004, // projects with project type GUID matching parameter
    EPF_VIRTUALVISIBLEPROJECT      = 0x00000008, // 'virtual' projects visible as top-level projects in Solution Explorer
    //  (NOTE: these are projects that are not directly referenced in the solution file;
    //  instead they are projects that are created programmatically via a non-standard UI.)
    EPF_VIRTUALNONVISIBLEPROJECT = 0x00000010, //   'virtual' projects NOT visible as top-level projects in Solution Explorer
    //  (NOTE: these are projects that are not directly referenced in the solution file
    //  and are usually displayed as nested (a.k.a. sub) projects in Solution Explorer)
    EPF_ALLVIRTUAL             = (EPF_VIRTUALVISIBLEPROJECT | EPF_VIRTUALNONVISIBLEPROJECT),
    //  all 'virtual' projects of any kind
    EPF_ALLPROJECTS            = (EPF_ALLINSOLUTION | EPF_ALLVIRTUAL),
    //  all projects including normal projects directly referenced in the solution
    //  file as well as all virtual projects including nested (a.k.a. sub) projects
};
typedef DWORD VSENUMPROJFLAGS;

// the following names are obsolete
cpp_quote("#define EPF_LOADED EPF_LOADEDINSOLUTION")      // obsolete name--use EPF_LOADEDINSOLUTION instead
cpp_quote("#define EPF_UNLOADED EPF_UNLOADEDINSOLUTION")  // obsolete name--use EPF_UNLOADEDINSOLUTION instead
cpp_quote("#define EPF_ALL EPF_ALLINSOLUTION")            // obsolete name--use EPF_ALLINSOLUTION instead
cpp_quote("#define EPF_VIRTUAL EPF_ALLVIRTUAL")           // obsolete name--use EPF_ALLVIRTUAL instead

enum __VSSLNOPENOPTIONS
{
    SLNOPENOPT_Silent            = 0x00000001,  // solution file is opened silently (no user feedback)
    SLNOPENOPT_AddToCurrent  = 0x00000002,  // solution file is merged into currently open solution
    SLNOPENOPT_DontConvertSLN    = 0x00000004,  // a solution file from a previous product is not opened
};
typedef DWORD VSSLNOPENOPTIONS;

enum __VSSLNSAVEOPTIONS
{
    SLNSAVEOPT_SaveIfDirty   = 0x00000000,  // save only if dirty (this is the default)
    SLNSAVEOPT_PromptSave        = 0x00000001,  // prompt user whether to save
    SLNSAVEOPT_SkipDocs      = 0x00000002,  // skip dirty documents
    SLNSAVEOPT_SkipProj      = 0x00000004,  // skip project file
    SLNSAVEOPT_SkipSolution  = 0x00000008,  // skip solution file
    SLNSAVEOPT_SkipUserOptFile = 0x00000010,    // skip user option file
    SLNSAVEOPT_NoSave            = 0x0000001E,  // inclusive or of all "skip" flags
    SLNSAVEOPT_ForceSave         = 0x00000020,  // force save even if not dirty
    SLNSAVEOPT_DocClose      = 0x00000040,  // result of closing a document
};
typedef DWORD VSSLNSAVEOPTIONS;

enum __VSSLNCLOSEOPTIONS
{
    SLNCLOSEOPT_SLNSAVEOPT_MASK =   0x0000FFFF,
    SLNCLOSEOPT_UnloadProject     = 0x00010000, // if not set, project is removed from solution
    SLNCLOSEOPT_DeleteProject     = 0x00020000, // if set, project is to be deleted from storage, no MRU entry needed
};
typedef DWORD VSSLNCLOSEOPTIONS;

typedef enum __VSUPDATEPROJREFREASON
{
    UPR_NoUpdate                    = 0,
    UPR_ProjectRenamed          = 1,
    UPR_ProjectUsedInNewSolution    = 2,
    UPR_ItemRenamed             = 3,
    UPR_SolutionLocationChanged = 4,
} VSUPDATEPROJREFREASON;

enum __VSADDVPFLAGS
{
    ADDVP_AddToProjectWindow        = 0x00000001,
    ADDVP_ExcludeFromBuild      = 0x00000002,
    ADDVP_ExcludeFromDebugLaunch    = 0x00000004,
    ADDVP_ExcludeFromDeploy     = 0x00000008,
    ADDVP_ExcludeFromSCC            = 0x00000010,
    ADDVP_ExcludeFromEnumOutputs    = 0x00000020,
    ADDVP_ExcludeFromCfgUI      = 0x00000040,
};
typedef DWORD VSADDVPFLAGS;

enum __VSREMOVEVPFLAGS
{
    REMOVEVP_DontCloseHierarchy  = 0x00000001,
    REMOVEVP_DontSaveHierarchy   = 0x00000002,
};
typedef DWORD VSREMOVEVPFLAGS;

enum __VSCREATESOLUTIONFLAGS
{
    CSF_SILENT      = 0x00000001, // create the solution silently, do not query the user at all
    CSF_OVERWRITE       = 0x00000002, // overwrite existing solution if one exists with the specified name at the specified location
    CSF_TEMPORARY       = 0x00000004, // create a temporary solution--solution items cannot be added until it is saved
    CSF_DELAYNOTIFY = 0x00000008, // delay OnAfterOpenSolution notification until after creation of first project
};
typedef DWORD VSCREATESOLUTIONFLAGS;

enum __VSGETPROJFILESFLAGS
{
    GPFF_SKIPUNLOADEDPROJECTS   = 0x00000001, // skip the projects that will not be loaded (by user preference)
};
typedef DWORD VSGETPROJFILESFLAGS;

[
    uuid(uuid_IVsSolution),
    version(1.0),
    pointer_default(unique)
]
interface IVsSolution : IUnknown
{
    HRESULT GetProjectEnum([in] VSENUMPROJFLAGS grfEnumFlags,   [in] REFGUID rguidEnumOnlyThisType, [out] IEnumHierarchies **ppEnum);
    HRESULT CreateProject([in] REFGUID rguidProjectType, [in]   LPCOLESTR lpszMoniker,
        [in] LPCOLESTR lpszLocation, [in] LPCOLESTR lpszName, [in] VSCREATEPROJFLAGS grfCreateFlags,
        [in] REFIID iidProject, [out, iid_is(iidProject)] void **ppProject);
    HRESULT GenerateUniqueProjectName([in] LPCOLESTR lpszRoot, [out] BSTR   *pbstrProjectName);
    HRESULT GetProjectOfGuid([in]   REFGUID rguidProjectID, [out] IVsHierarchy **ppHierarchy);
    HRESULT GetGuidOfProject([in]   IVsHierarchy *pHierarchy, [out] GUID *pguidProjectID);
    HRESULT GetSolutionInfo([out]   BSTR *pbstrSolutionDirectory, [out] BSTR *pbstrSolutionFile, [out] BSTR *pbstrUserOptsFile);
    HRESULT AdviseSolutionEvents([in]   IVsSolutionEvents *pSink, [out] VSCOOKIE *pdwCookie);
    HRESULT UnadviseSolutionEvents([in] VSCOOKIE dwCookie);
    HRESULT SaveSolutionElement([in] VSSLNSAVEOPTIONS   grfSaveOpts, [in] IVsHierarchy *pHier, [in] VSCOOKIE docCookie);
    HRESULT CloseSolutionElement([in]   VSSLNCLOSEOPTIONS grfCloseOpts, [in] IVsHierarchy *pHier, [in] VSCOOKIE docCookie);
    HRESULT GetProjectOfProjref([in] LPCOLESTR pszProjref, [out] IVsHierarchy   **ppHierarchy,
        [out]   BSTR *pbstrUpdatedProjref, [out] VSUPDATEPROJREFREASON *puprUpdateReason);
    HRESULT GetProjrefOfProject([in] IVsHierarchy   *pHierarchy, [out] BSTR *pbstrProjref);
    HRESULT GetProjectInfoOfProjref([in] LPCOLESTR pszProjref, [in] VSHPROPID   propid, [out] VARIANT *pvar);
    HRESULT AddVirtualProject([in] IVsHierarchy *pHierarchy, [in]   VSADDVPFLAGS grfAddVPFlags);
    HRESULT GetItemOfProjref([in]   LPCOLESTR pszProjref, [out] IVsHierarchy **ppHierarchy, [out] VSITEMID *pitemid,
        [out]   BSTR *pbstrUpdatedProjref, [out] VSUPDATEPROJREFREASON *puprUpdateReason);
    HRESULT GetProjrefOfItem([in]   IVsHierarchy *pHierarchy, [in] VSITEMID itemid, [out] BSTR *pbstrProjref);
    HRESULT GetItemInfoOfProjref([in]   LPCOLESTR pszProjref, [in] VSHPROPID propid, [out] VARIANT *pvar);
    HRESULT GetProjectOfUniqueName([in] LPCOLESTR   pszUniqueName, [out] IVsHierarchy **ppHierarchy);
    HRESULT GetUniqueNameOfProject([in] IVsHierarchy *pHierarchy,   [out] BSTR *pbstrUniqueName);
    HRESULT GetProperty([in] VSPROPID   propid, [out] VARIANT *pvar);
    HRESULT SetProperty([in] VSPROPID   propid, [in] VARIANT var);
    HRESULT OpenSolutionFile([in]   VSSLNOPENOPTIONS grfOpenOpts, [in] LPCOLESTR pszFilename);
    HRESULT QueryEditSolutionFile([out] DWORD   *pdwEditResult);  // dwEditResult: QER_EditOK or QER_NoEdit_UserCanceled
    HRESULT CreateSolution([in, unique] LPCOLESTR   lpszLocation, [in, unique] LPCOLESTR lpszName, [in] VSCREATESOLUTIONFLAGS grfCreateFlags);
    HRESULT GetProjectFactory([in] DWORD dwReserved, [in,   out] GUID *pguidProjectType, [in] LPCOLESTR pszMkProject,
        [out, retval] IVsProjectFactory **ppProjectFactory);
    HRESULT GetProjectTypeGuid([in] DWORD   dwReserved, [in] LPCOLESTR pszMkProject, [out, retval] GUID *pguidProjectType);
    HRESULT OpenSolutionViaDlg(LPCOLESTR pszStartDirectory, BOOL fDefaultToAllProjectsFilter);   // brings up   the Open Solution dialog
    // this method is   the same as AddVirtualProject except that the caller can specify a per instance guidProjectID for this project
    // to   enable IVsSolution::GetProjectOfGUID and IVsSolution::GetProjectOfProjref to function properly. the caller is responsible
    // for persisting   this instance GUID and passing the same GUID when loading the same project instance again.
    // NOTE: guidProjectID is   NOT the same as the guidProjectType. CoCreateGuid() is useful for creating new GUIDs.
    HRESULT AddVirtualProjectEx([in] IVsHierarchy   *pHierarchy, [in] VSADDVPFLAGS grfAddVPFlags, [in] REFGUID rguidProjectID);
    // This method  checks that it is   OK to rename the project at this time. 
    // The Solution file must   be writeable before any attempt to rename the project is attempted. If the Solution is currently 
    // under SCC but not checked out,   then the user will be prompted to check out the file. If the project file is under 
    // SCC then the project file must   be NOT be currently checked out by any one. This method basically calls
    // IVsSolution::QueryEditSolutionFile   and IVsTrackProjectDocuments2::OnQueryRenameFile for the project file.
    HRESULT QueryRenameProject([in] IVsProject *pProject,   [in] LPCOLESTR pszMkOldName, [in] LPCOLESTR pszMkNewName,
        [in] DWORD  dwReserved, // in future may pass subset of VSRENAMEFILEFLAGS
        [out] BOOL  *pfRenameCanContinue);
    // This method completes the renaming   of a project. If the project is stored in  the file system then the caller is
    // required to rename   the file in the filesystem (e.g. with ::MoveFile API) prior to calling this method. This method
    // handles updating the RunningDocumentTable and notify IVsTrackProjectDocuments2   so that clients (e.g. SCC) 
    // can know that the project file   has been renamed.
    HRESULT OnAfterRenameProject([in]   IVsProject *pProject, [in] LPCOLESTR pszMkOldName, [in] LPCOLESTR pszMkNewName,
        [in]    DWORD dwReserved); // in future may pass subset of VSRENAMEFILEFLAGS
    // This method will tell the solution   to release a virtual project pointer previously added via AddVirtualProjectEx
    // without calling Close on the project.
    HRESULT RemoveVirtualProject([in]   IVsHierarchy *pHierarchy, [in] VSREMOVEVPFLAGS grfRemoveVPFlags);
    // This method brings   up the New Project dialog with the specified treeview node expanded and specified listview item selected
    HRESULT CreateNewProjectViaDlg([in] LPCOLESTR   pszExpand, [in] LPCOLESTR pszSelect, [in] DWORD dwReserved);
    HRESULT GetVirtualProjectFlags([in] IVsHierarchy *pHierarchy,   [out] VSADDVPFLAGS *pgrfAddVPFlags);
    // This method obtains the default name for the next project in the solution (ProjectN)
    HRESULT GenerateNextDefaultProjectName([in] LPCOLESTR   pszBaseName, [in] LPCOLESTR pszLocation, [out] BSTR *pbstrProjectName);
    // This method obtains the full paths   of the projects in the solution (useful for pre-load knowledge about projects).
    // The project paths are returned   in an array of BSTRs--the number of BSTRS in the array is returned in *pcProjectsFetched.
    // Pass in cProjects==0 and rgbstrProjectNames==NULL to obtain the number   of BSTRS required (in *pcProjectsFetched).
    HRESULT GetProjectFilesInSolution([in] VSGETPROJFILESFLAGS grfGetOpts, [in] ULONG   cProjects, 
        [out, size_is(cProjects), length_is(*pcProjectsFetched)] BSTR *rgbstrProjectNames, 
        [out] ULONG *pcProjectsFetched);
    // This method determines   whether a new project with the given name can be created at the given location.
    HRESULT CanCreateNewProjectAtLocation([in] BOOL fCreateNewSolution, [in] LPCOLESTR pszFullProjectFilePath, [out] BOOL   *pfCanCreate);
};

cpp_quote("#define SID_SVsSolution IID_IVsSolution")
cpp_quote("#define SID_SVsSolutionObject SID_SVsSolution")

//---------------------------------------------------------------------------
// IVsSolution2
//---------------------------------------------------------------------------
[
    uuid(uuid_IVsSolution2),
    version(1.0),
    pointer_default(unique)
]
interface IVsSolution2 : IVsSolution
{
    // This method will tell the solution to update the internal filenames it is keeping for a project--particularly the
    // filename that is being monitored for file change notifications.  This is used, for example, when a web project is
    // taken off-line so the solution knows to update the filename and watch the local filename rather than the web filename.
    HRESULT UpdateProjectFileLocation([in] IVsHierarchy *pHierarchy);
};

//---------------------------------------------------------------------------
// IVsSolutionEvents
//---------------------------------------------------------------------------
[
    uuid(uuid_IVsSolutionEvents),
    version(1.0),
    pointer_default(unique)
]
interface IVsSolutionEvents : IUnknown
{
    // fAdded   == TRUE means project added to solution after solution open.
    // fAdded   == FALSE means project added to solution during solution open.
    HRESULT OnAfterOpenProject([in] IVsHierarchy *pHierarchy,   [in] BOOL fAdded);
    // fRemoving == TRUE means project being removed from   solution before solution close.
    // fRemoving == FALSE   means project being removed from solution during solution close.
    HRESULT OnQueryCloseProject([in] IVsHierarchy   *pHierarchy, [in] BOOL fRemoving, [in,out] BOOL *pfCancel);
    // fRemoved == TRUE means   project removed from solution before solution close.
    // fRemoved == FALSE means project removed from solution during solution close.
    HRESULT OnBeforeCloseProject([in]   IVsHierarchy *pHierarchy, [in] BOOL fRemoved);

    // stub hierarchy   is placeholder hierarchy for unloaded project.
    HRESULT OnAfterLoadProject([in] IVsHierarchy *pStubHierarchy,   [in] IVsHierarchy *pRealHierarchy);
    HRESULT OnQueryUnloadProject([in]   IVsHierarchy *pRealHierarchy, [in,out] BOOL *pfCancel);
    HRESULT OnBeforeUnloadProject([in] IVsHierarchy *pRealHierarchy, [in]   IVsHierarchy *pStubHierarchy);

    // fNewSolution == TRUE means   solution is being created now.
    // fNewSolution == FALSE means solution was created previously, is being loaded.
    HRESULT OnAfterOpenSolution([in] IUnknown   *pUnkReserved, [in] BOOL fNewSolution);
    HRESULT OnQueryCloseSolution([in]   IUnknown *pUnkReserved, [in,out] BOOL *pfCancel);
    HRESULT OnBeforeCloseSolution([in] IUnknown *pUnkReserved);
    HRESULT OnAfterCloseSolution([in]   IUnknown *pUnkReserved);
};

//---------------------------------------------------------------------------
// IVsSolutionEvents2
//---------------------------------------------------------------------------
[
    uuid(uuid_IVsSolutionEvents2),
    version(1.0),
    pointer_default(unique)
]
interface IVsSolutionEvents2 : IVsSolutionEvents
{
    // fired after merging all the projects from a solution file into   the currently open solution
    HRESULT OnAfterMergeSolution([in]   IUnknown *pUnkReserved);
};

//---------------------------------------------------------------------------
// IVsSolutionEvents3
//---------------------------------------------------------------------------
[
    uuid(uuid_IVsSolutionEvents3),
    version(1.0),
    pointer_default(unique)
]
interface IVsSolutionEvents3 : IVsSolutionEvents2
{
    // fired before opening all nested projects owned   by a parent hierarchy
    HRESULT OnBeforeOpeningChildren([in] IVsHierarchy   *pHierarchy);
    // fired after opening all nested   projects owned by a parent hierarchy
    HRESULT OnAfterOpeningChildren([in] IVsHierarchy *pHierarchy);

    // fired before closing all nested projects owned   by a parent hierarchy
    HRESULT OnBeforeClosingChildren([in] IVsHierarchy   *pHierarchy);
    // fired after closing all nested   projects owned by a parent hierarchy
    HRESULT OnAfterClosingChildren([in] IVsHierarchy *pHierarchy);
};

//---------------------------------------------------------------------------
// IVsFireSolutionEvents
//---------------------------------------------------------------------------
// Implemented by the Environment. 
// Used by projects that nest sub-projects. These projects must implement IVsParentProject.
// This interface allows a project that nests sub-projects to fire the same SolutionEvents
// that the Solution normally fires. These methods iterate through the notification sinks 
// of clients of IVsSolutionEvents and call the appropriate notification method.
// They return S_OK in all 'notification' cases.  in 'query' cases, they return S_FALSE 
// if the callee sets fCancel to TRUE, indicating that the attempted operation should 
// then be aborted.
//---------------------------------------------------------------------------
[
    uuid(uuid_IVsFireSolutionEvents),
    version(1.0),
    pointer_default(unique)
]
interface IVsFireSolutionEvents : IUnknown
{
    HRESULT FireOnAfterOpenProject([in] IVsHierarchy *pHierarchy,   [in] BOOL fAdded);
    HRESULT FireOnQueryCloseProject([in] IVsHierarchy   *pHierarchy, [in] BOOL fRemoving);
    HRESULT FireOnBeforeCloseProject([in]   IVsHierarchy *pHierarchy, [in] BOOL fRemoved);

    HRESULT FireOnAfterLoadProject([in] IVsHierarchy *pHierarchy);
    HRESULT FireOnQueryUnloadProject([in]   IVsHierarchy *pHierarchy);
    HRESULT FireOnBeforeUnloadProject([in] IVsHierarchy *pHierarchy);

    HRESULT FireOnBeforeOpeningChildren([in] IVsHierarchy   *pHierarchy);
    HRESULT FireOnAfterOpeningChildren([in] IVsHierarchy *pHierarchy);
    HRESULT FireOnBeforeClosingChildren([in] IVsHierarchy   *pHierarchy);
    HRESULT FireOnAfterClosingChildren([in] IVsHierarchy *pHierarchy);
};

//----------------------------------------------------------------------------
// IVsProject
//----------------------------------------------------------------------------
// Implemented by project objects.
// Interface often retrieved by QI from IVsHierarchy.
typedef enum __VSDOCUMENTPRIORITY
{
    DP_Intrinsic           = 60,
    DP_Standard        = 50,
    DP_NonMember           = 40,
    DP_CanAddAsNonMember = 30,
    DP_External        = 20,
    DP_CanAddAsExternal  = 10,
    DP_Unsupported     = 0
} VSDOCUMENTPRIORITY;

typedef enum __VSADDITEMOPERATION
{
    VSADDITEMOP_OPENFILE        = 1,    // open an existing file
    VSADDITEMOP_CLONEFILE       = 2,    // clone a template file
    VSADDITEMOP_RUNWIZARD       = 3,    // shell ran a wizard; do nothing
    VSADDITEMOP_LINKTOFILE  = 4,    // link to an existing file
} VSADDITEMOPERATION;

typedef enum __VSADDRESULT
{
    ADDRESULT_Success     = -1,
    ADDRESULT_Failure     = 0,
    ADDRESULT_Cancel      = 1
} VSADDRESULT;

[
    uuid(uuid_IVsProject),
    version(1.0),
    pointer_default(unique)
]
interface IVsProject : IUnknown
{
    HRESULT IsDocumentInProject([in] LPCOLESTR pszMkDocument,
        [out]   BOOL *pfFound,
        [out]   VSDOCUMENTPRIORITY *pdwPriority,
        [out]   VSITEMID *pitemid);
    HRESULT GetMkDocument([in] VSITEMID itemid, [out]   BSTR *pbstrMkDocument);
    HRESULT OpenItem([in]   VSITEMID itemid,
        [in]    REFGUID rguidLogicalView,
        [in]    IUnknown *punkDocDataExisting,
        [out] IVsWindowFrame    **ppWindowFrame);
    HRESULT GetItemContext([in] VSITEMID itemid, [out] IServiceProvider **ppSP);
    HRESULT GenerateUniqueItemName([in] VSITEMID itemidLoc,
        [in] LPCOLESTR  pszExt,
        [in] LPCOLESTR  pszSuggestedRoot,
        [out] BSTR  * pbstrItemName);
    HRESULT AddItem([in] VSITEMID   itemidLoc,
        [in] VSADDITEMOPERATION dwAddItemOperation,
        [in] LPCOLESTR pszItemName,
        [in] ULONG cFilesToOpen,
        [in, size_is(cFilesToOpen)] LPCOLESTR   rgpszFilesToOpen[],
        [in] HWND   hwndDlgOwner,
        [out,   retval] VSADDRESULT * pResult);
}

//---------------------------------------------------------------------------
// IVsProject2
//---------------------------------------------------------------------------
// Implemented by project objects.
// Interface often retrieved by QI from IVsHierarchy.

[
    uuid(uuid_IVsProject2),
    version(1.0),
    pointer_default(unique)
]
interface IVsProject2 : IVsProject
{
    HRESULT RemoveItem([in] DWORD   dwReserved,
        [in] VSITEMID itemid,
        [out, retval] BOOL  * pfResult);
    HRESULT ReopenItem([in] VSITEMID itemid,
        [in] REFGUID rguidEditorType,
        [in] LPCOLESTR  pszPhysicalView,   // if NULL, MapLogicalView will be called
        [in] REFGUID rguidLogicalView,      // in MultiView case determines view to be activated
        [in] IUnknown *punkDocDataExisting,
        [out, retval] IVsWindowFrame **ppWindowFrame);
}

//---------------------------------------------------------------------------
// IVsProject3
//---------------------------------------------------------------------------
// Implemented by project objects.
// Interface often retrieved by QI from IVsHierarchy.

enum __VSSPECIFICEDITORFLAGS
{
    VSSPECIFICEDITOR_DoOpen  = 0x00000001,  // project should open item(s)--only meaningful for AddItem, implied for OpenItem
    VSSPECIFICEDITOR_UseEditor = 0x00000002,    // project should open item(s) via OpenSpecificEditor using editor type and physical view
    VSSPECIFICEDITOR_UseView     = 0x00000004,  // project should open item(s) via OpenStandardEditor using logical view only
};
typedef DWORD VSSPECIFICEDITORFLAGS;

[
    uuid(uuid_IVsProject3),
    version(1.0),
    pointer_default(unique)
]
interface IVsProject3 : IVsProject2
{
    // AddItemWithSpecific is   used to add item(s) to the project and additionally ask the project to
    // open the item using the specified editor information.    An extension of IVsProject::AddItem().
    HRESULT AddItemWithSpecific([in] VSITEMID   itemidLoc,
        [in] VSADDITEMOPERATION dwAddItemOperation,
        [in] LPCOLESTR pszItemName,
        [in] ULONG cFilesToOpen,
        [in, size_is(cFilesToOpen)] LPCOLESTR   rgpszFilesToOpen[],
        [in] HWND   hwndDlgOwner,
        [in] VSSPECIFICEDITORFLAGS grfEditorFlags,
        [in] REFGUID rguidEditorType,
        [in] LPCOLESTR pszPhysicalView,
        [in] REFGUID rguidLogicalView,
        [out,   retval] VSADDRESULT *pResult);
    // OpenItemWithSpecific is used to ask the project to   open the item using the
    // specified editor information.    An extension of IVsProject::OpenItem().
    HRESULT OpenItemWithSpecific([in]   VSITEMID itemid,
        [in]    VSSPECIFICEDITORFLAGS grfEditorFlags,
        [in]    REFGUID rguidEditorType,
        [in]    LPCOLESTR pszPhysicalView,
        [in]    REFGUID rguidLogicalView,
        [in]    IUnknown *punkDocDataExisting,
        [out] IVsWindowFrame    **ppWindowFrame);
    // TransferItem is used to transfer ownership   of a running document to the project.
    // The project should   call IVsRunningDocumentTable::RenameDocument to transfer ownership
    // of   the document to its hierarchy and give the document a new itemid within the project.
    HRESULT TransferItem([in]   LPCOLESTR pszMkDocumentOld,  // passed as pszDocumentOld to IVsRunningDocumentTable::RenameDocument
        [in]    LPCOLESTR pszMkDocumentNew,  // passed as pszDocumentNew to IVsRunningDocumentTable::RenameDocument
        [in]    IVsWindowFrame *punkWindowFrame);  // optional if document not open
}

//---------------------------------------------------------------------------
// IVsParentProject
//---------------------------------------------------------------------------
// Implemented by project objects that nest sub-projects.
// Interface retrieved by QI from IVsHierarchy.
// Parent projects (those that nest projects within themselves) implement IVsParentProject
// and IVsHierarchy::GetNestedHierarchy.
//
// OpenChildren is called after the parent project is opened, before the OnAfterOpenProject 
//    notification is sent for the project.  At this point the parent project causes the 
//    OnBeforeAddingChildren notification to be fired, then opens all of its child projects, 
//    and then causes the OnAfterAddingChildren notification to be fired.
//    Subsequently the OnAfterOpenProject notification is sent for the parent project.
// CloseChildren is called before the parent project is closed, after the OnBeforeCloseProject 
//    notification is sent for the project.  At this point the parent project causes the 
//    OnBeforeClosingChildren notification to be fired, then closes all of its child projects, 
//    and then causes the OnAfterClosingChildren notification to be fired.
//    Subsequently the parent project is closed.
//---------------------------------------------------------------------------

[
    uuid(uuid_IVsParentProject),
    version(1.0),
    pointer_default(unique)
]
interface IVsParentProject : IUnknown
{
    HRESULT OpenChildren(void);
    HRESULT CloseChildren(void);
};

//---------------------------------------------------------------------------
// IVsNonLocalProject
//---------------------------------------------------------------------------
// Implemented by projects that store project files on a remote stores.
// Interface retrieved by QI from IVsHierarchy.
// This is implemented by web projects where they cache the server files locally. 
// It used to enusre a local copy of the file exists.
//---------------------------------------------------------------------------

[
    uuid(uuid_IVsNonLocalProject),
    version(1.0),
    pointer_default(unique)
]
interface IVsNonLocalProject : IUnknown
{
    HRESULT EnsureLocalCopy([in] VSITEMID   itemid);         // itemid of the item you wish to ensure there is a local copy of
}


//---------------------------------------------------------------------------
// IVsProjectSpecificEditorMap[2]
//---------------------------------------------------------------------------
// Implemented by projects that use project specific editors or language services.
// Interface retrieved by QI from IVsHierarchy.
// All projects that have special editors or designers or that implement a 
// language service to extend the text editor should implement this interface.
// This allows a project to guarantee that it gets the correct language service
// for its own language files rather than the last language service installed.
// It also allows the project to add a "(Project default editor)" entry in the OpenWith
// dialog so the user can define the default (DBLCLK) behavior for opening an item.
enum __VSPSEPROPID
{
    VSPSEPROPID_NIL                    = -1,
    VSPSEPROPID_LAST                       = -5100,
    VSPSEPROPID_UseGlobalEditorByDefault = -5100,   // BOOL [optional]. TRUE means use global editor, FALSE means use project specific editor by default.
    // support of this property adds a "(Project default editor)" entry in the OpenWith dialog.
    // the project is expected to persist on a per-user/per-machine/per file-type (file extension) basis
    // whether the global standard editor should be used or the project specific editor should be used.
    // it then uses this information to know whether to call OpenStandardEditor or OpenSpecificEditor
    // when opening a project item.
    VSPSEPROPID_ProjectDefaultEditorName = -5101,   // BSTR [optional]. The project can return a name for the editor (to be used instead of "(Project default editor)".

    // !!!! NOTE !!!!   THIS MUST BE THE SAME AS THE LAST PROP DEFINED
    VSPSEPROPID_FIRST                      = -5101,
};
typedef LONG VSPSEPROPID;

[
    uuid(uuid_IVsProjectSpecificEditorMap),
    version(1.0),
    pointer_default(unique)
]
interface IVsProjectSpecificEditorMap : IUnknown
{
    HRESULT GetSpecificEditorType([in] LPCOLESTR pszMkDocument, [out, retval] GUID *pguidEditorType);
}

[
    uuid(uuid_IVsProjectSpecificEditorMap2),
    version(1.0),
    pointer_default(unique)
]
interface IVsProjectSpecificEditorMap2 : IVsProjectSpecificEditorMap
{
    HRESULT GetSpecificLanguageService([in] LPCOLESTR pszMkDocument, [out, retval] GUID *pguidLanguageService);
    HRESULT GetSpecificEditorProperty([in] LPCOLESTR pszMkDocument, [in] VSPSEPROPID propid, [out, retval] VARIANT *pvar);
    HRESULT SetSpecificEditorProperty([in] LPCOLESTR pszMkDocument, [in] VSPSEPROPID propid, [in] VARIANT var);
}

//---------------------------------------------------------------------------
// IVsProjectResources
//---------------------------------------------------------------------------
// Implemented by projects that manage localized resource (.RESX) files for .NET Designers.
// Interface retrieved by QI from IVsHierarchy.

enum __VSPROJRESFLAGS
{
    PRF_CreateIfNotExist = 0x00000001
};
typedef DWORD VSPROJRESFLAGS;

[
    uuid(uuid_IVsProjectResources),
    version(1.0),
    pointer_default(unique)
]
interface IVsProjectResources : IUnknown
{
    HRESULT GetResourceItem(
        [in] VSITEMID itemidDocument,
        [in] LPCOLESTR pszCulture,
        [in] VSPROJRESFLAGS grfPRF,
        [out, retval] VSITEMID* pitemidResource);

    HRESULT CreateResourceDocData(
        [in] VSITEMID itemidResource,
        [out, retval] IUnknown** punkDocData);
}

//---------------------------------------------------------------------------
// IVsSupportItemHandoff
//---------------------------------------------------------------------------
// Normally only implemented by MiscFiles project.
// Interface retrieved by QI from IVsHierarchy.
// HandoffItem tells the receiver project to call IVsProject3::TransferItem 
// on the pProjDest project. This causes the open document window for an item 
// in the receiver to be transfered to destination project. e.g. This is used
// by the Environment's implementation of the cmdidMoveFileToProject<N> commands.
[
    uuid(uuid_IVsSupportItemHandoff),
    version(1.0),
    pointer_default(unique)
]
interface IVsSupportItemHandoff : IUnknown
{
    HRESULT HandoffItem([in] VSITEMID   itemid,             // itemid in project where document should be removed
        [in] IVsProject3 *pProjDest,        // project to which document should be transferred
        [in] LPCOLESTR pszMkDocumentOld,    // passed as pszDocumentOld to IVsRunningDocumentTable::RenameDocument
        [in] LPCOLESTR pszMkDocumentNew,    // passed as pszDocumentNew to IVsRunningDocumentTable::RenameDocument
        [in] IVsWindowFrame *punkWindowFrame); //   optional if document not open
}

//---------------------------------------------------------------------------
// VSDIR flags for items and projects to indicate desired AddProject/AddItem dialog state.
//---------------------------------------------------------------------------

enum __VSDIRFLAGS
{
    VSDIRFLAG_NonLocalTemplate     = 0x00000001,  // use "non-local" UI behavior and save mechanisms
    VSDIRFLAG_BlankSolution        = 0x00000002,  // create a "blank" (empty) solution--don't create a project
    VSDIRFLAG_DisableBrowseButton  = 0x00000004,  // disable the Browse button for this project/item
    VSDIRFLAG_DontAddDefExtension  = 0x00000008,  // don't append a default extension to the name provided for the item (invalid for project)
    VSDIRFLAG_DisableLocationField = 0x00000020,  // disable the location field for this project/item
    VSDIRFLAG_DontInitNameField    = 0x00001000,  // don't initialize the name field for this project/item with a valid name
    VSDIRFLAG_DisableNameField     = 0x00002000,  // disable the name field for this project/item
};
typedef DWORD VSDIRFLAGS;

//---------------------------------------------------------------------------
// IVsAddProjectItemDlg[2]
//---------------------------------------------------------------------------
// Implemented by the Environment.
// Used by project implementations to display the AddItem dialog.
enum __VSADDITEMFLAGS
{
    VSADDITEM_AllowMultiSelect   = 0x00000001,  // multi-select
    VSADDITEM_HideNameField      = 0x00000002,  // disable the item name field
    VSADDITEM_SuggestTemplateName    = 0x00000008,  // suggest template name for item
    VSADDITEM_ShowLocationField  = 0x00000010,  // show the location field
    VSADDITEM_ShowDontShowAgain  = 0x00000040,  // show the "Don't show again" checkbox
    VSADDITEM_AllowStickyFilter  = 0x00000080,  // allow pbstrFilter[out] parameter to be returned
    VSADDITEM_AddNewItems            = 0x00000100,  // use the Add New Item dialog (mutually exclusive with VSADDITEM_AddExistingItems)
    VSADDITEM_AddExistingItems   = 0x00000200,  // use the Add Existing Item dialog (mutually exclusive with VSADDITEM_AddNewItems)
    VSADDITEM_ProjectHandlesLinks    = 0x00008000,  // project adds items as links--enables "Link" menu item
    VSADDITEM_NewDirectoryForItem    = 0x00010000,  // item is placed in new directory (location field tracks name field)
    VSADDITEM_AllowHiddenTreeView    = 0x00020000,  // allow tree view to be hidden if only one template node present
    VSADDITEM_NoOpenButtonDropDown = 0x00080000,    // don't show drop-down menu under Open button on dialog
    VSADDITEM_AllowSingleTreeRoot    = 0x00100000,  // allow the tree view to have only one root node (default is to use sub-nodes)
    VSADDITEM_ExpandSingleTreeRoot = 0x00200000,    // ask the tree view to expand a single root node (default is to not expand it)
    VSADDITEM_ShowProjectTypesOnly = 0x00400000,    // show only project types in the dialog (not items associated with projects)
    VSADDITEM_AllowOnlyFileSysLocs = 0x00800000,    // allow only local file system locations in the Add Existing Item dialog (no http://)
};
typedef DWORD VSADDITEMFLAGS;

[
    uuid(uuid_IVsAddProjectItemDlg),
    version(1.0),
    pointer_default(unique)
]
interface IVsAddProjectItemDlg : IUnknown
{
    HRESULT AddProjectItemDlg([in] VSITEMID itemidLoc,        // item to add into
        [in] REFGUID rguidProject,        // guid of project
        [in] IVsProject *pProject,        // project interface
        [in] VSADDITEMFLAGS grfAddFlags,  // flags
        [in] LPCOLESTR lpszExpand,        // directory to select/expand by default
        [in] LPCOLESTR lpszSelect,        // item to select
        [in, out] BSTR *pbstrLocation,    // location field (initial/final value); valid if ShowLocationField set
        [in, out] BSTR *pbstrFilter,      // filter string (initial/final value); valid if AllowStickyFilter set
        [out] BOOL *pfDontShowAgain);     // checkbox to suppress dialog
}
cpp_quote("#define SID_SVsAddProjectItemDlg IID_IVsAddProjectItemDlg")

[
    uuid(uuid_IVsAddProjectItemDlg2),
    version(1.0),
    pointer_default(unique)
]
interface IVsAddProjectItemDlg2 : IVsAddProjectItemDlg
{
    HRESULT AddProjectItemDlgTitled([in] VSITEMID   itemidLoc,    // item to add into
        [in] REFGUID rguidProject,        // guid of project
        [in] IVsProject *pProject,        // project interface
        [in] VSADDITEMFLAGS grfAddFlags,  // flags
        [in] LPCOLESTR lpszDlgTitle,      // dialog caption
        [in] LPCOLESTR lpszExpand,        // directory to select/expand by default
        [in] LPCOLESTR lpszSelect,        // item to select
        [in, out] BSTR *pbstrLocation,    // location field (initial/final value); valid if ShowLocationField set
        [in, out] BSTR *pbstrFilter,      // filter string (initial/final value); valid if AllowStickyFilter set
        [out] BOOL *pfDontShowAgain);     // checkbox to suppress dialog
    HRESULT AddNewProjectItem([in] VSITEMID itemidLoc,        // item to add into
        [in] REFGUID rguidProject,        // guid of project
        [in] IVsProject *pProject,        // project interface (on which AddItem* will be called)
        [in] VSSPECIFICEDITORFLAGS grfEditorFlags,
        [in] REFGUID rguidEditorType,         // editor type to open with (if supported)
        [in] LPCOLESTR pszPhysicalView,   // physical view to open with (if supported)
        [in] REFGUID rguidLogicalView,    // logical view to open with (if supported)
        [in] LPCOLESTR pszItemName,       // template filename
        [in,out] BSTR   *pbstrFileToAdd);         // filename to add
    HRESULT AddExistingProjectItems([in] VSITEMID   itemidLoc,    // item to add into
        [in] REFGUID rguidProject,        // guid of project
        [in] IVsProject *pProject,        // project interface (on which AddItem* will be called)
        [in] VSSPECIFICEDITORFLAGS grfEditorFlags,
        [in] REFGUID rguidEditorType,         // editor type to open with (if supported)
        [in] LPCOLESTR pszPhysicalView,   // physical view to open with (if supported)
        [in] REFGUID rguidLogicalView,    // logical view to open with (if supported)
        [in] ULONG cFilesToAdd,           // number of files to add
        [in, size_is(cFilesToAdd)] LPCOLESTR rgpszFilesToAdd[]); // array   of filenames to add
    HRESULT AddProjectItemDlgTitledEx([in] VSITEMID itemidLoc,  // item to add into
        [in] REFGUID rguidProject,        // guid of project
        [in] IVsProject *pProject,        // project interface
        [in] VSADDITEMFLAGS grfAddFlags,  // flags
        [in] LPCOLESTR lpszDlgTitle,      // dialog caption
        [in] LPCOLESTR lpszTreeViewTitle, // treeview caption (NULL == "Categories")
        [in] LPCOLESTR lpszHelpTopic,     // name of help topic (NULL == "vs.add[new|existing]item")
        [in] LPCOLESTR lpszExpand,        // directory to select/expand by default
        [in] LPCOLESTR lpszSelect,        // item to select
        [in, out] BSTR *pbstrLocation,    // location field (initial/final value); valid if ShowLocationField set
        [in, out] BSTR *pbstrFilter,      // filter string (initial/final value); valid if AllowStickyFilter set
        [out] BOOL *pfDontShowAgain);     // checkbox to suppress dialog
}

//----------------------------------------------------------------------------
// IVsFilterAddProjectItemDlg[2]
//----------------------------------------------------------------------------
// Implemented by projects that want to hide items from being displayed
// in their own AddProjectItem dialog.
// Interface is retrieved by QI from IVsHierarchy.
// Parent projects of nested projects can also implement this interface to control the 
// AddNewItem dialogs of the child projects. 
[
    uuid(uuid_IVsFilterAddProjectItemDlg),
    version(1.0),
    pointer_default(unique)
]
interface IVsFilterAddProjectItemDlg : IUnknown
{
    HRESULT FilterTreeItemByLocalizedName([in] REFGUID rguidProjectItemTemplates,   [in] LPCOLESTR pszLocalizedName, [out] BOOL *pfFilter);
    HRESULT FilterTreeItemByTemplateDir([in] REFGUID rguidProjectItemTemplates, [in] LPCOLESTR pszTemplateDir, [out] BOOL   *pfFilter);
    HRESULT FilterListItemByLocalizedName([in] REFGUID rguidProjectItemTemplates,   [in] LPCOLESTR pszLocalizedName, [out] BOOL *pfFilter);
    HRESULT FilterListItemByTemplateFile([in]   REFGUID rguidProjectItemTemplates, [in] LPCOLESTR pszTemplateFile, [out] BOOL *pfFilter);
}

cpp_quote("#define SID_SVsFilterAddProjectItemDlg IID_IVsFilterAddProjectItemDlg")

[
    uuid(uuid_IVsFilterAddProjectItemDlg2),
    version(1.0),
    pointer_default(unique)
]
interface IVsFilterAddProjectItemDlg2 : IVsFilterAddProjectItemDlg
{
    // The pszCategoryName for a Tree   or List item is defined by the 8th field in the .VSDIR file for the item
    // Projects can optionally classify items   with category names to assist in AddProjectItem dialg filtering.
    HRESULT FilterTreeItemByCategory([in]   REFGUID rguidProjectItemTemplates, [in] LPCOLESTR pszCategoryName, [out] BOOL *pfFilter);
    HRESULT FilterListItemByCategory([in]   REFGUID rguidProjectItemTemplates, [in] LPCOLESTR pszCategoryName, [out] BOOL *pfFilter);
}

//----------------------------------------------------------------------------
// IVsProjectTextImageProvider
//----------------------------------------------------------------------------
// Implemented by IVsProject implementations [optional].
// Interface retrieved by QI from IVsHierarchy.
//
// Allows Find/Replace in Files to operate on items that do not exist as 
// local text files.
//
// For Find in Files, will be called from a background thread.
//
//----------------------------------------------------------------------------
enum __VSPTIP_DISPOSITION
{
    VSPTIP_Close,            // Finished using the item
    VSPTIP_ToOpen,       // The item is about to be opened through OpenDocumentViaProject
    VSPTIP_Modified      // Finished using the item, and it was modified
};
typedef DWORD VSPTIP_DISPOSITION;

enum __VSPTIP_MODE
{
    VSPTIP_ReadOnly,        // open as read only
    VSPTIP_ReadWrite        // opne as editable
};
typedef DWORD VSPTIP_MODE;

[
    uuid(uuid_IVsProjectTextImageProvider),
    version(1.0),
    pointer_default(unique)
]
interface IVsProjectTextImageProvider : IUnknown
{
    HRESULT OpenItemTextImage(
        [in]          LPCOLESTR       pszMkDocument, 
        [in]          VSPTIP_MODE     grfMode,
        [out, retval] IVsTextImage ** ppTextImage
        );

    HRESULT CloseItemTextImage(
        [in] LPCOLESTR          pszMkDocument,
        [in] VSPTIP_DISPOSITION vsptipDisposition,
        [in] IVsTextImage *     pTextImage
        );
}


//----------------------------------------------------------------------------
// IVsSaveOptionsDlg
//----------------------------------------------------------------------------
// Implemented by editors that need to show dialog to choose additional save format options
// from within the SaveAs dialog.
// Interface retrieved by QI from IPersistFileFormat.
// This interface is called from the Environment's implementation of 
// IVsUIShell::SaveDocDataToFile.
[
    object,
    uuid(uuid_IVsSaveOptionsDlg),
    version(1.0),
    pointer_default(unique)
]
interface IVsSaveOptionsDlg : IUnknown
{
    // Show dialog to   choose additional save format options.
    // The object   is responsible for communicating the chosen options to the save
    // operations   and for deciding at what scope the options should be persisted.
    // If   macro recording is on, the object must emit appropriate macro code to
    // record   the changes made to the options.
    HRESULT ShowSaveOptionsDlg([in] DWORD   dwReserved, [in] HWND hwndDlgParent, [in] WCHAR * pszFileName);
};

//----------------------------------------------------------------------------
// IEnumRunningDocuments
//----------------------------------------------------------------------------
// Implemented by the Environment.
[
    uuid(uuid_IEnumRunningDocuments),
    version(1.0),
    pointer_default(unique)
]
interface IEnumRunningDocuments : IUnknown
{
    HRESULT Next([in]   ULONG celt, [out, size_is(celt), length_is(*pceltFetched)] VSCOOKIE *rgelt, [out] ULONG *pceltFetched);
    HRESULT Skip([in]   ULONG celt);
    HRESULT Reset(void);
    HRESULT Clone([out] IEnumRunningDocuments   **ppenum);
}


//----------------------------------------------------------------------------
// IVsRunningDocumentTable
//----------------------------------------------------------------------------
// Implemented by the Environment.
// Used by projects and editors to coordinate open documents.
typedef enum __VSRDTFLAGS
{
    RDT_NoLock            = 0x00000000,      // can be used with FindAndLockDocument(RDT_NoLock,...,&docCookie) to get DocCookie w/o taking a lock
    RDT_ReadLock              = 0x00000001,
    RDT_EditLock              = 0x00000002,
    RDT_RequestUnlock         = 0x00000004,
    RDT_LOCKMASK              = 0x00000007,

    RDT_DontSaveAs        = 0x00000008,
    RDT_NonCreatable          = 0x00000010,
    RDT_DontSave              = 0x00000020,
    RDT_DontAutoOpen          = 0x00000040,
    RDT_CaseSensitive         = 0x00000080,
    RDT_CantSave              = RDT_DontSave | RDT_DontSaveAs,
    RDT_VirtualDocument   = 0x00001000,
    RDT_ProjSlnDocument   = 0x00002000,
    RDT_PlaceHolderDoc    = 0x00004000,
    RDT_CanBuildFromMemory  =   0x00008000,
    RDT_DontAddToMRU          = 0x00010000,
    RDT_DOCMASK           = 0xFFFFF0F8,  // allow __VSCREATEDOCWIN flags in doc mask

    RDT_Unlock_NoSave         = 0x00000100,
    RDT_Unlock_SaveIfDirty  =   0x00000200,
    RDT_Unlock_PromptSave     = 0x00000400,
    RDT_SAVEMASK              = 0x00000F00,
} _VSRDTFLAGS;
typedef DWORD VSRDTFLAGS;
typedef VSRDTFLAGS VSRDTLOCKTYPE;

enum __VSRDTATTRIB
{
    RDTA_Hierarchy      = 0x00000001,
    RDTA_ItemID         = 0x00000002,
    RDTA_MkDocument     = 0x00000004,
    RDTA_DocDataIsDirty = 0x00000008,
    RDTA_DocDataIsNotDirty= 0x00000010,
    // The following attribute events   are fired by calling NotifyDocumentChanged
    RDTA_NOTIFYDOCCHANGEDMASK   = 0xFFFF0000,
    RDTA_DocDataReloaded    = 0x00010000,
    RDTA_AltHierarchyItemID =   0x00020000,   
};
typedef DWORD VSRDTATTRIB;

enum __VSRDTSAVEOPTIONS
{
    RDTSAVEOPT_SaveIfDirty    = 0x00000000,  // save only if dirty (this is the default)
    RDTSAVEOPT_PromptSave         = 0x00000001,  // prompt user whether to save
    RDTSAVEOPT_ForceSave          = 0x00000002,  // force save even if not dirty
    RDTSAVEOPT_SaveNoChildren     = 0x00000004,  // save only the root of the hierarchy passed in, don't include its children
    RDTSAVEOPT_SaveOnlyChildren =   0x00000008,  // save only children of the hierarchy passed in, don't include hierarchy itself
    RDTSAVEOPT_ActivateDocOnErr =   0x00000010,  // activates the editor window of a doc if it errors on save
    RDTSAVEOPT_DocClose       = 0x00010000,  // indicates save is a result of a document close
    RDTSAVEOPT_Reserved       = 0xFFFF0000,  // reserved internal bits
};
typedef DWORD VSRDTSAVEOPTIONS;

enum __VSREGDOCLOCKHOLDER
{
    RDLH_WeakLockHolder         = 0x00000001,   // A weak lock holder only wants to hold an EditLlock if there are no other edit locks
    // IVsDocumentLockHolder::Close() will be called on next EditLock.
    // A weak lock holder must first check the existing lock count, and only take its
    // EditLock if there are no other EditLocks. It should take its EditLock before
    // calling RegisterDocumentLockHolder.
};
typedef DWORD VSREGDOCLOCKHOLDER;

[
    uuid(uuid_IVsRunningDocumentTable),
    version(1.0),
    pointer_default(unique)
]
interface IVsRunningDocumentTable : IUnknown
{
    HRESULT RegisterAndLockDocument([in] VSRDTFLAGS grfRDTLockType,
        [in] LPCOLESTR pszMkDocument,
        [in] IVsHierarchy   *pHier,
        [in] VSITEMID   itemid,
        [in] IUnknown   *punkDocData,
        [out]   VSCOOKIE *pdwCookie);
    HRESULT LockDocument([in]   VSRDTFLAGS grfRDTLockType, [in] VSCOOKIE dwCookie);
    HRESULT UnlockDocument([in] VSRDTFLAGS grfRDTLockType, [in] VSCOOKIE dwCookie);
    HRESULT FindAndLockDocument([in] VSRDTFLAGS dwRDTLockType,
        [in] LPCOLESTR pszMkDocument,
        [out]   IVsHierarchy **ppHier,
        [out]   VSITEMID *pitemid,
        [out]   IUnknown **ppunkDocData,
        [out]   VSCOOKIE *pdwCookie);
    HRESULT RenameDocument([in] LPCOLESTR   pszMkDocumentOld,
        [in] LPCOLESTR  pszMkDocumentNew,
        [in] IVsHierarchy *pHier,
        [in] VSITEMID itemidNew);                       
    HRESULT AdviseRunningDocTableEvents([in] IVsRunningDocTableEvents   *pSink,
        [out]   VSCOOKIE *pdwCookie);
    HRESULT UnadviseRunningDocTableEvents([in] VSCOOKIE dwCookie);
    HRESULT GetDocumentInfo([in] VSCOOKIE   docCookie,
        [out]   VSRDTFLAGS *pgrfRDTFlags,
        [out]   DWORD *pdwReadLocks,
        [out]   DWORD *pdwEditLocks,
        [out]   BSTR *pbstrMkDocument,
        [out]   IVsHierarchy **ppHier,
        [out]   VSITEMID *pitemid,
        [out]   IUnknown **ppunkDocData);
    HRESULT NotifyDocumentChanged([in] VSCOOKIE dwCookie,
        [in] VSRDTATTRIB grfDocChanged);
    HRESULT NotifyOnAfterSave([in] VSCOOKIE dwCookie);
    HRESULT GetRunningDocumentsEnum([out]   IEnumRunningDocuments **ppenum);
    HRESULT SaveDocuments([in] VSRDTSAVEOPTIONS grfSaveOpts, 
        [in] IVsHierarchy *pHier, 
        [in] VSITEMID itemid, 
        [in] VSCOOKIE docCookie);
    HRESULT NotifyOnBeforeSave([in] VSCOOKIE dwCookie);
    HRESULT RegisterDocumentLockHolder([in] VSREGDOCLOCKHOLDER grfRDLH, 
        [in] VSCOOKIE dwCookie,
        [in] IVsDocumentLockHolder  *pLockHolder, 
        [out] VSCOOKIE  *pdwLHCookie);
    HRESULT UnregisterDocumentLockHolder(VSCOOKIE   dwLHCookie);

    // This method is   used to modify the RDT doc flags for a registered document
    // the only valid   flags to modify are flags within RDT_DOCMASK.
    HRESULT ModifyDocumentFlags(VSCOOKIE docCookie, VSRDTFLAGS grfFlags, BOOL   fSet);
}

cpp_quote("#define SID_SVsRunningDocumentTable IID_IVsRunningDocumentTable")

//---------------------------------------------------------------------------
// IVsRunningDocTableEvents[2,3]
//---------------------------------------------------------------------------

[
    uuid(uuid_IVsRunningDocTableEvents),
    version(1.0),
    pointer_default(unique)
]
interface IVsRunningDocTableEvents : IUnknown
{
    HRESULT OnAfterFirstDocumentLock([in]   VSCOOKIE docCookie,
        [in]    VSRDTFLAGS dwRDTLockType,
        [in]    DWORD dwReadLocksRemaining,
        [in]    DWORD dwEditLocksRemaining);
    HRESULT OnBeforeLastDocumentUnlock([in] VSCOOKIE docCookie,
        [in] VSRDTFLAGS dwRDTLockType,
        [in] DWORD  dwReadLocksRemaining,
        [in] DWORD  dwEditLocksRemaining);
    HRESULT OnAfterSave([in] VSCOOKIE   docCookie);
    HRESULT OnAfterAttributeChange([in] VSCOOKIE docCookie, [in] VSRDTATTRIB grfAttribs);
    HRESULT OnBeforeDocumentWindowShow([in] VSCOOKIE docCookie, [in] BOOL   fFirstShow, [in] IVsWindowFrame *pFrame);
    HRESULT OnAfterDocumentWindowHide([in] VSCOOKIE docCookie, [in] IVsWindowFrame *pFrame);
};

[
    uuid(uuid_IVsRunningDocTableEvents2),
    version(1.0),
    pointer_default(unique)
]
interface IVsRunningDocTableEvents2 : IVsRunningDocTableEvents
{
    HRESULT OnAfterAttributeChangeEx([in]   VSCOOKIE docCookie,
        [in]    VSRDTATTRIB grfAttribs,
        [in]    IVsHierarchy *pHierOld,
        [in]    VSITEMID itemidOld,
        [in]    LPCOLESTR pszMkDocumentOld,                     
        [in]    IVsHierarchy *pHierNew,
        [in]    VSITEMID itemidNew,
        [in]    LPCOLESTR pszMkDocumentNew);
};

[
    uuid(uuid_IVsRunningDocTableEvents3),
    version(1.0),
    pointer_default(unique)
]
interface IVsRunningDocTableEvents3 : IVsRunningDocTableEvents2
{
    HRESULT OnBeforeSave([in]   VSCOOKIE docCookie);
};

//----------------------------------------------------------------------------
// IVsDocumentLockHolder
//----------------------------------------------------------------------------
// Implemented by parties that open documents not within standard DocumentWindows.
// This includes advanced editors (like the VC resource editor) that display a 
// tree within a special tool window (e.g. Resourece View) or parties that edit
// documents invisibly like project CodeModels. An IVsDocumentLockHolder
// is a holder of an EditLock on a document that is not held by an IVsWindowFrame. 
enum __FRAMECLOSE
{
    // these flag   bits should be the same as RDT flags
    FRAMECLOSE_NoSave         = 0x00000100 | RDTSAVEOPT_DocClose,
    FRAMECLOSE_SaveIfDirty  =   0x00000200 | RDTSAVEOPT_DocClose,
    FRAMECLOSE_PromptSave     = 0x00000400 | RDTSAVEOPT_DocClose,
};
typedef DWORD FRAMECLOSE;

[
    uuid(uuid_IVsDocumentLockHolder),
    version(1.0),
    pointer_default(unique)
]
interface IVsDocumentLockHolder : IUnknown
{
    HRESULT ShowDocumentHolder(void);       // e.g. called before prompting user to save the document locked by the holder
    HRESULT CloseDocumentHolder(FRAMECLOSE dwSaveOptions); //   expected implementation is to call UnlockDocument and then UnregisterDocumentLockHolder
}

//---------------------------------------------------------------------------
// IVsSimpleDocFactory
//---------------------------------------------------------------------------
// Used in conjunction with IVsInvisibleEditor service.
// Default implementation supplied by Environment. 
[
    uuid(uuid_IVsSimpleDocFactory)
]
interface IVsSimpleDocFactory : IUnknown
{
    // Load the given   file into a doc data object and return the given interface
    // on   that object.
    HRESULT LoadDocument ([in] LPCOLESTR pszMkDocument, [in] REFIID riid,   [out, iid_is(riid)] void **ppDocData);
};

//---------------------------------------------------------------------------
// IVsInvisibleEditor
//---------------------------------------------------------------------------
[
    uuid(uuid_IVsInvisibleEditor)
]
interface IVsInvisibleEditor : IUnknown
{
    // Obtain   the doc data for the file "under edit" by this editor object.
    // If   the file is not already open, the document factory registered with
    // this editor will be used, or the default text-file   loader if NULL was
    // registered.  If the file is already in   the RDT, it will simply be
    // QI'd for the given   interface and returned.  Editors should use this
    // function each time   they need access to the doc data (as opposed to caching
    // the doc data object, since   it may get removed from the RDT and re-loaded
    // into a   new doc data object).  If the caller intends to modify the document,
    // they should pass TRUE for fEnsureWritable,   which will query the user for
    // checking the file out as appropriate (if under   source code control).
    HRESULT GetDocData ([in] BOOL   fEnsureWritable, [in] REFIID riid, [out, iid_is(riid)] void **ppDocData);
};

//---------------------------------------------------------------------------
// IVsInvisibleEditorManager
//---------------------------------------------------------------------------
typedef enum __EDITORREGFLAGS
{
    RIEF_ENABLECACHING  =   0x00000001,       // If set, the invisible editor will keep the file loaded whenever possible
} _EDITORREGFLAGS;
typedef DWORD EDITORREGFLAGS;

[
    uuid(uuid_IVsInvisibleEditorManager)
]
interface IVsInvisibleEditorManager : IUnknown
{
    // Registers an invisible   editor on the specified document.
    //
    // pszMkDocument is the name of the document.
    //
    // pProject is the project to   which the file must belong.  If NULL is
    // supplied, the file   can belong to any project; when opened, it will
    // be   opened by whichever project responds to IsDocumentInAProject from
    // the shell (this includes the miscellaneous   files project).  
    //
    // dwFlags is   an OR'ing of zero or more EDITORREGFLAGS values:
    //
    //  REIF_ENABLECACHING:
    //  If this flag is set, the document   will be loaded and placed in the
    //  RDT immediately (if not already present),   and attempts will be made to
    //  keep the document   there as long as possible (certain actions may force
    //  it to   be unlocked, such as user closing without saving, etc.)  This
    //  allows the document to stay in the RDT in   the scenario where a
    //  document is open in a   visible editor, and closed by the user while
    //  an invisible editor is registered   for that document.
    //
    //  Otherwise, the document will NOT be loaded until GetDocData is called
    //  (unless of course   it is already in memory), and no unnecessary attempts
    //  to keep the document in the RDT while   this editor is registered will be
    //  made.
    //
    // pFactory is an   instance of IVsSimpleDocFactory that will be used to load
    // the document if it   isn't already open.  If NULL is supplied, a default
    // factory will be used which   loads the file into a shell-provided instance
    // of   IVsTextLines.
    //
    // ppEditor is filled   with the newly created and registered invisible editor
    // instance.
    HRESULT RegisterInvisibleEditor ([in]   LPCOLESTR pszMkDocument,
        [in]    IVsProject *pProject,
        [in]    EDITORREGFLAGS dwFlags,
        [in]    IVsSimpleDocFactory *pFactory,
        [out] IVsInvisibleEditor    **ppEditor);
};

cpp_quote("#define SID_SVsInvisibleEditorManager IID_IVsInvisibleEditorManager")

//---------------------------------------------------------------------------
// IVsXMLMemberIndex
//---------------------------------------------------------------------------
// Implemented by the Environment.
[
    uuid(uuid_IVsXMLMemberIndex)
]
interface IVsXMLMemberIndex : IUnknown
{
    // Create the XML file member index, or ensure that it is up to date.
    // This function will return when the index is ready for use; it will block
    // on any other thread that had already entered a call to this function,
    // or a call to GetMemberXML that needed to bring the index up to date.
    HRESULT     BuildMemberIndex ();

    // Parse a member signature into a unique member identifier.  This
    // identifier can be used later for retrieval of that member's XML, and
    // the identifier will remain valid throughout the lifetime of this
    // member index object, even if the XML source file changes.
    HRESULT     ParseMemberSignature ([in] LPCOLESTR pszSignature, [out] DWORD_PTR *pdwID);

    // Given a member ID, get the XML source corresponding to that member.
    // The XML will be surrounded by a <doc> tag, but will otherwise be the
    // exact contents of the XML (inside the <member> tag) for the member specified.
    // Note that this method will block until the index is completely constructed,
    // should that work be happening on another thread, or will begin the process
    // of constructing the index if it has not yet begun, or is out of date with
    // respect to the XML file.
    HRESULT     GetMemberXML ([in] DWORD_PTR dwID, [out] BSTR *pbstrXML);

    // Given some XML for a member (obtained by GetMemberXML), create a
    // don't-make-me-use-the-XML-parser object that picks out the pieces
    // of interest and renders them as text for you
    HRESULT     GetMemberDataFromXML ([in] LPCOLESTR pszXML, [out] IVsXMLMemberData **ppObj);
};

//---------------------------------------------------------------------------
// IVsXMLMemberIndexService
//---------------------------------------------------------------------------
// This service allows access to XML documentation corresponding to given
// metadata files.  Since these files are quite large, it is inefficient
// to use the XML parser on the entire file -- this service creates a small
// in-memory index (keyed by member signature) which can be used to pick out
// the exact hunk of XML required for individual member access.
//
// Intended usage is simple:  Query for the index service, and for each
// metadata image you want XML docs for, call CreateXMLMemberIndex(), giving
// the fully qualified name of the metadata file.  The service will use the
// appropriate logic to locate the XML file based on locale, etc., and return
// you a member index object.
//
// The three members of IVsXMLMemberIndex (above) are self explanatory, with
// the exception of BuildMemberIndex() -- it is not necessary to call thus
// function, as the member index is automatically build/updated as necessary
// upon each call to GetMemberXML.  The purpose of BuildMemberIndex is to
// allow creation of the index on a background thread (this service and each
// member index object are multi-thread safe -- once a pointer to the service
// is obtained (via the primary thread, since QueryService is NOT thread
// safe) it can be handed to worker threads without marshalling, from which
// it can be used safely).  If GetMemberXML is called when the index needs
// to be constructed (or is being constructed) the call will block until the
// XML file is scanned for member tags, all member signatures are parsed and
// hashed, and the index is built.  This is a fairly fast operation, but
// these files are quite large...
//---------------------------------------------------------------------------
[
    uuid(uuid_IVsXMLMemberIndexService)
]
interface IVsXMLMemberIndexService : IUnknown
{
    // Create a member index object for the given metadata binary.  If no
    // documentation file exists for the given binary, this function will fail.
    HRESULT     CreateXMLMemberIndex ([in] LPCOLESTR pszBinaryName, [out] IVsXMLMemberIndex **ppIndex);

    // Given some XML for a member (obtained by GetMemberXML), create a
    // don't-make-me-use-the-XML-parser object that picks out the pieces
    // of interest and renders them as text for you.  Same functionality
    // (exactly) as IVsXMLMemberIndex::GetMemberDataFromXML, but in a
    // more common place.
    HRESULT     GetMemberDataFromXML ([in] LPCOLESTR pszXML, [out] IVsXMLMemberData **ppObj);
};

//---------------------------------------------------------------------------
// IVsXMLMemberData
//---------------------------------------------------------------------------
// This is just a handy wrapper over the XML for a given member.  It extracts
// text from the XML (honoring tags like <see>, <paramref>, etc.) for things
// of interest.  If the tag for whatever is asked for doesn't exist, the
// text returned is empty and the function returns S_FALSE.
//---------------------------------------------------------------------------
[
    uuid(uuid_IVsXMLMemberData)
]
interface IVsXMLMemberData : IUnknown
{
    HRESULT     GetSummaryText ([out] BSTR *pbstrSummary);
    HRESULT     GetParamCount ([out] long *piParams);
    HRESULT     GetParamTextAt ([in] long iParam, [out] BSTR *pbstrName, [out] BSTR *pbstrText);
    HRESULT     GetReturnsText ([out] BSTR *pbstrReturns);
    HRESULT     GetRemarksText ([out] BSTR *pbstrRemarks);
};

cpp_quote("#define SID_SVsXMLMemberIndexService IID_IVsXMLMemberIndexService")


//---------------------------------------------------------------------------
// IVsWindowFrame
//---------------------------------------------------------------------------
// Implemented by the Environment.
// This interface is implemented by both Tool Windows and Documen Windows.
typedef enum __VSSETFRAMEPOS
{
    SFP_maskFrameMode       = 0x0000000f,
    SFP_fDock               = 0x00000001,
    SFP_fTab                = 0x00000002,
    SFP_fFloat          = 0x00000003,
    SFP_fMdiChild           = 0x00000004,

    SFP_maskPosition        = 0x000000f0,
    SFP_fDockTop            = 0x00000010,
    SFP_fDockBottom     = 0x00000020,
    SFP_fDockLeft           = 0x00000030,
    SFP_fDockRight      = 0x00000040,
    SFP_fTabFirst           = 0x00000010,
    SFP_fTabLast            = 0x00000020,
    SFP_fTabPrevious        = 0x00000030,
    SFP_fTabNext            = 0x00000040,

    SFP_fSize               = 0x40000000,
    SFP_fMove               = 0x80000000
} VSSETFRAMEPOS;

typedef enum __VSWINDOWSTATE
{
    VSWS_Normal         = 0,
    VSWS_Minimized      = 1,
    VSWS_Maximized      = 2
} VSWINDOWSTATE;

typedef enum __VSFRAMEMODE
{
    VSFM_Dock               = 0,
    VSFM_Float          = 1,
    VSFM_MdiChild           = 2,
    VSFM_FloatOnly      = 3,
} VSFRAMEMODE;

enum __VSFPROPID
{
    VSFPROPID_NIL                 = -1,

    VSFPROPID_LAST            = -3000,
    // The following properties are for all frame   windows
    VSFPROPID_Type            = -3000,  // I4 -> 1 == Document Frame, 2 == Tool Frame
    VSFPROPID_DocView             = -3001,  // UNK object filling client area of window
    VSFPROPID_SPFrame             = -3002,  // UNK IServiceProvider which is site object for DocView object
    VSFPROPID_SPProjContext   = -3003,  // UNK IServiceProvider provided by the owning IVsHierarchy
    //     This can be QS'ed for project context services
    VSFPROPID_Caption             = -3004,  // BSTR -> full window caption
    //VSFPROPID_                  = -3005,  // obsolete
    //VSFPROPID_                  = -3006,  // obsolete
    VSFPROPID_WindowState         = -3007,  // I4 -> see VSWINDOWSTATE above
    VSFPROPID_FrameMode       = -3008,  // I4 -> see VSFRAMEMODE above
    VSFPROPID_IsWindowTabbed      = -3009,  // I2 returns 0 if window not tabbed, 
    //            1 if window is Tabbed and is Active Tab
    //            2 if window is Tabbed and is Not Active tab
    //    Document windows always return 0
    //Note: VSFPROPID_UserContext   should now be used by all toolwindows to push context
    VSFPROPID_UserContext         = -3010,  // UNK IVsUserContext
    VSFPROPID_ViewHelper          = -3011,  // UNK Helper object can override add/override interfaces 
    //     normally implemented on the DocView object
    //     ViewHelper can implement following interfaces:
    //         IVsWindowFrameNotify
    //         IOleCommandTarget
    //         IVsToolboxUser
    //         IVsDocOutlineProvider
    //         IDocHostUIHandler
    //         IVsBackForwardNavigation
    //         IVsWindowView
    //         IVsStatusbarUser
    VSFPROPID_ShortCaption    = -3012,  // BSTR -> partial window caption (ie Foo.Txt)

    //Note: to use the default windowhelp   implementation, leave these properties unset
    //    you should only be using these properties if you are not pushing usercontext
    //    (e.g. you are a help window and don't want to blank out other user context)
    VSFPROPID_WindowHelpKeyword =   -3013,  // BSTR -> keyword to be used for cmdidWindowHelp
    VSFPROPID_WindowHelpCmdText =   -3014,  // BSTR -> command text for cmdidWindowHelp (e.g. Help on: Help Index)

    // The following properties are for all document frames
    VSFPROPID_DocCookie       = -4000,  // I4 -> IVsRunningDocumentTable (RDT) key
    VSFPROPID_OwnerCaption    = -4001,  // BSTR portion of caption defined by owner IVsHierarchy
    VSFPROPID_EditorCaption   = -4002,  // BSTR portion of caption defined by editor implementation
    VSFPROPID_pszMkDocument   = -4003,  // BSTR pszMkDocument passed to CreateDocumentWindow
    VSFPROPID_DocData         = -4004,      // UNK returns the AltDocData if available else the RDTDocData
    VSFPROPID_Hierarchy       = -4005,  // UNK owning IVsHierarchy
    VSFPROPID_ItemID          = -4006,      // I4  VSITEMID of document
    VSFPROPID_CmdUIGuid       = -4007,  // GUID used to control visibility of toolbars and AutoVisible tool windows
    VSFPROPID_CreateDocWinFlags =   -4008,  // I4 VSCREATEDOCWIN flags passed to CreateDocumentWindow 
    VSFPROPID_guidEditorType      = -4009,  // GUID guidEditorType uniquely identify which IVsEditorFactory created the document.
    VSFPROPID_pszPhysicalView     = -4010,  // BSTR identifies the type of window created by the IVsEditorFactory (e.g. "Form")
    VSFPROPID_InheritKeyBindings=   -4011,  // GUID most often used by an window to inherit the key bindings of the TextEditor
    //      e.g.: pFrame->SetGuidProperty(VSFPROPID_InheritKeyBindings, CMDUIGUID_TextEditor)
    VSFPROPID_RDTDocData          = -4012,  // UNK  the DocData registered in the RDT for the document in this frame
    VSFPROPID_AltDocData          = -4013,  // UNK  if this window is only editing a piece of a larger document
    //      then AltDocData is the DocData object for the piece of the document
    //      that is being edited within the window where as the RDTDocData 
    //      is the DocData object for the entire document registered in the RDT.
    //      AltDocData objects are not registered in the RDT. Document Windows
    //      that have AltDocData objects are created using CDW_fAltDocData flag.

    // The following properties are for all tool frames
    VSFPROPID_GuidPersistenceSlot     = -5000,  // GUID that uniquely identifies a tool window type.
    VSFPROPID_GuidAutoActivate    = -5001,  // GUID OBSOLETE. Do NOT use.
    VSFPROPID_CreateToolWinFlags      = -5002,  // I4 VSCREATETOOLWIN flags passed to CreateToolWindow 

    // the followin properties are for extensibility
    VSFPROPID_ExtWindowObject         = -5003,  // UNK returns the Environment's "Window" automation IDispatch object

    // The following properties are for all tool frames
    VSFPROPID_MultiInstanceToolNum  =   -5004,  // I4 ID of a multi-instance tool window
    VSFPROPID_BitmapResource          = -5006,  // I4 Resource number of bitmap in satellite dll
    VSFPROPID_BitmapIndex             = -5007,  // I4 index into strip if bitmap handle is a strip

    // UNK IVsToolbarHost   used to add toolbars to window.  Property is only valid if 
    // CTW_fToolbarHost or UIHWF_SupportToolWindowToolbars is   specfied.
    VSFPROPID_ToolbarHost             = -5008,  

    VSFPROPID_HideToolwinContainer  =   -5009,  // I2 make the toolwindow's cntr hidden when saving data file

    // !!!! NOTE !!!!   THIS MUST BE THE SAME AS THE LAST PROP DEFINED
    VSFPROPID_FIRST               = -5009,

};
typedef LONG VSFPROPID;


[
    uuid(uuid_IVsWindowFrame),
    version(1.0),
    pointer_default(unique)
]
interface IVsWindowFrame : IUnknown
{
    HRESULT Show(void);     // This show will activate
    HRESULT Hide(void);
    [custom(uuid_IVsWindowFrame, "preservesig")]
    HRESULT IsVisible(void);        // Returns S_OK or S_FALSE
    HRESULT ShowNoActivate(void);
    HRESULT CloseFrame(FRAMECLOSE   grfSaveOptions);
    HRESULT SetFramePos([in] VSSETFRAMEPOS dwSFP,
        [in] REFGUID rguidRelativeTo,
        [in] int x,
        [in] int y,
        [in] int cx,
        [in] int cy);
    HRESULT GetFramePos([out]   VSSETFRAMEPOS *pdwSFP,
        [out]   GUID *pguidRelativeTo,
        [out]   int *px,
        [out]   int *py,
        [out]   int *pcx,
        [out]   int *pcy);

    HRESULT GetProperty([in] VSFPROPID propid,
        [out]   VARIANT *pvar);
    HRESULT SetProperty([in] VSFPROPID propid,
        [in] VARIANT var);
    HRESULT GetGuidProperty([in] VSFPROPID propid,
        [out]   GUID *pguid);
    HRESULT SetGuidProperty([in] VSFPROPID propid,
        [in] REFGUID rguid);
    HRESULT QueryViewInterface([in] REFIID riid,
        [out, iid_is(riid)] void ** ppv);
    HRESULT IsOnScreen([out, retval] BOOL   *pfOnScreen);  
}

cpp_quote("#define SID_SVsWindowFrame IID_IVsWindowFrame")

//---------------------------------------------------------------------------
// IVsWindowFrameNotify[2]
//---------------------------------------------------------------------------
// Implemented by object set as VSFPROPID_ViewHelper.
// This interface is used in rare situations where the object sited in a 
// WindowFrame needs to know about WindowFrame events (e.g. to show a special 
// SaveChanges dialog when the window is closed for a window that edits multiple
// documents at once; such a window can listen for "OnClose(pgrfSaveOptions)" ).  
enum __FRAMESHOW
{
    FRAMESHOW_Hidden                = 0,    // obsolete, use WinHidden
    FRAMESHOW_WinHidden         = 0,    // window (tabbed or otherwise) is hidden
    FRAMESHOW_WinShown          = 1,    // a non-tabbed window is made visible
    FRAMESHOW_TabActivated      = 2,    // a tabbed window is activated (made visible)
    FRAMESHOW_TabDeactivated        = 3,    // a tabbed window is deactivated
    FRAMESHOW_WinRestored           = 4,    // window is restored to normal state
    FRAMESHOW_WinMinimized      = 5,    // window is minimized
    FRAMESHOW_WinMaximized      = 6,    // window is maximized
    FRAMESHOW_WinClosed         = 7,    // window is closed and persisted
    FRAMESHOW_DestroyMultInst       = 8,    // multi instance toolwindow destroyed
    FRAMESHOW_AutoHideSlideBegin    = 9,    // autohidden window is about to slide into view
};
typedef BOOL FRAMESHOW;

[
    uuid(uuid_IVsWindowFrameNotify),
    version(1.0),
    pointer_default(unique)
]
interface IVsWindowFrameNotify : IUnknown
{
    HRESULT OnShow([in] FRAMESHOW fShow);
    HRESULT OnMove();
    HRESULT OnSize();
    HRESULT OnDockableChange([in] BOOL fDockable);
}

[
    uuid(uuid_IVsWindowFrameNotify2),
    version(1.0),
    pointer_default(unique)
]
interface IVsWindowFrameNotify2 : IUnknown
{
    HRESULT OnClose([in, out]   FRAMECLOSE *pgrfSaveOptions);
}

//----------------------------------------------------------------------------
// IVsBackForwardNavigation
//----------------------------------------------------------------------------
// Implemented by the VSFPROPID_ViewHelper or VSFPROPID_DocView object in a WindowFrame.
// This is an advanced interface rarely implemented.
// Allows the window to particpate in Back/Forward Navigation stack for navigations 
// within the window. e.g. the TextEditor adds navigation points for cursor movements
// within the TextView. IVsUIShell::AddNewBFNavigationItem is used to add a navigation 
// point. Navigations between window activations is automatically handled by the Environment. 
[
    uuid(uuid_IVsBackForwardNavigation),
    version(1.0),
    pointer_default(unique)
]
interface IVsBackForwardNavigation : IUnknown
{
    HRESULT NavigateTo([in] IVsWindowFrame *pFrame,
        [in] BSTR bstrData,
        [in] IUnknown *punk);

    HRESULT IsEqual(     [in] IVsWindowFrame *pFrame,
        [in] BSTR bstrData,
        [in] IUnknown *punk,
        [out, retval] BOOL  *fReplaceSelf);
}


//---------------------------------------------------------------------------
// IVsWindowView
//---------------------------------------------------------------------------
// Implemented by the VSFPROPID_ViewHelper or VSFPROPID_DocView object in a WindowFrame.
// This is an advanced interface rarely implemented.
enum __VSVPROPID
{
    VSVPROPID_NIL                 = -1,

    VSVPROPID_BitmapGuidPackage   = -6000,  // GUID of the package that is providing the bitmap  
    VSVPROPID_BitmapResource          = -6001,  // I4   Resource number of bitmap in satellite dll
    VSVPROPID_BitmapIndex             = -6002,  // I4   index into strip if bitmap handle is a strip

    // !!!! NOTE !!!!   THIS MUST BE THE SAME AS THE LAST PROP DEFINED
    VSVPROPID_FIRST       = -6002,
};
typedef LONG VSVPROPID;

[
    uuid(uuid_IVsWindowView),
    version(1.0),
    pointer_default(unique)
]
interface IVsWindowView : IUnknown
{
    HRESULT GetProperty([in] VSVPROPID propid,
        [out]   VARIANT *pvar);
    HRESULT SetProperty([in] VSVPROPID propid,
        [in] VARIANT var);
    HRESULT GetGuidProperty([in] VSVPROPID propid,
        [out]   GUID *pguid);
    HRESULT SetGuidProperty([in] VSVPROPID propid,
        [in] REFGUID rguid);
}


//---------------------------------------------------------------------------
// IVsToolWindowToolbarHost
//---------------------------------------------------------------------------
// Implemented by the Environment.
// Used by tool windows that want to have a toolbar within the window.
// Use VSFPROPID_ToolbarHost to access the IVsToolWindowToolbarHost implementation
// of a WindowFrame. IVsUIShell::SetupToolbar used to actually add toolbars to
// the window. In order to enable the ability to have a IVsToolWindowToolbarHost
// CTW_fToolbarHost should be passed to IVsUIShell::CreateToolWindow or 
// UIHWF_SupportToolWindowToolbars passed to IVsUIHierarchyWindow::Init.
typedef enum {VSTWT_LEFT, VSTWT_TOP, VSTWT_RIGHT, VSTWT_BOTTOM} VSTWT_LOCATION;

[
    uuid(uuid_IVsToolWindowToolbarHost),
    version(1.0),
    pointer_default(unique)
]
interface IVsToolWindowToolbarHost : IUnknown
{
    HRESULT AddToolbar([in] VSTWT_LOCATION dwLoc,
        [in] const  GUID *pguid,
        [in] DWORD  dwId);
    HRESULT BorderChanged();    
    HRESULT ShowHideToolbar([in] const GUID *   pguid,
        [in] DWORD dwId,
        [in] BOOL   fShow);
    HRESULT ProcessMouseActivation([in] HWND hwnd,
        [in] UINT msg,
        [in] WPARAM wp,
        [in] LPARAM lp);
    HRESULT ForceUpdateUI(void);        // Force toolbar set to update enabling state synchronously

    // Same as ProcessMouseActivation, but for modal windows/dialogs containing
    //  toolbars.    If this method returns S_FALSE, the caller should return from
    //  its WndProc immediately with the value stored   in plResult. Otherwise the
    //  caller should   process it as it normally does.  There is no harm in a
    //  non-modal   tool window calling this function, as it is a safe superset of
    //  the functionality   in ProcessMouseActivation.
    HRESULT ProcessMouseActivationModal([in] HWND   hwnd,
        [in] UINT   msg,
        [in] WPARAM wp,
        [in] LPARAM lp,
        [out]   LRESULT *plResult);

    // The Close method is used to disconnect   the toolbar host from its site object.
    // This will cause the toolbar host to call Release on the IVsToolWindowToolbar
    // ptr it   is holding, so callers should use a ref-guard to protect against
    // premature deletes from   calling this method.
    // The Reserved in param must   be zero.
    HRESULT Close([in] DWORD dwReserved);

    // Show the toolbar set associated with this toolbar host
    HRESULT Show([in]   DWORD dwReserved);

    // Hide the toolbar set associated with this toolbar host
    HRESULT Hide([in]   DWORD dwReserved);
}


//---------------------------------------------------------------------------
// IVsToolWindowToolbar
//---------------------------------------------------------------------------
// Implemented by the object sited in a WindowFrame that wants to host toolbars.
// This interface is passed to IVsUIShell::SetupToolbar.
[
    uuid(uuid_IVsToolWindowToolbar),
    version(1.0),
    pointer_default(unique)
]
interface IVsToolWindowToolbar : IUnknown
{
    HRESULT GetBorder([out] RECT *prc);
    HRESULT SetBorderSpace([in] LPCBORDERWIDTHS pbw);
}

//---------------------------------------------------------------------------
// IVsUIShell
//---------------------------------------------------------------------------
// Implemented by the Environment.
// This service coordinates most aspects of the UI for the Environment.
typedef enum __VSSAVEFLAGS
{
    VSSAVE_Save = 0,
    VSSAVE_SaveAs   = 1,
    VSSAVE_SilentSave   = 2,
    VSSAVE_SaveCopyAs   = 3,
} VSSAVEFLAGS;

typedef enum __VSSYSCOLOR
{
    VSCOLOR_LIGHT            = -1,  // one interval lighter than COLOR_BTNFACE
    VSCOLOR_MEDIUM       = -2,  // one interval darker  than COLOR_BTNFACE
    VSCOLOR_DARK             = -3,  // one interval darker  than COLOR_BTNSHADOW
    VSCOLOR_LIGHTCAPTION     = -4,  // one interval lighter than COLOR_ACTIVECAPTION

    VSCOLOR_LAST             = -4,  // must be set to the last color enum above
} VSSYSCOLOR;

enum __VSCREATETOOLWIN
{
    CTW_RESERVED_MASK           = 0x0000FFFF, // reserved bits
    CTW_fInitNew                = 0x00010000,
    CTW_fActivateWithProject    = 0x00020000,
    CTW_fActivateWithDocument   = 0x00040000,
    CTW_fForceCreate            = 0x00080000,
    CTW_fHasBorder          = 0x00100000,
    CTW_fMultiInstance      = 0x00200000,
    CTW_fToolbarHost            = 0x00400000,
};
typedef DWORD VSCREATETOOLWIN;

enum __VSCREATEDOCWIN
{
    CDW_RDTFLAGS_MASK      = 0x000FFFFF,
    CDW_fDockable          = 0x00100000,
    CDW_fAltDocData    = 0x00200000,
    CDW_fCreateNewWindow = 0x00400000,  // allow an additional window   to be created for Window.NewWindow support
};
typedef DWORD VSCREATEDOCWIN;

enum __VSFINDTOOLWIN
{
    FTW_fForceCreate        = 0x00080000,
    FTW_fFindFirst      = 0x00800000, // find first multiinst tool window (ignore dwToolWinId)
    FTW_fFrameOnly      = 0x01000000, // just get the frame, don't care if there's an object behind it
};
typedef DWORD VSFINDTOOLWIN;

typedef enum __DBGMODE {
    DBGMODE_Design  = 0x00000000,   // Design mode - no code executing
    DBGMODE_Break       = 0x00000001,   // stopped in breakmode
    DBGMODE_Run     = 0x00000002,   // Attached to application and running
    DBGMODE_Enc     = 0x10000000,   // High bit indicates Edit and Continue mode
    DBGMODE_EncMask = 0xF0000000
} DBGMODE;

typedef enum _RemoveBFDirection
{
    RemovePrev,
    RemoveNext
}RemoveBFDirection;

// GUIDs used in calling IVsShell::CreateToolWindow()
cpp_quote("extern const __declspec(selectany) GUID GUID_Toolbox =  { 0xb1e99781, 0xab81, 0x11d0, { 0xb6, 0x83, 0x0, 0xaa, 0x0, 0xa3, 0xee, 0x26 } };")
cpp_quote("extern const __declspec(selectany) GUID GUID_PropertyBrowser = { 0xeefa5220, 0xe298, 0x11d0, { 0x8f, 0x78, 0x0, 0xa0, 0xc9, 0x11, 0x0, 0x57 } };")
cpp_quote("extern const __declspec(selectany) GUID GUID_SolutionExplorer = { 0x3ae79031, 0xe1bc, 0x11d0, { 0x8f, 0x78, 0x0, 0xa0, 0xc9, 0x11, 0x0, 0x57 } };")
cpp_quote("extern const __declspec(selectany) GUID GUID_OutputWindow = { 0x34e76e81, 0xee4a, 0x11d0, {0xae, 0x2e, 0x00, 0xa0, 0xc9, 0x0f, 0xff, 0xc3 } };")
cpp_quote("extern const __declspec(selectany) GUID GUID_DocOutline = { 0x25f7e850, 0xffa1, 0x11d0, { 0xb6, 0x3f, 0x0, 0xa0, 0xc9, 0x22, 0xe8, 0x51 } };")
cpp_quote("extern const __declspec(selectany) GUID GUID_TaskList = { 0x4a9b7e51, 0xaa16, 0x11d0, {0xa8, 0xc5, 0x0, 0xa0, 0xc9, 0x21, 0xa4, 0xd2 } };")
cpp_quote("extern const __declspec(selectany) GUID GUID_ServerExplorer = { 0x74946827, 0x37a0, 0x11d2, { 0xa2, 0x73, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0xff} };")
// { 0x3154ba3c, 0x7cfb, 0x11d2, { 0x89, 0x6c, 0x0, 0x0, 0xf8, 0x75, 0x57, 0xaa }   };")
cpp_quote("extern const __declspec(selectany) GUID GUID_MacroExplorer = { 0x7cd18b4, 0x3ba1, 0x11d2, { 0x89, 0xa, 0x0, 0x60, 0x8, 0x31, 0x96, 0xc6 } };")
cpp_quote("extern const __declspec(selectany) GUID GUID_ContextWindow = { 0x66dba47c, 0x61df, 0x11d2, { 0xaa, 0x79, 0x00, 0xc0, 0x4f, 0x99, 0x03, 0x43 } };")

// {C9C0AE26-AA77-11d2-B3F0-0000F87570EE}
cpp_quote("extern const __declspec(selectany) GUID GUID_ClassView =  { 0xc9c0ae26, 0xaa77, 0x11d2, { 0xb3, 0xf0, 0x0, 0x0, 0xf8, 0x75, 0x70, 0xee } };")
// {2D7728C2-DE0A-45b5-99AA-89B609DFDE73}
cpp_quote("extern const __declspec(selectany) GUID GUID_ResourceView =  { 0x2d7728c2, 0xde0a, 0x45b5, { 0x99, 0xaa, 0x89, 0xb6, 0x9, 0xdf, 0xde, 0x73 } };")
// {53024D34-0EF5-11d3-87E0-00C04F7971A5}
cpp_quote("extern const __declspec(selectany) GUID GUID_ObjectSearchWindow = { 0x53024d34, 0xef5, 0x11d3, { 0x87, 0xe0, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xa5 } };")
cpp_quote("extern const __declspec(selectany) GUID GUID_CommandWindow =     { 0x28836128, 0xfc2c, 0x11d2, { 0xa4, 0x33, 0x0, 0xc0, 0x4f, 0x72, 0xd1, 0x8a } };")

// {68487888-204A-11d3-87EB-00C04F7971A5}
cpp_quote("extern const __declspec(selectany) GUID GUID_ObjectSearchResultsWindow = { 0x68487888, 0x204a, 0x11d3, { 0x87, 0xeb, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xa5 } };")
// {269A02DC-6AF8-11D3-BDC4-00C04F688E50}
cpp_quote("extern const __declspec(selectany) GUID GUID_ObjBrowser = { 0x269a02dc, 0x6af8, 0x11d3, { 0xbd, 0xc4, 0x0, 0xc0, 0x4f, 0x68, 0x8e, 0x50 } };")
cpp_quote("extern const __declspec(selectany) GUID GUID_BrowserDoc = { 0x6B8E94B4, 0x0949, 0x4d9c, { 0xA8, 0x1F, 0xC1, 0xB9, 0xB7, 0x44, 0x18, 0x5C} };")

// similar to OPENFILENAMEW struct
typedef struct _VSOPENFILENAME
{
    DWORD     lStructSize;
    HWND      hwndOwner;
    LPCWSTR pwzDlgTitle;
    LPWSTR  pwzFileName;
    DWORD     nMaxFileName;
    LPCWSTR pwzInitialDir;
    LPCWSTR pwzFilter;
    DWORD     nFilterIndex;
    DWORD     nFileOffset;
    DWORD     nFileExtension;
    DWORD     dwHelpTopic;
    DWORD     dwFlags; // standard OFN_* flags plus below additions
} VSOPENFILENAMEW, *PVSOPENFILENAMEW;

// non-standard VS-specific OFN flags
cpp_quote("#define OFN_ALLOWONLYFILESYSLOCS 0x80000000")

// similar to OPENFILENAMEW struct
typedef struct _VSSAVEFILENAME
{
    DWORD                lStructSize;
    HWND                 hwndOwner;
    LPCWSTR          pwzDlgTitle;
    LPWSTR           pwzFileName;
    DWORD                nMaxFileName;
    LPCWSTR          pwzInitialDir;
    LPCWSTR          pwzFilter;
    DWORD                nFilterIndex;
    DWORD                nFileOffset;
    DWORD                nFileExtension;
    DWORD                dwHelpTopic;
    DWORD                dwFlags; // standard OFN_* flags
    IVsSaveOptionsDlg   *pSaveOpts;
} VSSAVEFILENAMEW, *PVSSAVEFILENAMEW;

// similar to BROWSEINFOW struct
typedef struct _VSBROWSEINFOW
{
    DWORD           lStructSize;
    HWND            hwndOwner;
    LPCWSTR     pwzDlgTitle;
    LPWSTR      pwzDirName;
    DWORD           nMaxDirName;
    LPCWSTR     pwzInitialDir;
    DWORD           dwHelpTopic;
    DWORD           dwFlags; // standard BIF_* flags
} VSBROWSEINFOW, *PVSBROWSEINFOW;

[
    uuid(uuid_IVsUIShell),
    version(1.0)
]
interface IVsUIShell : IUnknown
{
    HRESULT GetToolWindowEnum([out] IEnumWindowFrames   **ppEnum);
    HRESULT GetDocumentWindowEnum([out] IEnumWindowFrames   **ppEnum);
    HRESULT FindToolWindow([in] VSFINDTOOLWIN   grfFTW,
        [in] REFGUID rguidPersistenceSlot,
        [out] IVsWindowFrame **ppWindowFrame);
    HRESULT CreateToolWindow([in]   VSCREATETOOLWIN grfCTW,
        [in]    DWORD dwToolWindowId,
        [in]    IUnknown *punkTool,
        [in]    REFCLSID rclsidTool,
        [in]    REFGUID rguidPersistenceSlot,
        [in]    REFGUID rguidAutoActivate,
        [in]    IServiceProvider *pSP,
        [in]    LPCOLESTR pszCaption,
        [out] BOOL *pfDefaultPosition,
        [out] IVsWindowFrame    **ppWindowFrame);
    HRESULT CreateDocumentWindow([in]   VSCREATEDOCWIN grfCDW,
        [in]    LPCOLESTR pszMkDocument,
        [in]    IVsUIHierarchy *pUIH,
        [in]    VSITEMID itemid,
        [in]    IUnknown *punkDocView,
        [in]    IUnknown *punkDocData,
        [in]    REFGUID rguidEditorType,
        [in]    LPCOLESTR pszPhysicalView,
        [in]    REFGUID rguidCmdUI,
        [in]    IServiceProvider *pSP,
        [in]    LPCOLESTR pszOwnerCaption,
        [in]    LPCOLESTR pszEditorCaption,
        [out] BOOL *pfDefaultPosition,
        [out] IVsWindowFrame    **ppWindowFrame);
    HRESULT SetErrorInfo([in]   HRESULT hr,
        [in]    LPCOLESTR pszDescription,
        [in]    DWORD dwReserved, //must be 0
        [in]    LPCOLESTR pszHelpKeyword, //keyword to attach to a help button on the message box
        [in]    LPCOLESTR pszSource);
    HRESULT ReportErrorInfo([in] HRESULT hr);
    HRESULT GetDialogOwnerHwnd([out] HWND   * phwnd);
    HRESULT EnableModeless([in] BOOL fEnable);
    //SaveDocDataToFile may return STG_S_DATALOSS   to indicate some characters could not be represented in the current codepage
    HRESULT SaveDocDataToFile([in] VSSAVEFLAGS grfSave,
        [in] IUnknown *pPersistFile,
        [in] LPCOLESTR pszUntitledPath,
        [out] BSTR *pbstrDocumentNew,
        [out] BOOL *pfCanceled);
    [local] HRESULT SetupToolbar([in]   HWND hwnd,
        [in] IVsToolWindowToolbar *ptwt,
        [out] IVsToolWindowToolbarHost **pptwth);
    HRESULT SetForegroundWindow(void);

    HRESULT TranslateAcceleratorAsACmd([in] LPMSG   pMsg);

    HRESULT UpdateCommandUI([in] BOOL   fImmediateUpdate);

    HRESULT UpdateDocDataIsDirtyFeedback([in]   VSCOOKIE docCookie, [in] BOOL fDirty);
    HRESULT RefreshPropertyBrowser([in]DISPID   dispid);
    HRESULT SetWaitCursor();

    HRESULT PostExecCommand([in, unique] const GUID *   pguidCmdGroup,
        [in]           DWORD        nCmdID,
        [in]           DWORD        nCmdexecopt,
        [in, unique] VARIANT *  pvaIn);

    HRESULT ShowContextMenu ([in]   DWORD dwCompRole,
        [in]    REFCLSID rclsidActive,
        [in]    LONG nMenuId,
        [in]    REFPOINTS pos,
        [in]    IOleCommandTarget *pCmdTrgtActive);

    HRESULT ShowMessageBox ([in]        DWORD dwCompRole,
        [in]        REFCLSID rclsidComp,
        [in]        LPOLESTR pszTitle,
        [in]        LPOLESTR pszText,
        [in]        LPOLESTR pszHelpFile,
        [in]        DWORD dwHelpContextID,
        [in]        OLEMSGBUTTON msgbtn,
        [in]        OLEMSGDEFBUTTON msgdefbtn,
        [in]        OLEMSGICON msgicon,
        [in]        BOOL fSysAlert,
        [out][retval]   LONG *pnResult);

    HRESULT SetMRUComboText ([in]           const GUID * pguidCmdGroup,
        [in]            DWORD        dwCmdId,
        [in]            LPSTR        lpszText,
        [in]            BOOL         fAddToList);

    HRESULT SetToolbarVisibleInFullScreen   ([in] const GUID *pguidCmdGroup,
        [in] DWORD  dwToolbarId,
        [in] BOOL fVisibleInFullScreen);

    HRESULT FindToolWindowEx([in]    VSFINDTOOLWIN grfFTW,
        [in]     REFGUID rguidPersistenceSlot,
        [in]     DWORD   dwToolWinId,   
        [out] IVsWindowFrame    **ppWindowFrame);

    HRESULT GetAppName([out] BSTR   * pbstrAppName);

    HRESULT GetVSSysColor([in]  VSSYSCOLOR  dwSysColIndex,
        [out] DWORD       *pdwRGBval);

    HRESULT SetMRUComboTextW([in]           const GUID * pguidCmdGroup,
        [in]            DWORD        dwCmdId,
        [in]            LPWSTR       pwszText,
        [in]            BOOL         fAddToList);

    HRESULT PostSetFocusMenuCommand ([in,   unique] const GUID *pguidCmdGroup,
        [in]            DWORD       nCmdId);

    HRESULT GetCurrentBFNavigationItem([out] IVsWindowFrame **ppWindowFrame,
        [out] BSTR  * pbstrData,
        [out] IUnknown  **ppunk);


    HRESULT AddNewBFNavigationItem([in] IVsWindowFrame *pWindowFrame,
        [in] BSTR bstrData,
        [in] IUnknown *punk,
        [in] BOOL fReplaceCurrent);

    HRESULT OnModeChange ([in] DBGMODE dbgmodeNew);
    HRESULT GetErrorInfo([out]BSTR *pbstrErrText);
    // bring up the MSO Open dialog to obtain   a open file name.  NOTE: using struct similar
    // to   OPENFILENAMEW structure to facilitate conversion from GetOpenFileNameW system API.

    [custom(uuid_IVsUIShell, "preservesig")]
    HRESULT GetOpenFileNameViaDlg([in,out] VSOPENFILENAMEW *pOpenFileName);
    // bring up the MSO Save As dialog to   obtain a save file name.  NOTE: using struct similar
    // to   OPENFILENAMEW structure to facilitate conversion from GetOpenFileNameW system API.

    [custom(uuid_IVsUIShell, "preservesig")]
    HRESULT GetSaveFileNameViaDlg([in,out] VSSAVEFILENAMEW *pSaveFileName);
    // bring up the MSO Browse dialog   to obtain a directory name.  NOTE: using struct similar
    // to   BROWSEINFOW structure to facilitate conversion from SHBrowseForFolderW Shell32 API.
    HRESULT GetDirectoryViaBrowseDlg([in,out]   VSBROWSEINFOW *pBrowse);
    // center   the provided dialog HWND on the parent HWND (if provided), or on the main IDE window.
    // if   the IDE is in SDI mode the dialog HWND will be centered on the monitor workspace.
    [local ]HRESULT CenterDialogOnWindow([in]   HWND hwndDialog, [in] HWND hwndParent);
    HRESULT GetPreviousBFNavigationItem([out]   IVsWindowFrame **ppWindowFrame,
        [out] BSTR  * pbstrData,
        [out] IUnknown  **ppunk);
    HRESULT GetNextBFNavigationItem([out]   IVsWindowFrame **ppWindowFrame,
        [out] BSTR  * pbstrData,
        [out] IUnknown  **ppunk);
    // bring up the simple URL entry dialog to obtain   a URL from user.
    HRESULT GetURLViaDlg([in]   LPCOLESTR pszDlgTitle, [in] LPCOLESTR pszStaticLabel, [in] LPCOLESTR pszHelpTopic, [out] BSTR *pbstrURL);
    HRESULT RemoveAdjacentBFNavigationItem([in] RemoveBFDirection   rdDir);
    HRESULT RemoveCurrentNavigationDupes([in]RemoveBFDirection rdDir);
}

cpp_quote("#define SID_SVsUIShell IID_IVsUIShell")


//----------------------------------------------------------------------------
// IVsUIShellDocumentWindowMgr
//----------------------------------------------------------------------------
// Implemented by the Environment. Rarely used.
[
    local,
    uuid(uuid_IVsUIShellDocumentWindowMgr),
    version(1.0)
]
interface  IVsUIShellDocumentWindowMgr : IUnknown
{
    // Save the window positions and guidEditorType/pszPhysicalView for each open   document window into a stream
    HRESULT SaveDocumentWindowPositions([in] DWORD dwReserved, [in] IStream *   pStream);
    // Reopen   all document windows from the window position information in the stream.
    HRESULT ReopenDocumentWindows([in] IStream *pStream);
}

cpp_quote("#define SID_SVsUIShellDocumentWindowMgr IID_IVsUIShellDocumentWindowMgr")


//----------------------------------------------------------------------------
// IVsPackageDynamicToolOwner
//----------------------------------------------------------------------------
// Only VsPackages that own tool windows that are not created with
// CTW_fForceCreate flag need to implement this interface.
// This interface is retrieved by QI from IVsPackage.
[
    uuid(uuid_IVsPackageDynamicToolOwner),
    version(1.0),
    pointer_default(unique)
]
interface IVsPackageDynamicToolOwner : IUnknown
{
    // This method allows   the Package to use dynamic logic to control
    // whether the ToolWindow   should be shown or hidden. This method is
    // called   by the Environment when the user switches which window view
    //set   (or mode) is active, e.g. Design, Debugging, FullScreen, etc.
    HRESULT QueryShowTool([in] REFGUID rguidPersistenceSlot, [out] BOOL *pfShowTool);
}

cpp_quote("#define SID_SIVsPackageDynamicToolOwner IID_IVsPackageDynamicToolOwner")

//----------------------------------------------------------------------------
// IVsExternalFilesManager[2]
//----------------------------------------------------------------------------
// Implemented by the Environment.
// This service is implemented by the MiscFiles (aka ExternalFiles) project.
// For example, the service is used by "directory-based" project systems that 
// need to hand off an open file to the MiscFiles project after a SaveAs operation 
// saves the file outside of the project directory.
[
    uuid(uuid_IVsExternalFilesManager),
    version(1.0),,
    pointer_default(unique)
]
interface IVsExternalFilesManager : IUnknown
{
    HRESULT GetExternalFilesProject([out]   IVsProject **ppProject);
    HRESULT TransferDocument([in]   LPCOLESTR pszMkDocumentOld,
        [in]    LPCOLESTR pszMkDocumentNew,
        [in]    IVsWindowFrame *punkWindowFrame);
    HRESULT AddDocument([in]    VSCREATEDOCWIN dwCDW,
        [in]    LPCOLESTR pszMkDocument,
        [in]    IUnknown *punkDocView,
        [in]    IUnknown *punkDocData,
        [in]    REFGUID rguidEditorType,
        [in]    LPCOLESTR pszPhysicalView,
        [in]    REFGUID rguidCmdUI,
        [in]    LPCOLESTR pszOwnerCaption,
        [in]    LPCOLESTR pszEditorCaption,
        [out]   BOOL *pfDefaultPosition,
        [out]   IVsWindowFrame **ppWindowFrame);
    HRESULT IsVisible([out] BOOL *pfVisible);
}

cpp_quote("#define SID_SVsExternalFilesManager IID_IVsExternalFilesManager")

[
    uuid(uuid_IVsExternalFilesManager2),
    version(1.0),
    pointer_default(unique)
]
interface IVsExternalFilesManager2 : IVsExternalFilesManager
{
    [local] HRESULT AddDocumentEx([in]  VSCREATEDOCWIN dwCDW,
        [in]    LPCOLESTR pszMkDocument,
        [in]    IUnknown *punkDocView,
        [in]    IUnknown *punkDocData,
        [in]    REFGUID rguidEditorType,
        [in]    LPCOLESTR pszPhysicalView,
        [in]    REFGUID rguidCmdUI,
        [in]    LPCOLESTR pszOwnerCaption,
        [in]    LPCOLESTR pszEditorCaption,
        [in]    IServiceProvider *pspContext,
        [in]    HICON hIcon,
        [out]   BOOL *pfDefaultPosition,
        [out]   IVsWindowFrame **ppWindowFrame);
}


//----------------------------------------------------------------------------
// IVsFileChange
//----------------------------------------------------------------------------
// Implemented by the clients of the SVsFileChangeEx service.
// e.g. implemented by projects and editors that want to track FileChange events 
// from the file system.
enum _VSFILECHANGEFLAGS
{
    VSFILECHG_Attr  =   0x00000001,
    VSFILECHG_Time  =   0x00000002,
    VSFILECHG_Size  =   0x00000004,
    VSFILECHG_Del       =   0x00000008,
    VSFILECHG_Add       =   0x00000010,
};

typedef DWORD VSFILECHANGEFLAGS;

[
    uuid(uuid_IVsFileChangeEvents),
    version(1.0),
    pointer_default(unique)
]
interface IVsFileChangeEvents : IUnknown
{
    HRESULT FilesChanged([in]   DWORD cChanges,
        [in,    size_is(cChanges)] LPCOLESTR rgpszFile[],
        [in,    size_is(cChanges)] VSFILECHANGEFLAGS rggrfChange[]);
    HRESULT DirectoryChanged([in]   LPCOLESTR pszDirectory);
}

//----------------------------------------------------------------------------
// IVsFileChangeEx
//----------------------------------------------------------------------------
// Implemented by the Environment.
// Used by projects and editors that want to track FileChange events from the file system.
[
    uuid(uuid_IVsFileChangeEx),
    version(1.0),
    pointer_default(unique)
]
interface IVsFileChangeEx : IUnknown
{
    HRESULT AdviseFileChange([in]   LPCOLESTR pszMkDocument, [in] VSFILECHANGEFLAGS grfFilter, [in] IVsFileChangeEvents *pFCE, [out] VSCOOKIE *pvsCookie);
    HRESULT UnadviseFileChange([in] VSCOOKIE vsCookie);

    HRESULT SyncFile([in]   LPCOLESTR pszMkDocument);
    HRESULT IgnoreFile([in] VSCOOKIE vsCookie, [in] LPCOLESTR   pszMkDocument, [in] BOOL fIgnore);               

    HRESULT AdviseDirChange([in] LPCOLESTR pszDir, [in] BOOL fWatchSubDir, [in] IVsFileChangeEvents *pFCE, [out] VSCOOKIE   *pvsCookie);
    HRESULT UnadviseDirChange([in] VSCOOKIE vsCookie);
}

cpp_quote("#define SID_SVsFileChangeEx IID_IVsFileChangeEx")

//--------------------------------------------------------
// IVsFileChange
//--------------------------------------------------------
// OBSOLETE. do not use this interface. Use IVsFileChangeEx instead.
[
    uuid(uuid_IVsFileChange),
    version(1.0),
    pointer_default(unique)
]
interface IVsFileChange : IUnknown
{
    HRESULT AdviseFileChangeEvents([in] IVsFileChangeEvents *pFCE, [out] VSCOOKIE   *pdwAdvise);
    HRESULT UnadviseFileChangeEvents([in]   VSCOOKIE dwAdvise);
    HRESULT AddFile([in] VSCOOKIE   dwAdvise,
        [in] LPCOLESTR pszMkDocument,
        [in] VSFILECHANGEFLAGS grfFilter);
    HRESULT RemoveFile([in] VSCOOKIE dwAdvise,
        [in] LPCOLESTR  pszMkDocument);
    HRESULT AddDirectory([in]   VSCOOKIE dwAdvise,
        [in] LPCOLESTR pszPath,
        [in] BOOL   fWatchSubDir,
        [in] VSFILECHANGEFLAGS grfFilter);
    HRESULT RemoveDirectory([in] VSCOOKIE   dwAdvise,
        [in] LPCOLESTR pszMkDocument);
    HRESULT SyncFile([in]   LPCOLESTR pszMkDocument);
    HRESULT IgnoreFile([in] VSCOOKIE dwAdvise,
        [in] LPCOLESTR  pszMkDocument,
        [in] BOOL fIgnore);
}

cpp_quote("#define SID_SVsFileChange IID_IVsFileChange")

//---------------------------------------------------------------------------
// interface IVsIME
//---------------------------------------------------------------------------
// Implemented by the Environment.

typedef enum __VSIME_ERR
{
    IMENORMAL           = 0,
    IMENOTLD            = -1,
    ERRLDLIB            = -2,
    ERRGETIMEPROC       = -3,
    ERRGALLOC           = -4,
    ERRGLOCK            = -5,
    ERRGETIMEINF        = -6,
    ERRSETIMEKEY        = -7,
    ERRNLSENABLEPROC    = -8,
    ERRWINNLSNOTFOUND   = -9,
    ERRIMPGETIMEPROC    = -10,
    ERRINVALIDHWND  = -11
}   VSIME_ERR;

cpp_quote ("#ifndef _IMM_ // IMM.H")
typedef DWORD_PTR  HIMC;
typedef struct tagCANDIDATEFORM {
    DWORD dwIndex;
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT  rcArea;
} CANDIDATEFORM;
cpp_quote ("#endif")

[
    local,
    uuid(uuid_IVsIME),
    version(1.0)
]
interface IVsIME : IUnknown
{
    // JPIsIMEActive
    HRESULT IsActive([in]   HWND hwnd, [out] BOOL * pfRetVal);
    // JPActIME
    HRESULT Activate([in]   HWND hwnd, [out] VSIME_ERR * perr);
    // JPInActIME
    HRESULT Deactivate([in] HWND hwnd, [out] VSIME_ERR * perr);
    // JPFInActIME
    HRESULT FDeactivate([in] HWND   hwnd, [in] BOOL fDisable, [out] VSIME_ERR * perr);
    // JPSetIMEFont
    HRESULT SetFont([in] HWND   hwnd, [in] HFONT hf, [out] VSIME_ERR * perr);
    // JPSetIMECurPos
    HRESULT SetCurPos([in] HWND hwnd,    [in] int x,  [in] int y,  [out] VSIME_ERR * perr);
    // JPSetIMEDefCurPos
    HRESULT SetDefCurPos([in]   HWND hwnd, [out] VSIME_ERR * perr);

    // Higher-level IME support methods
    // NOTES:
    // - bstrCompString and bstrReadString are binary   buffers, not Unicode
    //   strings.   Use SysAllocStringByteLen, SysStringByteLen to manage
    //   memory for these   items.
    //   See ImmSetCompositionString and ImmGetCompositionString in the
    //   Win32 SDK for more information.

    HRESULT AttachContext([in] HWND hwnd,   [in] BOOL fAttach, [out] VSIME_ERR * perr);

    // JPGetImmContext
    HRESULT GetImmContext([in] HWND hwnd,   [out] HIMC * phimc);

    // JPReleaseImmContext
    HRESULT ReleaseImmContext([in] HWND hwnd,
        [in] HIMC himc,
        [out] BOOL * pfRetVal);

    // JPGetImmCompositionString
    HRESULT GetImmCompositionString([in] HIMC   himc,
        [in] DWORD dwIndex,
        [out]   BSTR *pbstrCompString,
        [out]   LONG * plRetVal);
    // JPSetImmCompositionString
    HRESULT SetImmCompositionString([in] HIMC   himc,
        [in] DWORD dwIndex,
        [in] BSTR   bstrCompString,
        [in] BSTR   bstrReadString,
        [out]   BOOL * pfRetVal);

    // JPSetImmCandidateWindow
    HRESULT SetImmCandidateWindow([in] HIMC himc,
        [in] CANDIDATEFORM * lpcf,
        [out] BOOL * pfRetVal);

    // JPNotifyIME
    HRESULT Notify([in] HIMC himc,
        [in] DWORD  dwAction,
        [in] DWORD  dwIndex,
        [in] DWORD  dwValue,
        [out] BOOL  * pfRetVal);

    // Note: The Escape method wraps a call to ImmEscape, which returns 
    // a 64-bit value (LRESULT) on 64-bit Windows, but Escape returns only 
    // the least-significant 32 bits of the result.  If this is not suitable
    // in a 64-bit context, just call ImmEscape directly.
    HRESULT Escape([in] HKL hkl,
        [in] HIMC himc,
        [in] UINT uEsc,
        [in, out] BSTR  bstrData,
        [out] LONG  * plRetVal);

    HRESULT GetDefaultWindow([in]   HWND hwnd,
        [out] HWND* phRetVal);

    // JPGetImmCompositionStringW
    HRESULT GetImmCompositionStringW([in]   HIMC himc,
        [in]    DWORD dwIndex,
        [out] BSTR *pbstrCompString,
        [out] LONG *    plRetVal);
}

cpp_quote("#define SID_SVsIME IID_IVsIME")

// ---------------------------------------------------------------------------------
// IVsRelativePathResolver
// ---------------------------------------------------------------------------------
//      Objects that implement this interface can participate in the resolving of a
//      relative path into an absolute path by the
//      IVsUIShellOpenDocument::SearchProjectsForRelativePath implementation. This
//      must be implemented on an object that is proffered as a service. This often
//      will be the LanguageService object associated with extending the text editor
//      for a particular language. This interface allows a project language service
//      to resolve relative paths against non-project items (e.g. if a project has
//      the concept of an INCLUDE search path). A language system that had the
//      notion of global search paths as well as per-project search path may involve
//      both the active project (as retrieved by
//      IVsMonitorSelection::GetCurrentSelection) and its global package state.
//
//      The service GUID (SID) of the Global RelativePathResolver object should be
//      registered as a sub-key under the HKLM\...\RelativePathResolvers key in the
//      registry. Each registered service will be QueryService'ed for the
//      IVsRelativePathResolver interface.
// ---------------------------------------------------------------------------------
[
    uuid(uuid_IVsRelativePathResolver),
    version(1.0),
    pointer_default(unique)
]
interface IVsRelativePathResolver : IUnknown
{
    // return E_FAIL if the pszRelPath can not be resolved to an absolute path
    HRESULT ResolveRelativePath(
        [in] DWORD dwReserved,            // Must be 0
        [in] LPCOLESTR pszRelPath, 
        [out,   retval] BSTR *pbstrAbsPath);
}

//---------------------------------------------------------------------------
// define LOGVIEWID's here!
//---------------------------------------------------------------------------
cpp_quote("#define LOGVIEWID_Primary GUID_NULL")
cpp_quote("extern const __declspec(selectany) GUID LOGVIEWID_Any = { 0xffffffff, 0xffff, 0xffff, {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff } };")

//---------------------------------------------------------------------------
// The range 7651a700-06e5-11d1-8ebd-00a0c90f26ea to
// 7651a750-06e5-11d1-8ebd-00a0c90f26ea has been reserved for LOGVIEWID's
//---------------------------------------------------------------------------
cpp_quote("extern const __declspec(selectany) GUID LOGVIEWID_Debugging = { 0x7651a700, 0x06e5, 0x11d1, {0x8e, 0xbd, 0x00, 0xa0, 0xc9, 0x0f, 0x26, 0xea } };")
cpp_quote("extern const __declspec(selectany) GUID LOGVIEWID_Code = { 0x7651a701, 0x06e5, 0x11d1, {0x8e, 0xbd, 0x00, 0xa0, 0xc9, 0x0f, 0x26, 0xea } };")
cpp_quote("extern const __declspec(selectany) GUID LOGVIEWID_Designer = { 0x7651a702, 0x06e5, 0x11d1, {0x8e, 0xbd, 0x00, 0xa0, 0xc9, 0x0f, 0x26, 0xea } };")
cpp_quote("extern const __declspec(selectany) GUID LOGVIEWID_TextView = { 0x7651a703, 0x06e5, 0x11d1, {0x8e, 0xbd, 0x00, 0xa0, 0xc9, 0x0f, 0x26, 0xea } };")

// cmdidOpenWith handlers should pass this LOGVIEWID along to OpenStandardEditor to get the "Open With" dialog
cpp_quote("extern const __declspec(selectany) GUID LOGVIEWID_UserChooseView = { 0x7651a704, 0x06e5, 0x11d1, {0x8e, 0xbd, 0x00, 0xa0, 0xc9, 0x0f, 0x26, 0xea } };")

// LOGVIEWID_ProjectSpecific is passed by the OpenWith dialog to IVsProject::OpenItem when the user chooses the "(Project default editor)"
// entry. The project should use its special logic to open the specific editor for the project. If the item supports ViewForm/ViewCode,
// then this will be the smart DBLCLK/Open logic where the FormView is opened if appropriate, else the CodeView is opened.
cpp_quote("extern const __declspec(selectany) GUID LOGVIEWID_ProjectSpecificEditor = { 0x80a3471a, 0x6b87, 0x433e, { 0xa7, 0x5a, 0x9d, 0x46, 0x1d, 0xe0, 0x64, 0x5f } };")

//---------------------------------------------------------------------------
// IVsUIShellOpenDocument
//---------------------------------------------------------------------------
// Implemented by the Environment.
// Used by projects to open documents.
enum __VSDOCINPROJECT
{
    DOCINPROJ_DocNotInProject   = 0,
    DOCINPROJ_DocInProject  = 1,
    DOCINPROJ_DocInExtFilesProject= 2
};

typedef BOOL VSDOCINPROJECT;

enum __VSIDOFLAGS
{
    IDO_ActivateIfOpen      =  0x00000001, // Prompt if owned by different pHier
    IDO_IgnoreLogicalView       =  0x00000002,
};
typedef DWORD VSIDOFLAGS;

enum __VSOSEFLAGS
{
    OSE_RDTFLAGS_MASK            =  0x000FFFFF,
    OSE_UseOpenWithDialog        =  0x10000000,
    OSE_ChooseBestStdEditor  =  0x20000000,
    OSE_OpenAsNewFile            =  0x40000000,
};
typedef DWORD VSOSEFLAGS;

enum __VSOSPEFLAGS
{
    OSPE_RDTFLAGS_MASK       =  0x000FFFFF,
    OSPE_CDWFLAGS_MASK       =  0x00FFFFFF,
    OSPE_OpenAsNewFile       =  0x10000000,
};
typedef DWORD VSOSPEFLAGS;

enum __VSIEIFLAGS
{
    IEI_RDTFLAGS_MASK        =  0x000FFFFF,
    IEI_CREATEDOCWIN_MASK        =  0x00300000 | IEI_RDTFLAGS_MASK,
    IEI_CREATENEWDOCWIN_MASK     =  0x00700000 | IEI_RDTFLAGS_MASK,
    IEI_DoNotLoadDocData         =  0x10000000,
};
typedef DWORD VSIEIFLAGS;

enum __VSOSPFLAGS
{
    OSP_UsePreviewWithDialog        =   0x10000000,
    OSP_LaunchNewBrowser                =   0x01000000,
    OSP_LaunchSingleBrowser         =   0x00100000,
    OSP_SkipInternalIfModal         =   0x00200000, // only valid with OSP_LaunchSingleBrowser
    OSP_LaunchSystemBrowser   = 0x00010000,
    OSP_NoUrlConversion       = 0x00001000  // by default preview will convert URL to UTF8 
    // and canonicalize it before passing to external browser.
    // No URL conversion is done for internal WB
} ;
typedef DWORD VSOSPFLAGS;

typedef enum __VSPREVIEWRESOLUTION
{
    PR_Default = 0,
    PR_640x480 = 1,
    PR_800x600 = 2,
    PR_1024x768 =   3
} VSPREVIEWRESOLUTION;

enum __VSASPFLAGS
{
    ASP_MakeDefault = 0x00000001,
    ASP_UnsetOldDefaults    = 0x00000002
};
typedef DWORD VSASPFLAGS;


// this punkDocData value is only valid for the methods
// IVsUIShellOpenDocument::OpenStandardEditor
// IVsUIShellOpenDocument::OpenSpecificEditor
cpp_quote("#define DOCDATAEXISTING_UNKNOWN       ((IUnknown *)(-1))")

enum __VSRELPATHSEARCHFLAGS
{
    RPS_UseAllSearchStrategies  = 0x00000000, // Use all strategies to resolve the relative path
    RPS_SkipEnumProjectItems    = 0x00000001,   // Skip enumerating items of all projects
    RPS_SkipGlobalResolvers = 0x00000002,       // Skip asking globally registered implementors of 
    // IVsRelativePathResolver
    RPS_MatchByProjectPath = 0x80000000     // Match by project path instead of MkDocument
};
typedef DWORD VSRELPATHSEARCHFLAGS;

[
    uuid(uuid_IVsUIShellOpenDocument),
    version(1.0),
    pointer_default(unique)
]
interface IVsUIShellOpenDocument : IUnknown
{
    HRESULT IsDocumentOpen(
        [in]  IVsUIHierarchy  *pHierCaller,  // Useful with IDO_ActivateIfOpen. Warn user if document is open by another Hierarchy.
        [in]  VSITEMID     itemidCaller,     // Useful with IDO_ActivateIfOpen. Warn user if document is open by another Hierarchy.
        [in]  LPCOLESTR    pszMkDocument,
        [in]  REFGUID      rguidLogicalView,
        [in]  VSIDOFLAGS   grfIDO,
        [out] IVsUIHierarchy **ppHierOpen,
        [out] VSITEMID    *pitemidOpen,
        [out] IVsWindowFrame **ppWindowFrame,
        [out, retval] BOOL *pfOpen);

    HRESULT IsDocumentInAProject(
        [in]  LPCOLESTR    pszMkDocument,
        [out] IVsUIHierarchy **ppUIH,
        [out] VSITEMID    *pitemid,
        [out] IServiceProvider **ppSP,
        [out, retval] VSDOCINPROJECT *pDocInProj);

    HRESULT OpenDocumentViaProject(
        [in]  LPCOLESTR    pszMkDocument,
        [in]  REFGUID      rguidLogicalView,
        [out] IServiceProvider **ppSP,
        [out] IVsUIHierarchy **ppHier,
        [out] VSITEMID    *pitemid,
        [out, retval] IVsWindowFrame   **ppWindowFrame);

    HRESULT OpenStandardEditor(
        [in]  VSOSEFLAGS   grfOpenStandard,
        [in]  LPCOLESTR    pszMkDocument,
        [in]  REFGUID      rguidLogicalView,
        [in]  LPCOLESTR    pszOwnerCaption,
        [in]  IVsUIHierarchy  *pHier,
        [in]  VSITEMID     itemid,
        [in]  IUnknown    *punkDocDataExisting,
        [in]  IServiceProvider *pSP,
        [out, retval] IVsWindowFrame   **ppWindowFrame);

    HRESULT OpenStandardPreviewer(
        [in]  VSOSPFLAGS   ospOpenDocPreviewer,
        [in]  LPCOLESTR    pszURL,
        [in]  VSPREVIEWRESOLUTION resolution,
        [in]  DWORD dwReserved);

    HRESULT GetStandardEditorFactory(
        [in] DWORD dwReserved,
        [in, out] GUID *pguidEditorType,
        [in] LPCOLESTR pszMkDocument,
        [in] REFGUID rguidLogicalView,
        [out] BSTR *pbstrPhysicalView,
        [out, retval] IVsEditorFactory **ppEF);

    HRESULT MapLogicalView(
        [in] REFGUID rguidEditorType,
        [in] REFGUID rguidLogicalView,
        [out, retval] BSTR *pbstrPhysicalView);

    HRESULT OpenSpecificEditor(
        [in] VSOSPEFLAGS  grfOpenSpecific,
        [in] LPCOLESTR    pszMkDocument,
        [in] REFGUID      rguidEditorType,
        [in] LPCOLESTR    pszPhysicalView,  // if NULL, MapLogicalView will be called
        [in] REFGUID      rguidLogicalView, // in MultiView case determines view to be activated by IVsMultiViewDocumentView
        [in] LPCOLESTR    pszOwnerCaption,
        [in] IVsUIHierarchy  *pHier,
        [in] VSITEMID     itemid,
        [in] IUnknown    *punkDocDataExisting,
        [in] IServiceProvider *pSPHierContext,
        [out, retval] IVsWindowFrame   **ppWindowFrame);

    HRESULT InitializeEditorInstance(
        [in] VSIEIFLAGS   grfIEI,
        [in] IUnknown    *punkDocView,
        [in] IUnknown    *punkDocData,
        [in] LPCOLESTR    pszMkDocument,
        [in] REFGUID      rguidEditorType,
        [in] LPCOLESTR    pszPhysicalView,
        [in] REFGUID      rguidLogicalView, // in MultiView case determines view to be activated by IVsMultiViewDocumentView
        [in] LPCOLESTR    pszOwnerCaption,
        [in] LPCOLESTR    pszEditorCaption,
        [in] IVsUIHierarchy  *pHier,
        [in] VSITEMID     itemid,
        [in] IUnknown    *punkDocDataExisting,
        [in] IServiceProvider *pSPHierContext,
        [in] REFGUID      rguidCmdUI,
        [out, retval] IVsWindowFrame   **ppWindowFrame);

    HRESULT IsSpecificDocumentViewOpen(
        [in]  IVsUIHierarchy  *pHierCaller,  // Useful with IDO_ActivateIfOpen. Warn user if document is open by another Hierarchy.
        [in]  VSITEMID         itemidCaller, // Useful with IDO_ActivateIfOpen. Warn user if document is open by another Hierarchy.
        [in]  LPCOLESTR        pszMkDocument,
        [in]  REFGUID          rguidEditorType,
        [in]  LPCOLESTR        pszPhysicalView,
        [in]  VSIDOFLAGS       grfIDO,
        [out] IVsUIHierarchy **ppHierOpen,
        [out] VSITEMID        *pitemidOpen,
        [out] IVsWindowFrame **ppWindowFrame,
        [out, retval] BOOL    *pfOpen);

    HRESULT OpenDocumentViaProjectWithSpecific(
        [in] LPCOLESTR pszMkDocument,
        [in] VSSPECIFICEDITORFLAGS grfEditorFlags,
        [in] REFGUID rguidEditorType,
        [in] LPCOLESTR pszPhysicalView,
        [in]  REFGUID rguidLogicalView,
        [out] IServiceProvider **ppSP,
        [out] IVsUIHierarchy **ppHier,
        [out] VSITEMID *pitemid,
        [out, retval] IVsWindowFrame **ppWindowFrame);

    // This method is used to implement Window.NewWindow functionality.
    // Editors should handle cmdidNewWindow by calling this method.
    HRESULT OpenCopyOfStandardEditor(
        [in]  IVsWindowFrame *pWindowFrame,
        [in]  REFGUID     rguidLogicalView, 
        [out, retval] IVsWindowFrame   **ppNewWindowFrame);

    // GetFirstDefaultPreviewer returns the EXE path of the first default web browser. 
    // This is the same browser that would have been launched 
    // if OSP_LaunchSingleBrowser were passed to CVsUIShellOpenDocument::OpenStandardPreviewer.
    // If it is the internal browser, pbstrDefBrowserPath will be NULL, but *pfIsInternalBrowser
    // will be TRUE and the function will return S_OK;
    // Returns S_OK if a default previewer is defined.
    // Returns S_FALSE if there are no default previewers.
    HRESULT GetFirstDefaultPreviewer([out] BSTR *pbstrDefBrowserPath, [out] BOOL *pfIsInternalBrowser, [out] BOOL *pfIsSystemBrowser);

    // Convert a relative path for a document to an absolute path that can be passed to     
    // OpenDocumentViaProject.  This method uses two strategies:
    //
    //   1. Enum project items in all projects and compare pszRelPath against the
    //      MkDocument (or project path, if the RPS_MatchByProjectPath flag is
    //      specified) of the project item. The comparison is case insensitive. The
    //      pszRelPath can be a document name without a path or a document name with a
    //      partial path that matches a valid right-hand portion of the MkDocument (or
    //      project path).  The active project is given first priority.
    //
    //      This step can be skipped by specifying the RPS_SkipEnumProjectItems flag.
    //
    //   2. Ask all globally registered IVsRelativePathResolver objects to resolve the 
    //      path. This mechanism allows a project language service to resolve relative 
    //      paths against non-project items (e.g. if a project has the concept of an 
    //      INCLUDE search path).  Global RelativePathResolver objects should 
    //      register a service GUID (SID) as a sub-key under the 
    //      HKLM\...\RelativePathResolvers key in the registry. Each registered service 
    //      will be QueryService'ed for the IVsRelativePathResolver interface.
    //
    //      This step can be skipped by specifying the RPS_SkipGlobalResolvers flag.
    //
    // If none of the methods attempted results in a match, the function sets 
    // *pbstrAbsPath to NULL and returns S_FALSE.

    HRESULT SearchProjectsForRelativePath(
        [in] VSRELPATHSEARCHFLAGS   grfRPS,
        [in] LPCOLESTR pszRelPath,
        [out,   retval] BSTR *pbstrAbsPath);

    // Add a Web Browser to the list of available previewers that can be launched
    // via OpenStandardPreviewer. Once a previewer has been added, it is persisted
    // in the registry under HKCU.  A package that
    // wishes to add a standard previewer should put a registry entry
    // HKLM\...\7.0\AddStandardPreviewer
    //  {guidPackage} = "Name of Package"     -- this is a subkey; name is for debugging purpose only and is not actually used
    // At the appropriate time the shell will parse those entries and call 
    // IVsPackage::ResetDefaults(PKGRF_ADDSTDPREVIEWER) on the package.  At that point
    // the package should call AddStandardPreviewer.
    // For example, if the shell didn't provide IE by default, you could add a call
    // to AddStandardPreviewer(L"c:\\program files\\internet explorer\\iexplore.exe",
    //                         L"Microsoft Internet Explorer", TRUE, L"IEXPLORE", L"WWW_OpenURL", 
    //                         L"\"%s\",,0xffffffff,3,,,,", L"WWW_Activate", L"0xffffffff,0",  
    //                         ASP_MakeDefault);
    // Use ASP_UnsetOldDefaults with care since. You have to also have ASP_MakeDefault to 
    // unset the old defaults so that there will never be 0 defaults.  Also, if multiple 
    // packages use it ASP_UnsetOldDefaults|ASP_MakeDefault, the last package wins 
    // (it will be the default).
    HRESULT AddStandardPreviewer(
        [in] LPCOLESTR pszExePath,
        [in] LPCOLESTR pszDisplayName,
        [in] BOOL        fUseDDE,
        [in] LPCOLESTR pszDDEService,
        [in] LPCOLESTR pszDDETopicOpenURL,
        [in] LPCOLESTR pszDDEItemOpenURL,
        [in] LPCOLESTR pszDDETopicActivate,
        [in] LPCOLESTR pszDDEItemActivate,
        [in] VSASPFLAGS aspAddPreviewerFlags);

}

cpp_quote("#define SID_SVsUIShellOpenDocument IID_IVsUIShellOpenDocument")

//---------------------------------------------------------------------------
// IVsMultiViewDocumentView
//---------------------------------------------------------------------------
// Implemented on the object sited in a WindowFrame for a view
// that supports multiple view tabs (e.g. the HTML Editor with "Design" and
// "HTML" tabs).
// Interface is retrieved by QI on the object returned from VSFPROPID_DocView.
[
    uuid(uuid_IVsMultiViewDocumentView),
    version(1.0),
    pointer_default(unique)
]
interface IVsMultiViewDocumentView : IUnknown
{
    HRESULT ActivateLogicalView([in] REFGUID rguidLogicalView);
    HRESULT GetActiveLogicalView([out] GUID *pguidLogicalView);
    HRESULT IsLogicalViewActive([in] REFGUID rguidLogicalView, [out, retval] BOOL *pIsActive);
};


//---------------------------------------------------------------------------
// IVsPersistDocData[2]
//---------------------------------------------------------------------------
// Implemented by editors that follow the standard editor architecture of the Environment.
// This interface is implemented on the Data side (DocData) of the editor as opposed to the 
// View side (DocView) for editors that support data/view separation and multiple views.
enum _VSRELOADDOCDATA
{
    RDD_IgnoreNextFileChange     = 0x00000001,
    RDD_RemoveUndoStack      = 0x00000002
};
typedef DWORD VSRELOADDOCDATA;

[
    uuid(uuid_IVsPersistDocData),
    version(1.0),
    pointer_default(unique)
]
interface IVsPersistDocData : IUnknown
{
    HRESULT GetGuidEditorType([out] CLSID *pClassID);
    HRESULT IsDocDataDirty([out] BOOL *pfDirty);
    // SetUntitledDocPath is called by all projects after a new document instance is created.
    // Editors use the same CreateInstance/InitNew design pattern of standard COM objects.
    // Editors can use this method to perform one time initializations that are required after a new
    // document instance was created via IVsEditorFactory::CreateEditorInstance(CEF_CLONEFILE,...).
    // NOTE: Ideally this method would be called InitializeNewDocData but it is too late to rename this method.
    //       Most editors can ignore the parameter passed. It is a legacy of historical insignificance.
    HRESULT SetUntitledDocPath([in] LPCOLESTR pszDocDataPath);
    HRESULT LoadDocData([in] LPCOLESTR pszMkDocument);
    //SaveDocData may return STG_S_DATALOSS to indicate some characters could not be represented in the current codepage
    HRESULT SaveDocData(
        [in]  VSSAVEFLAGS dwSave,
        [out] BSTR       *pbstrMkDocumentNew,
        [out] BOOL       *pfSaveCanceled);
    HRESULT Close(void);    // close and zombie (without saving)
    HRESULT OnRegisterDocData([in] VSCOOKIE docCookie, [in] IVsHierarchy *pHierNew, [in] VSITEMID itemidNew);
    HRESULT RenameDocData([in] VSRDTATTRIB grfAttribs, [in] IVsHierarchy *pHierNew, [in] VSITEMID itemidNew, [in] LPCOLESTR pszMkDocumentNew);
    HRESULT IsDocDataReloadable([out] BOOL *pfReloadable);
    HRESULT ReloadDocData([in] VSRELOADDOCDATA grfFlags);
};

//---------------------------------------------------------------------------
// IVsPersistDocData2
//---------------------------------------------------------------------------
[
    uuid(uuid_IVsPersistDocData2),
    version(1.0),
    pointer_default(unique)
]
interface IVsPersistDocData2 : IVsPersistDocData
{
    HRESULT SetDocDataDirty([in] BOOL fDirty);
    HRESULT IsDocDataReadOnly([out] BOOL *pfReadOnly);
    HRESULT SetDocDataReadOnly([in] BOOL fReadOnly);
};

//---------------------------------------------------------------------------
// IVsDocDataFileChangeControl
//---------------------------------------------------------------------------
// IVsDocDataFileChangeControl must be implemented by DocData objects
// that advise for FileChange notifications to automatically reload when the
// file has been changed outside of the editor. IgnoreFileChanges(TRUE) tells
// the DocData object to increment a flag to ignore IVsFileChangeEvents for
// the file. This IgnoreFileChanges mechanism should be refcounted to allow
// nested calls.
[
    uuid(uuid_IVsDocDataFileChangeControl),
    version(1.0),
    pointer_default(unique)
]
interface IVsDocDataFileChangeControl : IUnknown
{
    HRESULT IgnoreFileChanges([in] BOOL fIgnore); // returns S_FALSE if buffer is not a disk file
}


//---------------------------------------------------------------------------
// IVsPersistHierarchyItem[2]
//---------------------------------------------------------------------------
// Implemented by projects. 
// Interface is retrieved by QI from IVsHierarchy.
// This interface is called by the RDT in order to perform save/saveas operations
// for items within the Hierarchy.
[
    uuid(uuid_IVsPersistHierarchyItem),
    version(1.0),
    pointer_default(unique)
]
interface IVsPersistHierarchyItem : IUnknown
{
    HRESULT IsItemDirty([in] VSITEMID   itemid, [in] IUnknown *punkDocData, [out] BOOL *pfDirty);
    HRESULT SaveItem([in]   VSSAVEFLAGS dwSave, [in] LPCOLESTR pszSilentSaveAsName,
        [in]    VSITEMID itemid, [in] IUnknown *punkDocData, [out] BOOL *pfCanceled);
};

[
    uuid(uuid_IVsPersistHierarchyItem2),
    version(1.0),
    pointer_default(unique)
]
interface IVsPersistHierarchyItem2 : IVsPersistHierarchyItem
{
    HRESULT IsItemReloadable([in]   VSITEMID itemid, [out, retval] BOOL *pfReloadable);
    HRESULT ReloadItem([in] VSITEMID itemid, [in]   DWORD dwReserved);
    HRESULT IgnoreItemFileChanges([in] VSITEMID itemid, [in] BOOL   fIgnore);
};

//----------------------------------------------------------------------------
// IVsUIHierarchyWindow
//----------------------------------------------------------------------------
// Implemented by the Environment.
// This is the same tree control used by the "Solution Explorer" that displays
// objects that implement IVsUIHierarchy. This UIHierarchyWindow can be used also
// for non-project Hierarchies (e.g. "Server Explorer").

typedef enum __EXPANDFLAGS
{
    EXPF_ExpandFolder               = 0,
    EXPF_CollapseFolder         = 1,
    EXPF_ExpandFolderRecursively    = 2,
    EXPF_ExpandParentsToShowItem    = 3,
    EXPF_SelectItem             = 4,
    EXPF_BoldItem               = 5,
    EXPF_ExtendSelectItem       = 6,
    EXPF_AddSelectItem      = 7,
    EXPF_UnSelectItem       = 8,
    EXPF_UnBoldItem             = 9,
    EXPF_CutHighlightItem           = 10,
    EXPF_AddCutHighlightItem        = 11,
    EXPF_UnCutHighlightItem     = 12,
    EXPF_EditItemLabel      = 13,
} EXPANDFLAGS;


enum __UIHWINFLAGS
{
    UIHWF_ActAsProjectTypeWin           = 0x00000001,
    UIHWF_DoNotSortRootNodes            = 0x00000002, // default is alpha sort on caption
    // enable   toolbars in UIHierarchyWindow toolwindow. Use VSFPROPID_ToolbarHost to access 
    // the window's IVsToolWindowToolbarHost implementation.
    UIHWF_SupportToolWindowToolbars     = 0x00000004, 
    UIHWF_ForceSingleSelect         = 0x00000008,
    UIHWF_InitWithHiddenRootHierarchy       = 0x00000010,
    UIHWF_UseSolutionAsHiddenRootHierarchy  = 0x00000020,
    UIHWF_LinesAtRoot               = 0x00000040,
    UIHWF_SortChildNodes                = 0x00000080,
    UIHWF_NoStateIcon               = 0x00000100,
    UIHWF_InitWithHiddenParentRoot      = 0x00000400,
    UIHWF_PropagateAltHierarchyItem     = 0x00001000,
    UIHWF_RouteCmdidDelete          = 0x00002000,
    //This is   for windows that handle commands when they are the active hierarchy even
    //if their hierarchy doesn't have   focus.  (Like Project/Add Item)
    UIHWF_HandlesCmdsAsActiveHierarchy      = 0x00004000,
};
typedef DWORD UIHWINFLAGS;

enum __VSHIERARCHYITEMSTATE
{
    HIS_FIRST           = 0x00000002,
    HIS_Selected        = 0x00000002,
    HIS_CutHighlight    = 0x00000004,
    HIS_Bold            = 0x00000010,
    HIS_Expanded        = 0x00000020,
    HIS_LAST            = 0x00000020
};
typedef DWORD VSHIERARCHYITEMSTATE;

enum __VSCOMHIEROPTIONS
{
    COMHIEROPT_RootHierarchyOnly = 0x00000001,      // e.g. "i only want project nodes"
    COMHIEROPT_AllowHiddenRoot   = 0x00000002,      // e.g. "ok to return Solution node hierarchy"
};
typedef DWORD VSCOMHIEROPTIONS;

enum __VSADDHIEROPTIONS
{
    ADDHIEROPT_DontSelectNewHierarchy   = 0x00000001,       // add the new hierarchy without changing the current selection
};
typedef DWORD VSADDHIEROPTIONS;

[
    uuid(uuid_IVsUIHierarchyWindow),
    version(1.0),
    pointer_default(unique)
]
interface IVsUIHierarchyWindow : IUnknown
{
    // UIHierarchyWindow is instantiated by calling
    // IVsUIShell::CreateToolWindow(CLSID_VSUIHIERARCHYWINDOW,...).
    // The caller   can then QI the ppvDocView returned by this call for
    // the IVsUIHierarchyWindow interface.
    HRESULT Init([in]    IVsUIHierarchy *pUIH,
        [in]     UIHWINFLAGS grfUIHWF,
        [out] IUnknown**    ppunkOut);

    HRESULT ExpandItem([in] IVsUIHierarchy* pUIH,   [in] VSITEMID itemid, [in] EXPANDFLAGS expf);

    // This method adds an additional   root UIHierarchy node to the list managed by the
    // UIHierarchyWindow.
    HRESULT AddUIHierarchy([in] IVsUIHierarchy* pUIH,   [in] VSADDHIEROPTIONS grfAddOptions);   
    HRESULT RemoveUIHierarchy([in] IVsUIHierarchy* pUIH);

    HRESULT SetWindowHelpTopic([in] LPCOLESTR   lpszHelpFile, [in] DWORD dwContext);

    HRESULT GetItemState(
        [in] IVsUIHierarchy* pHier,
        [in] VSITEMID itemid,
        [in] VSHIERARCHYITEMSTATE dwStateMask,
        [out, retval] VSHIERARCHYITEMSTATE *pdwState);

    // returns E_FAIL   if there is no selection
    HRESULT FindCommonSelectedHierarchy([in] VSCOMHIEROPTIONS   grfOpt,
        [out,   retval] IVsUIHierarchy**  lppCommonUIH);

    [local]HRESULT SetCursor([in]HCURSOR hNewCursor, [out, retval]HCURSOR   *phOldCursor);

    HRESULT GetCurrentSelection(
        [out] IVsHierarchy ** ppHier,
        [out] VSITEMID * pitemid,
        [out] IVsMultiItemSelect ** ppMIS);
};

cpp_quote("extern const __declspec(selectany) GUID CLSID_VSUIHIERARCHYWINDOW = {0x7D960B07, 0x7AF8, 0x11D0, 0x8E, 0x5E, 0x00, 0xA0, 0xC9, 0x11, 0x00, 0x5A};")

//----------------------------------------------------------------------------
// IVsWindowPane
//----------------------------------------------------------------------------
// Implemented by objects that want to be sited in an IVsWindowFrame (tool or document windows).
// This interface is retrieved by QI on the DocView object.
// This is the light weight way to fill a WindowFrame. Basically you implement a standard
// Win32 window and parent your HWND to the HWND of the WindowFrame. It is also possible
// to site an ActiveX Control or ActiveX DocObject in a WindowFrame.
// NOTE: if your window hosts ActiveX Controls, it is not recommended to implement
// IVsWindowPane; instead implement the ActiveX approach.
[
    local,
    uuid(uuid_IVsWindowPane),
    version(1.0)
]
interface IVsWindowPane : IUnknown
{
    HRESULT SetSite([in] IServiceProvider   *pSP);
    HRESULT CreatePaneWindow([in]   HWND hwndParent,
        [in]    int x,
        [in]    int y,
        [in]    int cx,
        [in]    int cy,
        [out] HWND *hwnd);
    [custom(uuid_IVsWindowPane, "preservesig")]
    HRESULT GetDefaultSize([out] SIZE   *psize);
    HRESULT ClosePane(void);
    [custom(uuid_IVsWindowPane, "preservesig")]
    HRESULT LoadViewState([in] IStream *pstream);
    [custom(uuid_IVsWindowPane, "preservesig")]
    HRESULT SaveViewState([in] IStream *pstream);
    HRESULT TranslateAccelerator(LPMSG lpmsg);
}

//----------------------------------------------------------------------------
// IEnumPackages
//----------------------------------------------------------------------------
[
    uuid(uuid_IEnumPackages),
    version(1.0),
    pointer_default(unique)
]
interface IEnumPackages : IUnknown
{
    HRESULT Next([in]   ULONG celt, [out, size_is(celt), length_is(*pceltFetched)] IVsPackage **rgelt, [out] ULONG *pceltFetched);
    HRESULT Skip([in]   ULONG celt);
    HRESULT Reset(void);
    HRESULT Clone([out] IEnumPackages   **ppenum);
}

//----------------------------------------------------------------------------
// IEnumHierarchies
//----------------------------------------------------------------------------
[
    uuid(uuid_IEnumHierarchies),
    version(1.0),
    pointer_default(unique)
]
interface IEnumHierarchies : IUnknown
{
    HRESULT Next([in]   ULONG celt, [out, size_is(celt), length_is(*pceltFetched)] IVsHierarchy **rgelt, [out] ULONG *pceltFetched);
    HRESULT Skip([in]   ULONG celt);
    HRESULT Reset(void);
    HRESULT Clone([out] IEnumHierarchies **ppenum);
}

//----------------------------------------------------------------------------
// IEnumWindowFrames
//----------------------------------------------------------------------------
[
    uuid(uuid_IEnumWindowFrames),
    version(1.0),
    pointer_default(unique)
]
interface IEnumWindowFrames : IUnknown
{
    HRESULT Next([in]   ULONG celt, [out, size_is(celt), length_is(*pceltFetched)] IVsWindowFrame **rgelt, [out] ULONG *pceltFetched);
    HRESULT Skip([in]   ULONG celt);
    HRESULT Reset(void);
    HRESULT Clone([out] IEnumWindowFrames   **ppenum);
}

//----------------------------------------------------------------------------
// IVsShell
//----------------------------------------------------------------------------
// Implemented by the Environment. 
// This service is used to manage the loading of IVsPackages.
//
// Each VSSPROPID must return a VARIANT struct filled in with the proper VT_
//     type.  The caller may *assume* the VT_ is correct (i.e. that there is
//     no need to call VariantChangeType(), or verify the type, beyond an
//     ASSERT() to make sure there weren't header-file mismatches, etc.
// This same logic applies to the caller when setting a property: the
//     hierarchy will assume that the *caller* has passed a VARIANT already
//     converted to the proper VT_.
//---------------------------------------------------------------------------

enum
{
    PBRP_SaveChanges       = 1,
    PBRP_DontSaveChanges = 2,
    PBRP_PromptForSave   = 3,
    PBRP_SaveDocumentsOnly = 4
};

typedef enum _VSRECORDSTATE
{
    VSRECORDSTATE_ON        = 1,
    VSRECORDSTATE_OFF       = 2,
    VSRECORDSTATE_PAUSED    = 3
} VSRECORDSTATE;

typedef enum _VSRELOADOPTION
{
    VSRELOADOPTION_PROMPT       = 0,    // prompt user for reload of externally modified documents
    VSRELOADOPTION_SILENT       = 1,    // always silently reload externally modified documents
    VSRELOADOPTION_NEVER        = 2,    // never reload externally modified documents
} VSRELOADOPTION;

// WARNING: VSSPROPID values must not overlap any other *PROPID group values!

enum __VSSPROPID
{
    VSSPROPID_LAST              = -9000,
    VSSPROPID_StartupDir            = -9000, // BSTR directory where running executable started up
    VSSPROPID_MDIState          = -9001, // BOOL VARIANT_TRUE if IDE in MDI state, else VARIANT_FALSE
    VSSPROPID_VirtualRegistryRoot   = -9002, // BSTR registry key name (must be appended to HKLM or HKCU)
    VSSPROPID_OpenFileFilter        = -9003, // BSTR open file filter list string
    VSSPROPID_FindInFilesFilter = -9004, // BSTR find in files filter list string
    VSSPROPID_AddExistItemFilter    = -9005, // BSTR add existing item filter list string
    VSSPROPID_IsInOfficeMode        = -9006, // BOOL TRUE if environment is in Office mode
    VSSPROPID_InstallDirectory  = -9007, // BSTR directory where visual studio executable was installed
    VSSPROPID_PreBuildRunPreview    = -9008, // I4 one of PBRP_ values (PBRP_SaveChanges/PBRP_DontSaveChanges/PBRP_PromptForSave)
    VSSPROPID_IsComplexScriptAvail= -9009, //   OBSOLETE
    VSSPROPID_hinstComplexScript    = -9010, // OBSOLETE
    VSSPROPID_hinstMSO          = -9011, // I4, HINSTANCE of mso*.dll
    VSSPROPID_ViewSourceMode        = -9012, // BOOL set to TRUE if environment to be in ViewSourceMode
    VSSPROPID_RecordState           = -9013, // I4, VSRECORDSTATE enum type specifying macro recording state of env.
    VSSPROPID_Zombie                = -9014, // BOOL TRUE if env is in zombie state
    VSSPROPID_AnimationsOn      = -9015, // BOOL TRUE if env animations are on
    VSSPROPID_ProcessingPendingMessageFilterMsg =   -9016, // BOOL TRUE if Processing Pending MessageFilter Msg
    VSSPROPID_IsInteractive     = -9017, // BOOL FALSE if running non-interactive cmd line invokations e.g. /make. OBSOLETE!!! DO NOT USE!!! Use VSSPROPID_IsInCommandLineMode instead.
    VSSPROPID_DetectFileChanges = -9018, // BOOL TRUE if Editors are supposed to watch for filechanges
    VSSPROPID_OpenFromCurrDocDir    = -9019, // BOOL TRUE if Open File operation starts in current document's directory
    VSSPROPID_ReloadChangedFiles    = -9020, // I4, VSRELOADOPTION. tells editors how to respond to externally modified documents
    VSSPROPID_AppDataDir            = -9021, // BSTR application data directory
    VSSPROPID_IsInCommandLineMode   = -9022, // BOOL TRUE if environment is running as a command line tool. Do not bring up any UI in this case!!!. Opposite if VSSPROPID_IsInteractive
    VSSPROPID_ShowOutputPaneOnBuildBegin = -9023,   // BOOL TRUE if we're going to show the ouputpane when we start building
    VSSPROPID_ShowTasklistOnBuildEnd = -9024,   // BOOL TRUE if we're going to show the tasklist when we finish building
    VSSPROPID_hmsoinstMSO           = -9025, // I4, HMSOINST of mso*.dll
    VSSPROPID_ShowMiscFilesProject= -9026, //   BOOL TRUE if we're going to show the Miscellaneous Files project (so it is visible in Solution Explorer)
    VSSPROPID_ObjectMgrTypesImgList =   -9027, // I4, Handle to shell's imagelist for symbol types (class, interface, method etc). Do NOT free. Shell will free upon final shutdown
    VSSPROPID_SCCGlyphsImgList    = -9028, // I4, Handle to shell's imagelist for SCC glyphs (indexed by VsStateIcon). Do NOT free. Shell will free upon final shutdown
    VSSPROPID_SuppressMessageFilterBusyDialog   = -9029, // BOOL  If TRUE the "Component Busy/Retry/Switch" dialog is suppressed (used by VSA for break mode)
    VSSPROPID_VisualStudioProjDir   = -9030, // BSTR full path of location of 'Visual Studio Projects' directory
    VSSPROPID_PreBuildRunPreviewSaveOpts    = -9031, // I4 VSRDTSAVEOPTIONS to pass to IVsRunningDocumentTable::SaveDocuments when VSSPROPID_PreBuildRunPreview != PBRP_DontSaveChanges
    VSSPROPID_FIRST             = -9031
};
typedef LONG VSSPROPID;

[
    uuid(uuid_IVsShell),
    version(1.0),
    pointer_default(unique)
]
interface IVsShell : IUnknown
{
    HRESULT GetPackageEnum([out] IEnumPackages **ppEnum);
    HRESULT GetProperty([in] VSSPROPID propid, [out] VARIANT *pvar);
    HRESULT SetProperty([in] VSSPROPID propid, [in]  VARIANT    var);
    HRESULT AdviseBroadcastMessages([in]    IVsBroadcastMessageEvents *pSink,
        [out]   VSCOOKIE *pdwCookie);
    HRESULT UnadviseBroadcastMessages([in] VSCOOKIE dwCookie);
    HRESULT AdviseShellPropertyChanges([in]  IVsShellPropertyEvents *pSink,
        [out]   VSCOOKIE *pdwCookie);
    HRESULT UnadviseShellPropertyChanges([in]   VSCOOKIE dwCookie);
    HRESULT LoadPackage([in] REFGUID guidPackage,   [out, retval] IVsPackage **ppPackage);
    HRESULT LoadPackageString([in] REFGUID guidPackage, [in] ULONG resid,   [out, retval] BSTR *pbstrOut);
    HRESULT LoadUILibrary([in] REFGUID guidPackage, [in] DWORD dwExFlags,   [out, retval] DWORD_PTR *phinstOut);
    HRESULT IsPackageInstalled([in] REFGUID guidPackage, [out, retval] BOOL *pfInstalled);
    HRESULT IsPackageLoaded([in] REFGUID guidPackage,   [out, retval] IVsPackage **ppPackage);
}
cpp_quote("#define SID_SVsShell IID_IVsShell")


// These definitions are for broadcasting a notification message via
//   IVsBroadcastMessageEvents::OnBroadcastMessage to indicate that the cmdbar
//   metrics have changed.
//
// wParam = (BOOL)fLargeButtons
// lParam = (VSTBM*)pNewMetrics
//

// These message defines must be kept in ssync with the defines in env\core\vbm.h
// VSM_message = (VBM__BASE + id) = (WM_USER + 0x0C00 + id)
cpp_quote("#define VSM_TOOLBARMETRICSCHANGE   (WM_USER + 0x0C52)")
cpp_quote("#define VSM_ENTERMODAL             (WM_USER + 0x0C53)")
cpp_quote("#define VSM_EXITMODAL              (WM_USER + 0x0C54)")

typedef struct __VSTBM
{
    int     dxpButton;  // large or small button size
    int     dypButton;
    int     dxpMargin;  // space around edges of toolbars
    int     dypMargin;
    int     dxpRow;     // row widths (horz and vert docking, resp)
    int     dypRow;
    int     dxpGap;     // gap widths
    int     dypGap;
    int     dxCaptionBtn;
    int     dyCaptionBtn;
    HFONT   hfontHalfHtTitle;
} VSTBM;

//----------------------------------------------------------------------------
// IVsBroadcastMessageEvents
//----------------------------------------------------------------------------
// Implemented by clients of BroadcastMessageEvents
[
    uuid(uuid_IVsBroadcastMessageEvents),
    version(1.0),
    pointer_default(unique)
]
interface IVsBroadcastMessageEvents : IUnknown
{
    HRESULT OnBroadcastMessage([in] UINT msg,   [in] WPARAM wParam, [in] LPARAM lParam);
}

//----------------------------------------------------------------------------
// IVsShellPropertyEvents
//----------------------------------------------------------------------------
// Implemented by clients of ShellPropertyChange Events
[
    uuid(uuid_IVsShellPropertyEvents),
    version(1.0),
    pointer_default(unique)
]
interface IVsShellPropertyEvents : IUnknown
{
    HRESULT OnShellPropertyChange([in] VSSPROPID propid, [in]   VARIANT var);
}

//----------------------------------------------------------------------------
// IVsEditorFactory
//----------------------------------------------------------------------------
// Implemented by Package that implements an editor type that follows the standard 
// editor architecture of the Environment.
// Interface is passed to Environment via IVsRegisterEditors::RegisterEditor.
//
// This interace is similar to IClassFactory and is used to instantiate DocView
// and DocData objects for an editor. When creating editors for new documents (CEF_CLONEFILE),
// editors use the same CreateInstance/InitNew design pattern of standard COM objects.
// Editors can use IVsPersistDocData::SetUntitledDocPath method to perform one time 
// initializations that are required after a new document instance was created via 
// IVsEditorFactory::CreateEditorInstance(CEF_CLONEFILE,...).

// {6AC5EF80-12BF-11D1-8E9B-00A0C911005A}
cpp_quote("extern const __declspec(selectany) GUID GUID_DefaultEditor = { 0x6ac5ef80, 0x12bf, 0x11d1, {0x8e, 0x9b, 0x0, 0xa0, 0xc9, 0x11, 0x00, 0x5a} };")

// {8137C9E8-35FE-4AF2-87B0-DE3C45F395FD}
cpp_quote("extern const __declspec(selectany) GUID GUID_ExternalEditor = { 0x8137c9e8, 0x35fe, 0x4af2, { 0x87, 0xb0, 0xde, 0x3c, 0x45, 0xf3, 0x95, 0xfd } };")

enum __VSCREATEEDITORFLAGS
{
    CEF_CLONEFILE   = 0x00000001,   // Mutually exclusive w/_OPENFILE
    CEF_OPENFILE    = 0x00000002,   // Mutually exclusive w/_CLONEFILE
    CEF_SILENT  = 0x00000004,   // Editor factory should create editor silently
    CEF_OPENASNEW   = 0x00000008,   // Editor factory should perform necessary fixups
};
typedef DWORD VSCREATEEDITORFLAGS;

enum __VSEDITORCREATEDOCWIN
{
    ECDW_UserCanceled    = 0x00000001, // User has canceled CreateEditorInstance operation
    ECDW_CDWFLAGS_MASK = 0xFFFFF0F8, // legal   values taken from VSCREATEDOCWIN
};
typedef int VSEDITORCREATEDOCWIN;

[
    uuid(uuid_IVsEditorFactory),
    version(1.0),
    pointer_default(unique)
]
interface IVsEditorFactory : IUnknown
{
    // CreateEditorInstance should return:
    //  VS_E_UNSUPPORTEDFORMAT if the document has a format that cannot be opened in the editor.
    //  VS_E_INCOMPATIBLEDOCDATA if the document is open in an incompatible editor (or E_NOINTERFACE).
    //  another HRESULT error code is the file could not be opened for any other reason.
    // CreateEditorInstance may be called   on various editor factories in a loop attempting to find an
    // editor   that will successfully open.  VS_E_UNSUPPORTEDFORMAT will allow the loop to continue (without
    // closing the document if it   is currently open).  VS_E_INCOMPATIBLEDOCDATA will ask if the open document
    // should   be closed.  Any other return code will stop the loop from continuing.
    HRESULT CreateEditorInstance(   [in]  VSCREATEEDITORFLAGS grfCreateDoc,
        [in]  LPCOLESTR           pszMkDocument,
        [in]  LPCOLESTR           pszPhysicalView,
        [in]  IVsHierarchy       *pvHier,
        [in]  VSITEMID            itemid,
        [in]  IUnknown           *punkDocDataExisting,
        [out] IUnknown          **ppunkDocView, // NULL if external editor
        [out] IUnknown          **ppunkDocData, // NULL if external editor
        [out] BSTR       *pbstrEditorCaption,
        [out] GUID       *pguidCmdUI,
        [out, retval] VSEDITORCREATEDOCWIN *pgrfCDW);   // flags to be passed to CreateDocumentWindow
    HRESULT SetSite( [in]   IServiceProvider *pSP);
    HRESULT Close(void);
    HRESULT MapLogicalView( [in] REFGUID rguidLogicalView,
        [out,   retval] BSTR *pbstrPhysicalView);
}

//----------------------------------------------------------------------------
// IVsRegisterEditors
//----------------------------------------------------------------------------
// Implemented by the Environment.
// Used by Packages that implement an editor type. RegisterEditor is usually  
// called in IVsPackage::SetSite; UnregisterEditor is called in IVsPackage::Close.
typedef enum _VSEDITORPRIORITY
{
    EDTPRI_IntrinsicEditor  =   50,
    EDTPRI_TextEditor         = 30,
    EDTPRI_TextEditorCodePage   = 29,
    EDTPRI_InplaceEditor      = 25,
    EDTPRI_OutsideEditor      = 20,
    EDTPRI_BinaryEditor   = 10
} VSEDITORPRIORITY;

[
    uuid(uuid_IVsRegisterEditors),
    version(1.0),
    pointer_default(unique)
]
interface IVsRegisterEditors : IUnknown
{
    HRESULT RegisterEditor([in] REFGUID rguidEditor, [in]   IVsEditorFactory *pVsPF, [out] VSCOOKIE *pdwCookie);
    HRESULT UnregisterEditor([in]   VSCOOKIE dwCookie);
}

cpp_quote("#define SID_SVsRegisterEditors IID_IVsRegisterEditors")


//----------------------------------------------------------------------------
// IVsEditorFactoryNotify
//----------------------------------------------------------------------------
// Implemented by IVsEditorFactory objects. [optional]
// Interface is retrieved by QI from IVsEditorFactory.
// Most often used to coordinate the setting of VSHPROPID_ItemSubType for items 
// within a project that support ViewForm/ViewCode commands for editors that work
// specially with a particular project type (e.g. .NET Designers and VB projects).
// NOTE: Not all projects support this feature.
enum __EFNFLAGS
{
    EFN_ClonedFromTemplate = 0x00000001,        // AddNewItem operation. File passed was cloned from a template file.
    EFN_ItemAdded            = 0x00000002,      // AddItem operation. File passed was added as an existing file
    EFN_ItemAddedFromSaveAs =   0x00000004,     // AddItem operation. File passed was added as a result of a save as operation
    EFN_ItemAddedAsCopyOf     = 0x00000008,     // AddItem operation. File added as a "Copy of file" (copy/paste to same folder scenario)
};
typedef DWORD EFNFLAGS;

[
    uuid(uuid_IVsEditorFactoryNotify),
    version(1.0),
    pointer_default(unique)
]
interface IVsEditorFactoryNotify : IUnknown
{
    // This method is   called whenever a new file (cloned from a template or existing file) is 
    // added to the project. This   method is called just after cloning the template file but 
    // prior to opening the editor or   calling IVsTrackProjectDocuments::OnAfterAddFiles. 
    // Implementors are expected to set VSHPROPID_ItemSubType   on the project item appropriately. 
    // They may also perform other processing   on the file or setting up other project state as 
    // appropriate.
    HRESULT NotifyItemAdded([in] EFNFLAGS   grfEFN, [in] IVsHierarchy *pHier, [in] VSITEMID itemid, [in] LPCOLESTR pszMkDocument);

    // This method is   called whenever a file is renamed.
    HRESULT NotifyItemRenamed([in] IVsHierarchy *pHier, [in] VSITEMID   itemid, [in] LPCOLESTR pszMkDocumentOld, [in] LPCOLESTR pszMkDocumentNew);

    // This method is   called whenever a file is saved.
    HRESULT NotifyDependentItemSaved([in]   IVsHierarchy *pHier, [in] VSITEMID itemidParent, [in] LPCOLESTR pszMkDocumentParent, [in] VSITEMID itemidDpendent, [in] LPCOLESTR pszMkDocumentDependent);
}

//----------------------------------------------------------------------------
// IVsMultiItemSelect
//----------------------------------------------------------------------------
// Implemented by windows that support multiple selection of IVsHierarchy items
// (e.g. the IVsUIHierarchyWindow object).

typedef struct __VSITEMSELECTION
{
    IVsHierarchy *pHier;
    VSITEMID itemid;
} VSITEMSELECTION;


// These element IDs are the only element IDs that can be used with the
// selection service.  Do not attempt to pass any other element IDs, or
// attempt to pass the SEID_MAX element ID.
typedef DWORD VSSELELEMID;
cpp_quote("#define SEID_UndoManager             0")
cpp_quote("#define SEID_WindowFrame             1")
cpp_quote("#define SEID_DocumentFrame           2")
cpp_quote("#define SEID_StartupProject          3")
cpp_quote("#define SEID_PropertyBrowserSID      4")
//Note: SEID_UserContext should be used only by document windows that   do not push
//    selection context to the propery browser
//    see VSFPROPID_UserContext for the alternative case
cpp_quote("#define SEID_UserContext             5")
cpp_quote("#define SEID_ResultList              6") // IOleCommandTarget for list navigation cmds
// SEID_LastWindowFrame is what SEID_WindowFrame was before it got its current value.
// It   is guaranteed to be different from SEID_WindowFrame (unless both are empty).
cpp_quote("#define SEID_LastWindowFrame         7") 
cpp_quote("#define SEID_MAX                     9")

enum __VSGSIFLAGS
{
    // Indicates that   the pHier field of VSITEMSELECTION structure should not
    // be   filled in (and therefore not AddRef()'d).  This is useful in the case
    // where a selection is within one hierarchy,   as this value does not need
    // to   be filled.  The pHier was already obtained via GetCurrentSelection or
    // via OnSelectionChanged.
    GSI_fOmitHierPtrs   = 0x00000001
};
typedef DWORD VSGSIFLAGS;

[
    uuid(uuid_IVsMultiItemSelect),
    version(1.0),
    pointer_default(unique)
]
interface IVsMultiItemSelect : IUnknown
{
    HRESULT GetSelectionInfo([out] ULONG *pcItems,
        [out] BOOL  *pfSingleHierarchy);

    HRESULT GetSelectedItems([in]  VSGSIFLAGS grfGSI,
        [in]  ULONG cItems,
        [out, size_is(cItems)]  VSITEMSELECTION rgItemSel[]);
}

//----------------------------------------------------------------------------
// IEnumHierarchyItems
//----------------------------------------------------------------------------
// Implemented by the Environment. 
// Retrieved via the SVsEnumHierarchyItemsFactory service
[
    uuid(uuid_IEnumHierarchyItems),
    version(1.0),
    pointer_default(unique)
]
interface IEnumHierarchyItems : IUnknown
{
    HRESULT Next([in]   ULONG celt, [out, size_is(celt), length_is(*pceltFetched)] VSITEMSELECTION *rgelt, [out] ULONG *pceltFetched);
    HRESULT Skip([in]   ULONG celt);
    HRESULT Reset(void);
    HRESULT Clone([out] IEnumHierarchyItems **ppenum);
}

enum __VSEHI // VS Enum Hierarchy Items flags
{
    VSEHI_Leaf              = 0x00000001,  // return leaf nodes (nonexpandable)
    VSEHI_Branch                = 0x00000002,  // return branch nodes (expandable)
    VSEHI_Nest              = 0x00000004,  // visit nested hierarchies
    VSEHI_AllowSideEffects  = 0x00000008,  // recurse into that return true for VSHPROPID_HasEnumerationSideEffects (requires VSEHI_NEST)
    VSEHI_DataConn          = 0x00000008,  // OBSOLETE. use VSEHI_AllowSideEffects instead
    VSEHI_OmitHier          = 0x00010000   // Don't fill pHier member of VSITEMSELECTION (incompatible with VSEHI_Nest)
};
typedef DWORD VSEHI;

//----------------------------------------------------------------------------
// IVsEnumHierarchyItemsFactory
//----------------------------------------------------------------------------
// Implemented by the Environment. 
// Helper object to assist in walking over IVsHierarchy objects.
[
    uuid(uuid_IVsEnumHierarchyItemsFactory),
    version(1.0),
    pointer_default(unique)
]
interface IVsEnumHierarchyItemsFactory : IUnknown
{
    HRESULT EnumHierarchyItems ([in]    IVsHierarchy *          pHierRoot, 
        [in]    VSEHI                   grfItems,
        [in]    VSITEMID                itemidRoot, // usually VSITEMID_ROOT
        [out]   IEnumHierarchyItems **  ppenum
        );
};
cpp_quote("#define SID_SVsEnumHierarchyItemsFactory IID_IVsEnumHierarchyItemsFactory")

//----------------------------------------------------------------------------
// IVsSwatchClient
//----------------------------------------------------------------------------
// Implemented by advanced clients who want the ability to have custom owner-drawn 
// swatch controls placed on menus. Swatches are defined in the BUTTONS section
// of a VsPackage's .CTC file with the type SWATCH. 
//
// When the shell first encounters a swatch control placed on a menu, it will 
// fire an IOleCommandTarget::Exec call with:
//   * The control's guid/id pair as specified in the .CTC definition.
//   * An ExecOpt param with hiword of EXECOPTHW_GETSWATCH and loword of OLECMDEXECOPT_DODEFAULT
//        const DWORD dwExecOpt = MAKELONG(EXECOPTHW_GETSWATCH, OLECMDEXECOPT_DODEFAULT);
//        hr = pCmdTrgt->Exec(pguid, dwCmdId, dwExecOpt, NULL, &var);
//   * A variant out param that takes the IVsSwatchClient pointer for the client owning this control
//
// The methods on the swatch client interface are then called to obtain data 
// about the swatch control and to allow the client to update the control, 
// process user input, and render the swatch.

typedef struct __VSSWATCHMETRICS
{
    int cRows;              // Number of rows/lines, must be >= 1
    int cColumns;           // Number of columns, must be >= 1
    int cxCtrl;             // Preferred width of whole control; Office will override if too small, use 0 if don't care
    int cyCtrl;             // Preferred height of whole control; Office will override if too small, use 0 if don't care
    int cxCell;             // Width of each cell; 0 or -1 = current button width, -2 = default color cell width
    int cyCell;             // Height of each cell; 0 or -1 = current button height, -2 = default color cell height
    int dxBetween;          // Pixel width between cells; 0 or -1 = use default of 2 pixels
    int dyBetween;          // Pixel height between cells; 0 or -1 = use default of 2 pixels
    BOOL    fPaletteSensitive;  // TRUE if the client image is sensitive to palette changes
}   VSSWATCHMETRICS;

enum __VSSWATCHRENDERFLAGS
{
    VSSRF_DEFAULT     = 0x00000000,
    VSSRF_DISABLED  =   0x00000001,
    VSSRF_SELECTED  =   0x00000002,
    VSSRF_FOCUS   = 0x00000004
};

typedef DWORD VSSWATCHRENDERFLAGS;

typedef struct __VSSWATCHRENDER
{
    VSSWATCHRENDERFLAGS grfFlags;     // Ctrl state, see enum above
    int               x;          // Column-coordinate of cell to render
    int               y;          // Row-coordinate of cell to render
    int               nAltitude;  // Btn face altitude; -1 = lowered, 0 = normal, 1 = raised
    HDC               hdc;        // HDC to render image into
    RECT                  *prc;       // Bounding rect for image
}   VSSWATCHRENDER;

[
    uuid(uuid_IVsSwatchClient),
    version(1.0),
    pointer_default(unique),
    local
]
interface IVsSwatchClient : IUnknown
{
    // Client   fills struct with creation data for their swatch control.  See
    //  comments for VSSWATCHMETRICS above.
    HRESULT GetMetrics ([in, out]   VSSWATCHMETRICS *psm);

    // Client   returns initial/current selection. (-1, -1) means no selection.
    HRESULT GetSelection ([in, out] int *pxCur,
        [in, out] int *pyCur);

    // Notify   client of current/updated selection; client can change
    //  selection   by modifying the in/out params.
    // Special: returning   (-1, -1) means the whole control must be redrawn
    //  (example:   colors rotating in a MRU swatch).
    HRESULT SelectionUpdate ([in,   out] int *pxCur,
        [in,    out] int *pyCur);

    // Client   should render the cell with the specified criteria, or return an
    //  MSO ctrl id for one of Office's standard controls.  See msobtn.h for
    //  definitions of MSO tcids.
    HRESULT RenderCell([in] VSSWATCHRENDER *pRender,
        [in, out] int *ptcidRet);

    // Tells the client that swatch (x, y) was selected. A failure return
    //  will prevent selection from changing to (x, y).
    HRESULT SelectCell([in] int x,
        [in] int y);

    // Client   returns tooltip string in out param, NULL if none
    HRESULT GetCellTooltip([in] int x,
        [in] int y,
        [out, retval] BSTR  *pbstrTooltip);

    // Client   returns count of enabled cells in this swatch control
    HRESULT GetEnabledCount([in, out]   int *pcEnabled);

    // Client   should realize the specified palette and return the old
    //  palette.    The shell will realize the old palette again when 
    //  necessary.  This method is only called on   clients that have
    //  specified   palette sensitivity.
    HRESULT RealizePalette([in] HDC hdc,
        [out, retval] HPALETTE  *phpalOld);
};

//----------------------------------------------------------------------------
// IVsTrackSelectionEx
//----------------------------------------------------------------------------
// Implemented by the Environment associated with each WindowFrame.
// Interface is retrieved by QueryService on the site object provided by the 
// IVsWindowFrame to the object hosted within the WindowFrame. Third parties
// can also access this interface on any WindowFrame by using the IServiceProvider
// returned by VSFPROPID_SPFrame.
// This interface is used to announce the selection within the window to the 
// Environment. When appropriate, selections within the window are propagated to the
// global SVsMonitorSelection service.
cpp_quote("#define HIERARCHY_DONTCHANGE       ((IVsHierarchy *)(-1))")
cpp_quote("#define SELCONTAINER_DONTCHANGE    ((ISelectionContainer *)(-1))")
cpp_quote("#define HIERARCHY_DONTPROPAGATE    ((IVsHierarchy *)(-2))")
cpp_quote("#define SELCONTAINER_DONTPROPAGATE ((ISelectionContainer *)(-2))")

[
    uuid(uuid_IVsTrackSelectionEx),
    version(1.0),
    pointer_default(unique)
]
interface IVsTrackSelectionEx : ITrackSelection
{
    HRESULT OnSelectChangeEx([in] IVsHierarchy *pHier,
        [in] VSITEMID itemid,
        [in] IVsMultiItemSelect *pMIS,
        [in] ISelectionContainer *pSC);

    HRESULT IsMyHierarchyCurrent([out] BOOL *pfCurrent);

    HRESULT OnElementValueChange([in] VSSELELEMID elementid,
        [in] BOOL fDontPropagate,
        [in] VARIANT varValue);

    // if *pitemid==VSITEMID_SELECTION, get selection from *ppMIS
    //
    HRESULT GetCurrentSelection([out] IVsHierarchy ** ppHier,
        [out] VSITEMID * pitemid,
        [out] IVsMultiItemSelect ** ppMIS,
        [out] ISelectionContainer **ppSC);
}

cpp_quote("#define SID_SVsTrackSelectionEx IID_IVsTrackSelectionEx")

//----------------------------------------------------------------------------
// IVsSelectionEvents
//----------------------------------------------------------------------------
// Implemented by clients that want to track selection and currency within the Environment.
[
    uuid(uuid_IVsSelectionEvents),
    version(1.0),
    pointer_default(unique)
]
interface IVsSelectionEvents : IUnknown
{
    // An "after" event, so new is current.
    HRESULT OnSelectionChanged([in] IVsHierarchy *pHierOld,
        [in]    VSITEMID itemidOld,
        [in]    IVsMultiItemSelect *pMISOld,
        [in]    ISelectionContainer *pSCOld,
        [in]    IVsHierarchy *pHierNew,
        [in]    VSITEMID itemidNew,
        [in]    IVsMultiItemSelect *pMISNew,
        [in]    ISelectionContainer *pSCNew);

    HRESULT OnElementValueChanged([in] VSSELELEMID elementid,
        [in] VARIANT varValueOld,
        [in] VARIANT varValueNew);

    HRESULT OnCmdUIContextChanged([in] VSCOOKIE dwCmdUICookie,
        [in] BOOL   fActive);
}

//----------------------------------------------------------------------------
// IVsMonitorSelection
//----------------------------------------------------------------------------
// Implemented by the Environment.
// Used by clients that want to track selection and currency within the Environment.
[
    uuid(uuid_IVsMonitorSelection),
    version(1.0),
    pointer_default(unique)
]
interface IVsMonitorSelection : IUnknown
{
    // If pitemid is VSITEMID_SELECTION, then the selection is retrieved
    // via the IVsMultiSelectItem object.
    HRESULT GetCurrentSelection([out] IVsHierarchy **ppHier,
        [out] VSITEMID *pitemid,
        [out] IVsMultiItemSelect **ppMIS,
        [out] ISelectionContainer **ppSC);

    HRESULT AdviseSelectionEvents([in]  IVsSelectionEvents *psink,
        [out]   VSCOOKIE *pdwCookie);

    HRESULT UnadviseSelectionEvents([in] VSCOOKIE dwCookie);

    HRESULT GetCurrentElementValue([in]  VSSELELEMID elementid,
        [out] VARIANT *pvarValue);

    HRESULT GetCmdUIContextCookie([in] REFGUID rguidCmdUI,
        [out]   VSCOOKIE *pdwCmdUICookie);

    HRESULT IsCmdUIContextActive([in] VSCOOKIE dwCmdUICookie,
        [out] BOOL  *pfActive);

    HRESULT SetCmdUIContext([in] VSCOOKIE dwCmdUICookie,
        [in] BOOL fActive);
}

cpp_quote("#define SID_SVsShellMonitorSelection IID_IVsMonitorSelection")

// GUIDs used in calling IVsMonitorSelection::GetCmdUIContextCookie()
cpp_quote("extern const __declspec(selectany) GUID UICONTEXT_SolutionBuilding            = {0xadfc4e60, 0x0397, 0x11d1, {0x9f, 0x4e, 0x00, 0xa0, 0xc9, 0x11, 0x00, 0x4f}};")
cpp_quote("extern const __declspec(selectany) GUID UICONTEXT_Debugging                   = {0xadfc4e61, 0x0397, 0x11d1, {0x9f, 0x4e, 0x00, 0xa0, 0xc9, 0x11, 0x00, 0x4f}};")
cpp_quote("extern const __declspec(selectany) GUID UICONTEXT_Dragging                    = {0xb706f393, 0x2e5b, 0x49e7, {0x9e, 0x2e, 0xb1, 0x82, 0x5f, 0x63, 0x9b, 0x63}};")
cpp_quote("extern const __declspec(selectany) GUID UICONTEXT_FullScreenMode              = {0xadfc4e62, 0x0397, 0x11d1, {0x9f, 0x4e, 0x00, 0xa0, 0xc9, 0x11, 0x00, 0x4f}};")
cpp_quote("extern const __declspec(selectany) GUID UICONTEXT_DesignMode                  = {0xadfc4e63, 0x0397, 0x11d1, {0x9f, 0x4e, 0x00, 0xa0, 0xc9, 0x11, 0x00, 0x4f}};")
cpp_quote("extern const __declspec(selectany) GUID UICONTEXT_NoSolution                  = {0xadfc4e64, 0x0397, 0x11d1, {0x9f, 0x4e, 0x00, 0xa0, 0xc9, 0x11, 0x00, 0x4f}};")
cpp_quote("extern const __declspec(selectany) GUID UICONTEXT_SolutionExists              = {0xf1536ef8, 0x92ec, 0x443c, {0x9e, 0xd7, 0xfd, 0xad, 0xf1, 0x50, 0xda, 0x82}};")
cpp_quote("extern const __declspec(selectany) GUID UICONTEXT_EmptySolution               = {0xadfc4e65, 0x0397, 0x11d1, {0x9f, 0x4e, 0x00, 0xa0, 0xc9, 0x11, 0x00, 0x4f}};")
cpp_quote("extern const __declspec(selectany) GUID UICONTEXT_SolutionHasSingleProject    = {0xadfc4e66, 0x0397, 0x11d1, {0x9f, 0x4e, 0x00, 0xa0, 0xc9, 0x11, 0x00, 0x4f}};")
cpp_quote("extern const __declspec(selectany) GUID UICONTEXT_SolutionHasMultipleProjects = {0x93694fa0, 0x0397, 0x11d1, {0x9f, 0x4e, 0x00, 0xa0, 0xc9, 0x11, 0x00, 0x4f}};")
cpp_quote("extern const __declspec(selectany) GUID UICONTEXT_CodeWindow                  = {0x8fe2df1d, 0xe0da, 0x4ebe, {0x9d, 0x5c, 0x41, 0x5d, 0x40, 0xe4, 0x87, 0xb5}};")


//----------------------------------------------------------------------------
// Forward interface declarations
//----------------------------------------------------------------------------
interface IVsTaskList;
interface IVsTaskProvider;
interface IVsTaskItem;
interface IVsEnumTaskItems;

//----------------------------------------------------------------------------
// VSTASKPRIORITY enum
//----------------------------------------------------------------------------
typedef [uuid(E323C22C-55B2-11D3-9479-00C04F683646)] // Needed for VB scripts
enum _vstaskpriority
{
    TP_HIGH,
    TP_NORMAL,
    TP_LOW
} VSTASKPRIORITY;

//----------------------------------------------------------------------------
// VSTASKCATEGORY enum, space between each for custom categories
//----------------------------------------------------------------------------
typedef enum _vstaskcategory
{
    CAT_ALL =   1,  //not a real category, only used for filter for AutoFilter or custom views
    CAT_BUILDCOMPILE = 10,
    CAT_COMMENTS = 20,
    CAT_CODESENSE   = 30,  //CAT_CODESENSE and CAT_BUILDCOMPILE now go to the same view
    CAT_SHORTCUTS   = 40,
    CAT_USER = 50,
    CAT_MISC = 60,
    CAT_HTML = 70
} VSTASKCATEGORY;

//----------------------------------------------------------------------------
// VSTASKBITMAP enum
//----------------------------------------------------------------------------
enum _vstaskbitmap
{
    BMP_COMPILE =   -1,
    BMP_SQUIGGLE = -2,
    BMP_COMMENT =   -3,
    BMP_SHORTCUT = -4,
    BMP_USER = -5
};

typedef LONG VSTASKBITMAP;

//----------------------------------------------------------------------------
// VSTASKFIELD enum.  These are used both for sorts and for which columns
// are displayed
//----------------------------------------------------------------------------
typedef enum _vstaskfield
{
    FLD_PRIORITY,
    FLD_CATEGORY,   //not visible
    FLD_SUBCATEGORY, //not visible
    FLD_BITMAP, //visible merging of Category and Subcategory concepts
    FLD_CHECKED,
    FLD_DESCRIPTION,
    FLD_FILE,
    FLD_LINE,
    FLD_COLUMN, //not   visible
    FLD_CUSTOM,
    FLD_PROVIDERKNOWSORDER      //not visible, sorts on provider then def sort order within provider
} VSTASKFIELD;


//----------------------------------------------------------------------------
// GUIDS for built in task list views
//----------------------------------------------------------------------------
cpp_quote("DEFINE_GUID(GUID_VsTaskListViewAll, 0x1880202e, 0xfc20, 0x11d2, 0x8b, 0xb1, 0x0, 0xc0, 0x4f, 0x8e, 0xc2, 0x8c);")
cpp_quote("DEFINE_GUID(GUID_VsTaskListViewUserTasks, 0x1880202f, 0xfc20, 0x11d2, 0x8b, 0xb1, 0x0, 0xc0, 0x4f, 0x8e, 0xc2, 0x8c);")
cpp_quote("DEFINE_GUID(GUID_VsTaskListViewShortcutTasks, 0x18802030, 0xfc20, 0x11d2, 0x8b, 0xb1, 0x0, 0xc0, 0x4f, 0x8e, 0xc2, 0x8c);")
cpp_quote("DEFINE_GUID(GUID_VsTaskListViewHTMLTasks, 0x36ac1c0d, 0xfe86, 0x11d2, 0x8b, 0xb1, 0x0, 0xc0, 0x4f, 0x8e, 0xc2, 0x8c);")
cpp_quote("DEFINE_GUID(GUID_VsTaskListViewCompilerTasks, 0x18802033, 0xfc20, 0x11d2, 0x8b, 0xb1, 0x0, 0xc0, 0x4f, 0x8e, 0xc2, 0x8c);")
cpp_quote("DEFINE_GUID(GUID_VsTaskListViewCommentTasks, 0x18802034, 0xfc20, 0x11d2, 0x8b, 0xb1, 0x0, 0xc0, 0x4f, 0x8e, 0xc2, 0x8c);")
cpp_quote("DEFINE_GUID(GUID_VsTaskListViewCurrentFileTasks, 0x18802035, 0xfc20, 0x11d2, 0x8b, 0xb1, 0x0, 0xc0, 0x4f, 0x8e, 0xc2, 0x8c);")
cpp_quote("DEFINE_GUID(GUID_VsTaskListViewCheckedTasks, 0x18802036, 0xfc20, 0x11d2, 0x8b, 0xb1, 0x0, 0xc0, 0x4f, 0x8e, 0xc2, 0x8c);")
cpp_quote("DEFINE_GUID(GUID_VsTaskListViewUncheckedTasks, 0x18802037, 0xfc20, 0x11d2, 0x8b, 0xb1, 0x0, 0xc0, 0x4f, 0x8e, 0xc2, 0x8c);")

//----------------------------------------------------------------------------
// IVsTaskList
//----------------------------------------------------------------------------
// Implemented by the Environment by the TaskList tool window.
// Used by parties that want to add their own special kind of task items to the
// TaskList window (e.g. language service objects use this to display "red squiggly" errors).
// NOTE: Project that want to display build errors/warnings as a result of a build operation
// in the TaskList can often simply use IVsOutputWindowPane::OutputTaskItemString.
[
    uuid(uuid_IVsTaskList)
]
interface IVsTaskList : IUnknown
{
    // Register a   task provider with the task list.
    HRESULT RegisterTaskProvider ([in] IVsTaskProvider *pProvider,
        [out] VSCOOKIE *pdwProviderCookie);

    // Unregister   a task provider previously registered with above
    HRESULT UnregisterTaskProvider ([in] VSCOOKIE   dwProviderCookie);

    // Indicate to the task list that   a provider has new/updated tasks
    HRESULT RefreshTasks ([in] VSCOOKIE dwProviderCookie);

    // Standard enumerator over entire list of tasks
    HRESULT EnumTaskItems   ([out] IVsEnumTaskItems **ppEnum);

    //filter so that only   the specified category is shown
    HRESULT AutoFilter ([in] VSTASKCATEGORY cat);

    //The   task list caches the provider info so that it doesn't have to
    //keep getting the subcategory list and the image   list.  If any of
    //that info changes while   you're still registered, call this function.
    HRESULT UpdateProviderInfo([in] VSCOOKIE dwProviderCookie);

    // set the ui   output mode the task list should follow - if fSilent, no ui
    HRESULT SetSilentOutputMode([in] BOOL   fSilent);

    // output   tasklist contents to stream
    HRESULT DumpOutput ([in] DWORD dwReserved,  // must be 0. may be used to control format of stream in future
        [in] VSTASKCATEGORY cat,
        [in] IStream *pstmOutput,
        [out]   BOOL *pfOutputWritten);

    //to register   your custom category.  Specify where you want to be in terms of sort order
    //and   we'll return you the closest we can get
    HRESULT RegisterCustomCategory(REFGUID guidCat, [in] DWORD dwSortOrder, [out]   VSTASKCATEGORY *pCat);
    HRESULT UnregisterCustomCategory([in]   VSTASKCATEGORY catAssigned);

    //filter so that only   the custom view guid is shown
    HRESULT AutoFilter2 (REFGUID guidCustomView);
};

cpp_quote("DEFINE_GUID(CLSID_VsTaskList, 0xBC5955D5, 0xaa0d, 0x11d0, 0xa8, 0xc5, 0x00, 0xa0, 0xc9, 0x21, 0xa4, 0xd2);")
cpp_quote("DEFINE_GUID(CLSID_VsTaskListPackage, 0x4A9B7E50, 0xaa16, 0x11d0, 0xa8, 0xc5, 0x00, 0xa0, 0xc9, 0x21, 0xa4, 0xd2);")

//This is the height and width for the custom bitmaps that you can provide
//in your image list
cpp_quote("#define TL_CATEGORY_BMP_WIDTH  16")
cpp_quote("#define TL_CATEGORY_BMP_HEIGHT 16")

//----------------------------------------------------------------------------
// IVsTaskProvider[2]
//----------------------------------------------------------------------------
// Implemented by parties that want to add their own special kind of task items to the
// TaskList window (e.g. language service objects use this to display "red squiggly" errors).
// Interface is passed to the Environment through IVsTaskList::RegisterTaskProvider.
// NOTE: Projects that want to display build errors/warnings as a result of a build operation
// in the TaskList can often simply use IVsOutputWindowPane::OutputTaskItemString.
[
    uuid(uuid_IVsTaskProvider)
]
interface IVsTaskProvider : IUnknown
{
    // Standard enumerator over tasks   supplied by this provider
    HRESULT EnumTaskItems   ([out] IVsEnumTaskItems **ppEnum);

    //phImageList   is actually an HIMAGELIST*, but I can't get MIDL
    //to recognize that even by including/importing commctrl.h, so just cast it
    [local][propget] HRESULT       ImageList ([out,retval] HANDLE *phImageList);

    //return the list   of subcategories for the tasks you provide.  The task
    //itself will   return an index into this list when asked for a subcategory
    //If cbstr is   passed in as zero and rgbstr as NULL, then the provider
    //should set *pcActual to   the actual number of BSTRs that need to be returned.
    [propget]   HRESULT SubcategoryList([in] ULONG cbstr, [out, size_is(cbstr)] BSTR rgbstr[], [out] ULONG *pcActual);

    // This method is   for use if your task provider wants to unregister
    // while it still   has tasks and then later reregister and retake
    // ownership of those   tasks.  The bstr should uniquely describe this
    // provider. (EXAMPLE:      CodeSense:c:\dir\filename.cs if you
    // have a   different provider for each file, or simply C# CodeSense
    // if   you don't)
    // If   you don't plan to unregister while you have tasks, just
    // return   E_NOTIMPL
    [propget]   HRESULT     ReRegistrationKey ([out] BSTR *pbstrKey);

    //To solve the circular ref problem (aka the "when do   I unregister" problem):
    //If you haven't unregistered   by the time the tasklist package is closing down,
    //you'll get this   notification, which basically means "unregister now or forever
    //hold your peace".  (This really   should be named OnTaskListPackageClose or
    //something like that, but when I   first added it I thought I would call it from
    //FinalRelease, it wasn't   until later that I realized it should really be called
    //once the task list can no longer be   reached by a QueryService)
    HRESULT OnTaskListFinalRelease([in] IVsTaskList *pTaskList);
};

[
    uuid(uuid_IVsTaskProvider2)
]
interface IVsTaskProvider2 : IVsTaskProvider
{
    [propget]     HRESULT   MaintainInitialTaskOrder ([out,retval] BOOL *bMaintainOrder);
};

//----------------------------------------------------------------------------
// IVsTaskItem[2]
//----------------------------------------------------------------------------
// Implemented by parties that want to add their own special kind of task items to the
// TaskList window.
// Interface retrieved by the Environment by using IVsTaskListProvider::EnumTaskItems.
// NOTE: Projects that want to display build errors/warnings as a result of a build operation
// in the TaskList can often simply use IVsOutputWindowPane::OutputTaskItemString.
[
    uuid(uuid_IVsTaskItem)
]
interface IVsTaskItem : IUnknown
{
    //--------------------------------------------------------------------
    // Properties
    // Only implement   the propput methods if you want that field to
    // be   modifiable by the user
    //--------------------------------------------------------------------
    HRESULT   get_Priority ([out,retval] VSTASKPRIORITY *ptpPriority);
    HRESULT   put_Priority ([in] VSTASKPRIORITY tpPriority);
    [propget]     HRESULT   Category([out, retval] VSTASKCATEGORY *pCat);

    //return the index into the subcategory list maintained by the provider
    [propget]     HRESULT   SubcategoryIndex([out, retval]long *pIndex);

    //If you have   provided a custom image list, return the correct index
    //into that.    Otherwise return one of the VSTASKBITMAP enums to use
    //one   of the default bitmaps.
    [propget]     HRESULT   ImageListIndex([out,retval] long *pIndex);

    HRESULT   get_Checked([out,retval]BOOL *pfChecked);
    HRESULT   put_Checked([in] BOOL fChecked);
    HRESULT   get_Text ([out,retval] BSTR *pbstrName);
    HRESULT   put_Text ([in] BSTR bstrName);
    [propget]     HRESULT   Document ([out,retval] BSTR *pbstrMkDocument);

    //The   line number returned should be 0 based
    [propget]     HRESULT   Line ([out,retval] long *piLine);

    //implement this if you care whether errors on the same line are correctly
    //sorted
    [propget]     HRESULT   Column([out, retval] long *piCol);

    [propget]     HRESULT   CanDelete([out, retval]BOOL *pfCanDelete);
    [propget]     HRESULT   IsReadOnly([in] VSTASKFIELD field, [out, retval]BOOL *pfReadOnly);
    [propget]     HRESULT   HasHelp([out, retval]BOOL *pfHasHelp);

    //--------------------------------------------------------------------
    // Actions
    //--------------------------------------------------------------------
    HRESULT   NavigateTo (void);
    HRESULT   NavigateToHelp(void);

    //--------------------------------------------------------------------
    // Notifications
    //--------------------------------------------------------------------
    HRESULT   OnFilterTask([in]BOOL fVisible);
    HRESULT   OnDeleteTask();
};

//#ifndef INTEROPLIB
[
    uuid(uuid_IVsTaskItem2)
]
interface IVsTaskItem2 : IVsTaskItem
{
    //BrowseObject is   obsolete.  Task list no longer pushes selection context
    [propget]   HRESULT BrowseObject([out, retval] IDispatch **ppObj);
    HRESULT get_CustomColumnText([in]REFGUID guidView, [in]ULONG iCustomColumnIndex, [out, retval]BSTR *pbstrText); 
    HRESULT put_CustomColumnText([in]REFGUID guidView, [in]ULONG iCustomColumnIndex, [in]BSTR bstrText);
    [propget]   HRESULT IsCustomColumnReadOnly([in]REFGUID guidView, [in]ULONG iCustomColumnIndex, [out, retval]BOOL *pfReadOnly);
};
//#endif // INTEROPLIB

//----------------------------------------------------------------------------
// IVsEnumTaskItems interface
//----------------------------------------------------------------------------
// Implemented by parties that want to add their own special kind of task items to the
// TaskList window.
// Interface retrieved by the Environment by using IVsTaskListProvider::EnumTaskItems.
[
    uuid(uuid_IVsEnumTaskItems)
]
interface IVsEnumTaskItems : IUnknown
{
    HRESULT     Next ([in] ULONG celt, [out, size_is(celt), length_is(*pceltFetched)] IVsTaskItem **rgelt, [out, optional] ULONG *pceltFetched);
    HRESULT     Skip ([in] ULONG celt);
    HRESULT     Reset (void);
    HRESULT     Clone ([out] IVsEnumTaskItems **ppenum);
};

//----------------------------------------------------------------------------
// IVsCommentTaskToken
//----------------------------------------------------------------------------
// Implemented by the Environment.
// Used by language services that support Comment Tokens (e.g. UNDONE, TODO, etc.).
// Interface retrieved by IVsEnumCommentTaskTokens::Next.
// IVsCommentTaskToken is an interface representing one comment task token.
// It has properties that represent the text and priority of the token.
// The list of comment tokens is managed globally and edited by the user via a ToolOptions page.
[
    uuid(uuid_IVsCommentTaskToken)
]
interface IVsCommentTaskToken : IUnknown
{
    [propget]   HRESULT Text([out, retval] BSTR* pbstrText);
    [propget]   HRESULT Priority([out, retval] VSTASKPRIORITY* ptpPriority);
};

//----------------------------------------------------------------------------
// IVsEnumCommentTaskTokens
//----------------------------------------------------------------------------
// Implemented by the Environment.
// Used by language services that support Comment Tokens (e.g. UNDONE, TODO, etc.).
// Interface retrieved by IVsCommentTaskInfo::EnumTokens.
// IVsEnumCommentTaskTokens is an enumerator interface for a collection of
// comment task tokens.
// The list of comment tokens is managed globally and edited by the user via a ToolOptions page.
[
    uuid(uuid_IVsEnumCommentTaskTokens)
]
interface IVsEnumCommentTaskTokens : IUnknown
{
    HRESULT   Next ([in] ULONG celt, [out, size_is(celt), length_is(*pceltFetched)] IVsCommentTaskToken **rgelt, [out] ULONG *pceltFetched);
    HRESULT   Skip ([in] ULONG celt);
    HRESULT   Reset (void);
    HRESULT   Clone ([out] IVsEnumCommentTaskTokens **ppenum);
};

//----------------------------------------------------------------------------
// IVsCommentTaskInfo interface
//----------------------------------------------------------------------------
// Implemented by the Environment.
// Used by language services that support Comment Tokens (e.g. UNDONE, TODO, etc.).
// Interface retrieved by QueryService(SID_SVsTaskList, IID_IVsCommentTaskInfo).
// The list of comment tokens is managed globally and edited by the user via a ToolOptions page.
[
    uuid(uuid_IVsCommentTaskInfo)
]
interface IVsCommentTaskInfo : IUnknown
{
    // Get the default comment task token. This is the token that
    // add-ins should   use when inserting generic comment tasks
    // into the user's code.
    [propget]   HRESULT DefaultToken([out, retval] IVsCommentTaskToken** ppToken);

    // Get an   enumerator for all comment task tokens (including the
    // default token). These are the tokens that task   providers
    // should   detect if they provide comment tasks.
    [propget]   HRESULT EnumTokens([out, retval] IVsEnumCommentTaskTokens** ppEnum);

    [propget]   HRESULT TokenCount([out, retval] long *pCount);
};

//----------------------------------------------------------------------------
// IVsTaskListEvents interface
//----------------------------------------------------------------------------
// IVsTaskListEvents is an event set for events related to the task list.
// When one of the events occurs, the task list will query each registered
// provider to see if it supports this interface.  If the provider supports
// the interface, the notification function will be called on it.   Since
// this notification is only for comment tasks so far, (and we can't think
// of anything else we would need it for), we've optimized it for comment
// tasks.  Since comment tasks are found while parsing, the model is that
// before parsing the first time, you would register and poll the task list
// for the current comment tokens.  Then, as long as you're registered,
// you will get notified of any changes to the tokens.  If we ever add any
// other notifications (that aren't necessary for all providers, because if
// they were, they'd be on IVsTaskProvider), we'll have
// to do a real connection point.
[
    uuid(uuid_IVsTaskListEvents)
]
interface IVsTaskListEvents : IUnknown
{
    // Notification that the set of comment task tokens has been
    // modified.
    HRESULT OnCommentTaskInfoChanged();
};

cpp_quote("#define SID_SVsTaskList IID_IVsTaskList")

//----------------------------------------------------------------------------
// interface IVsOutputWindowPane
//----------------------------------------------------------------------------
// Implemented by the Environment by the OutputWindow tool window.
// Interface retrieved by IVsOutputWindow::GetPane.
// Used by parties that want to display messages in the OutputWindow. The OutputWindow
// is an extensible Window, but every OutputWindowPane must have an owner VsPackage
// that creates the pane via IVsOutputWindow::CreatePane. There are two standard OutputWindow
// panes owned by the Environment:
//   "Build" -- Projects often display build errors/warnings in the "Build" OutputWindow pane.
//              This pane is create by the SVsSolutionBuildManager service. The pointer to 
//              the pane is passed to projects as part of IVsBuildableProjectCfg operations.
//   "General" -- Any party can display miscellaneous informational messages that occur at any 
//              time can be displayed in the "General" OutputWindow pane. The "General" pane 
//              can be retrieved by calling QueryService(SID_SVsGeneralOutputWindowPane, 
//              IID_IVsOutputWindowPane) as a global service.
cpp_quote("DEFINE_GUID(GUID_BuildOutputWindowPane, 0x1BD8A850, 0x02D1, 0x11d1, 0xbe, 0xe7, 0x0, 0xa0, 0xc9, 0x13, 0xd1, 0xf8);")

[
    uuid(uuid_IVsOutputWindowPane),
    version(1.0),
    pointer_default(unique)
]
interface IVsOutputWindowPane : IUnknown
{
    // Outputs the given string to the output window.  Attempts to parse the string to obtain a
    // navigable file location.  The recognized format is as follows (square brackets indicate
    // optional content):
    //      v:\dir\file.ext [(loc)] : msg [: Lines: a,b,c...]
    // or
    //      \\server\share\dir\file.ext [(loc)] : msg [: Lines: a,b,c...]
    // where loc is one of the following:
    //      (line)
    //      (line-line)
    //      (line,col)
    //      (line,col-col)
    //      (line,col,len)
    //      (line,col,line,col)
    //
    // The "Lines" keyword signals a sequence of comma-separate line numbers that will be
    // highlighted when the user double-clicks on that output window entry.  This is useful for
    // indicating errors or warnings that involve a sequence of code statements rather than
    // only one.
    HRESULT OutputString([in]   LPCOLESTR pszOutputString);

    HRESULT Activate(void);
    HRESULT Hide(void);
    HRESULT Clear(void);
    HRESULT FlushToTaskList(void);

    // OutputTaskItemString and OutputTaskItemStringEx can be used to output a string to the output window
    // with accompanying filename/linenumber information but without task list information, if desired. If
    // either method is called with a NULL (or empty) string for pszTaskItemText this is assumed to be the case.
    // If the interface is being marshaled to another thread, pass in empty strings instead of NULL strings.
    HRESULT OutputTaskItemString([in]   LPCOLESTR pszOutputString,
        [in]    VSTASKPRIORITY nPriority,  // (was ULONG) use VSTASKPRIORITY enum value (tasklist.idl)
        [in]    VSTASKCATEGORY nCategory,  // (was ULONG) use VSTASKCATEGORY enum value (tasklist.idl)
        [in]    LPCOLESTR pszSubcategory,
        [in]    VSTASKBITMAP nBitmap,      // (was ULONG) use VSTASKBITMAP enum value (tasklist.idl)
        [in]    LPCOLESTR pszFilename,
        [in]    ULONG nLineNum,            // zero-based line number in pszFilename
        [in]    LPCOLESTR pszTaskItemText);
    HRESULT OutputTaskItemStringEx([in] LPCOLESTR   pszOutputString,
        [in]    VSTASKPRIORITY nPriority,  // (was ULONG) use VSTASKPRIORITY enum value (tasklist.idl)
        [in]    VSTASKCATEGORY nCategory,  // (was ULONG) use VSTASKCATEGORY enum value (tasklist.idl)
        [in]    LPCOLESTR pszSubcategory,
        [in]    VSTASKBITMAP nBitmap,      // (was ULONG) use VSTASKBITMAP enum value (tasklist.idl)
        [in]    LPCOLESTR pszFilename,
        [in]    ULONG nLineNum,            // zero-based line number in pszFilename
        [in]    LPCOLESTR pszTaskItemText,
        [in]    LPCOLESTR pszLookupKwd);   // VSUC_Usage_LookupF1 keyword string
    HRESULT GetName(BSTR *pbstrPaneName);
    HRESULT SetName(LPCOLESTR   pszPaneName);

    // This method is obsolete and simply calls OutputString.  To ensure thread safety,
    // the IVsOutputWindowPane interface should be marshaled to the running thread.
    HRESULT OutputStringThreadSafe([in] LPCOLESTR pszOutputString);
}

//----------------------------------------------------------------------------
// interface IVsOutputWindow
//----------------------------------------------------------------------------
// Implemented by the Environment by the OutputWindow tool window.
// Used by parties that want to display messages in the OutputWindow. The OutputWindow
// is an extensible Window, but every OutputWindowPane must have an owner VsPackage
// that creates the pane via IVsOutputWindow::CreatePane. There are two standard OutputWindow
// panes owned by the Environment:
//   "Build" -- Projects often display build errors/warnings in the "Build" OutputWindow pane.
//              This pane is create by the SVsSolutionBuildManager service. The pointer to 
//              the pane is passed to projects as part of IVsBuildableProjectCfg operations.
//   "General" -- Any party can display miscellaneous informational messages that occur at any 
//              time can be displayed in the "General" OutputWindow pane. The "General" pane 
//              can be retrieved by calling QueryService(SID_SVsGeneralOutputWindowPane, 
//              IID_IVsOutputWindowPane) as a global service.
[
    uuid(uuid_IVsOutputWindow),
    version(1.0),
    pointer_default(unique)
]
interface IVsOutputWindow : IUnknown
{
    HRESULT GetPane([in] REFGUID rguidPane, [out]   IVsOutputWindowPane **ppPane);
    HRESULT CreatePane([in] REFGUID rguidPane, [in] LPCOLESTR   pszPaneName, [in] BOOL fInitVisible, [in] BOOL fClearWithSolution);
    HRESULT DeletePane([in] REFGUID rguidPane);
}

cpp_quote("#define SID_SVsOutputWindow IID_IVsOutputWindow")

//----------------------------------------------------------------------------
// IVsAsyncEnum
//----------------------------------------------------------------------------
//      This interface is supported by enumerators which wish to support
//      asynchronous behavior.  The interface should be queried for
//      prior to calling IEnumXXX::Next(), and any callback interfaces must
//      be advised prior to the IEnumXXX::Next() call.
//
//      Synchronous enumerators may support IVsAsyncEnum, in which case
//      the same requirements that the callback interfaces are added prior
//      to normal direct manipulation of the enumerator via its primary
//      interface, but the entire count of elements available would be
//      passed as cElementsAvailable to
//      IVsAsyncEnumCallback::OnDataAvailable(), and fIsComplete would be
//      set to TRUE.
//
//      Stopping an asynchronous enumerator is itself an asynchronous
//      operation.  When the enumerator is stopped, an
//      IVsAsyncEnumCallback::OnDataAvailable() event is fired, with
//      cElementsAvailable set to zero, and fIsComplete set to TRUE.
//      Passing in TRUE to the IVsAsyncEnum::Stop() call causes the thread
//      to block until the enumerator has fired its final OnDataAvailable()
//      events.
[
    uuid(uuid_IVsAsyncEnum),
    version(1.0),
    pointer_default(unique)
]
interface IVsAsyncEnum : IUnknown
{
    HRESULT AdviseAsyncEnumCallback(
        [in] IVsAsyncEnumCallback *pIVsAsyncEnumCallback,
        [out] VSCOOKIE *pdwCookie);
    HRESULT UnadviseAsyncEnumCallback([in] VSCOOKIE dwCookie);

    HRESULT Stop([in] BOOL fSync);
}

//----------------------------------------------------------------------------
// IVsAsyncEnumCallback
//----------------------------------------------------------------------------
//      This event interface is used by asynchronous enumerator
//      consumers.  The enumerator's behavior remains inherently
//      synchronous, but as data is available without blocking,
//      OnDataAvailable() events are fired.  cElementsAvailable is
//      always a delta. Pure progress information may be conveyed by
//      the enumerator by passing 0 for cElementsAvailable and
//      revised values for ulProgressCurrent and ulProgressMax.
//
//      It's important that cElementsAvailable is remembered to be a
//      delta; an enumerator may choose to fire OnDataAvailable() for
//      each and every element that comes available in which case
//      cElementsAvailable will always be one.
[
    uuid(uuid_IVsAsyncEnumCallback),
    version(1.0),
    pointer_default(unique)
]
interface IVsAsyncEnumCallback : IUnknown
{
    HRESULT OnDataAvailable(
        [in] ULONG cElementsAvailable,
        [in] BOOL fIsComplete,
        [in] ULONG ulProgressCurrent,
        [in] ULONG ulProgressMax);
}


//----------------------------------------------------------------------------
// dwEffects passed to source via IVsHierarchyDropDataSource::OnDropNotify will
// be dwEffects returned by IVsHierarchyDropDataTarget::Drop.  There are three
// possible effects: DROPEFFECT_COPY, DROPEFFECT_MOVE, and DROPEFFECT_LINK.
// These effects are exclusive--they are not OR'ed together.
//
// DROPEFFECT_COPY means that the dropped item remains in the source and a
// copy of it was added to the target.
//
// DROPEFFECT_MOVE means that the dropped item was added to the target and
// it should be removed from the source and the its storage deleted.
//
// DROPEFFECT_LINK means that a link to the source item was added to the target
// so the item should be removed from the source but the storage should remain
// so that the link is not broken.  A link is therefore a special case of move.
//
//
// These flags have the same meanings in IVsUIHierWinClipboardHelper::Paste
// and IVsUIHierWinClipboardHelperEvents::OnPaste.
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
// IVsHierarchyDropDataSource[2]
//----------------------------------------------------------------------------
// Implemented by projects and IVsHierarchy objects that are source of drag/drop operations.
// Interface is retrieved by QI from IVsHierarchy.
[
    uuid(uuid_IVsHierarchyDropDataSource),
    version(1.0),
    pointer_default(unique)
]
interface IVsHierarchyDropDataSource : IUnknown
{
    HRESULT GetDropInfo([out]DWORD* pdwOKEffects,
        [out]IDataObject** ppDataObject,
        [out]IDropSource** ppDropSource);
    HRESULT OnDropNotify([in]BOOL   fDropped,
        [in]DWORD dwEffects);
}

[
    uuid(uuid_IVsHierarchyDropDataSource2),
    version(1.0),
    pointer_default(unique)
]
interface IVsHierarchyDropDataSource2 : IVsHierarchyDropDataSource
{
    // OnBeforeDropNotify   allows the drag source to prompt to save unsaved items being dropped.
    HRESULT OnBeforeDropNotify([in] IDataObject *pDataObject,
        [in] DWORD  dwEffect,
        [out,retval] BOOL *pfCancelDrop);
}

//----------------------------------------------------------------------------
// IVsHierarchyDropDataTarget
//----------------------------------------------------------------------------
// Implemented by projects and IVsHierarchy objects that are target of drag/drop operations.
// Interface is retrieved by QI from IVsHierarchy.
[
    uuid(uuid_IVsHierarchyDropDataTarget),
    version(1.0),
    pointer_default(unique)
]
interface IVsHierarchyDropDataTarget:IUnknown
{
    HRESULT DragEnter([in]IDataObject   * pDataObject,
        [in]DWORD grfKeyState,
        [in]VSITEMID itemid,
        [in, out]DWORD * pdwEffect);
    HRESULT DragOver([in]DWORD grfKeyState,
        [in]VSITEMID    itemid,
        [in,    out]DWORD * pdwEffect);
    HRESULT DragLeave(void);
    HRESULT Drop([in]IDataObject * pDataObject,
        [in]DWORD grfKeyState,
        [in]VSITEMID    itemid,
        [in,out]DWORD * pdwEffect);
}

//---------------------------------------------------------------------------
// library
//---------------------------------------------------------------------------

#ifndef VS_PACKAGE_INCLUDE
// allow packages to #include this IDL without a library section
#ifndef INTEROPLIB
[
    uuid(uuid_lib_VsShell),
    version(1.0)
]
library VsShell
{
    importlib("textmgr.tlb");
    cpp_quote("#include \"textmgr.h\"")

    interface IVsPackage;
    interface IVsPersistSolutionOpts;
    interface IVsPersistSolutionProps;
    interface IVsSolutionPersistence;
    interface IVsWindowPane;
    interface IVsUIHierarchyWindow;
#endif // INTEROPLIB

    //----------------------------------------------------------------------------
    // IVsDebuggerEvents
    //----------------------------------------------------------------------------
    // Implemented by clients of DebuggerEvents.
    [
        uuid(uuid_IVsDebuggerEvents),
        version(1.0),
        pointer_default(unique)
    ]
    interface IVsDebuggerEvents: IUnknown
    {
        HRESULT OnModeChange ([in] DBGMODE dbgmodeNew);
    }

    //----------------------------------------------------------------------------
    //  struct VsTextPos
    //----------------------------------------------------------------------------
    struct _VsTextPos {
        IVsHierarchy *pHier;
        VSITEMID itemid;
        IVsTextLines *pTextBuf;
        TextSpan span;
    };
    typedef struct _VsTextPos VsTextPos;

    enum __VSDBGLAUNCHFLAGS 
    {
        DBGLAUNCH_Silent                = 0x00000001, 
        DBGLAUNCH_LocalDeploy           = 0x00000002, // passed to IVsDebuggableProjectCfg::Launch to allow optimizations
        DBGLAUNCH_NoDebug               = 0x00000004, // launch without attaching a debugger
        DBGLAUNCH_DetachOnStop = 0x00000008, // Detach instead of terminate when debugging stopped.
        DBGLAUNCH_Selected              = 0x00000010, // launch selected project instead of startup project
        DBGLAUNCH_StopDebuggingOnEnd = 0x00000020, // When this process ends, debugging is stopped.
        DBGLAUNCH_WaitForAttachComplete = 0x00000040 // When DLO_LaunchByWebServer, wait for the attach to finish before continuing to launch other targets
    };
    typedef DWORD VSDBGLAUNCHFLAGS;

    typedef enum _DEBUG_LAUNCH_OPERATION 
    {
        DLO_AlreadyRunning,  // attach to a process
        //  bstrExe is the process name, or a NULL character followed by 
        //  a string indicating the hexadecimal process id

        DLO_CreateProcess,   // launch the application
        //  bstrExe is the full path to the exe,
        //  bstrArg are the arguments to pass to CreateProcess,
        //  clsidCustom specifies the single debug engine to use (NULL for default),
        //  or dwClsidCount and pclsidList specify the debug engines to use

        DLO_Custom,          // deprecated -- same as DLO_CreateProcess

        DLO_LaunchByWebServer, // Use special HTTP verb to debug
    } DEBUG_LAUNCH_OPERATION;

    typedef struct _VsDebugTargetInfo
    {
        DWORD cbSize;                 // size of the VsDebugTargetInfo struct
        BSTR bstrRemoteMachine;       // NULL for local machine, or remote machine name
        DEBUG_LAUNCH_OPERATION dlo;   // specifies how this process should be launched or attached
        BSTR bstrMdmRegisteredName;   // used with DLO_AlreadyRunning. The name of the app as it is registered with the MDM.                                
        CLSID clsidCustom;            // used with DLO_Custom, wich indicates that the "exe" is not going
                                      // to be launched via CreateProcess, but some other other custom means
                                      // For example, SQL is going to use this
        BSTR bstrExe;                 // The name of the executable
        BSTR bstrArg;                 // command line arguments to the exe. used with DLO_CreateProcess.
        BSTR bstrCurDir;              // current directory
        BSTR bstrEnv;                 // environment settings to pass to CreateProcess,  used with DLO_CreateProcess.
        CLSID clsidPortSupplier;      // port supplier guid
        BSTR bstrPortName;            // name of port from above supplier (NULL is fine)
        BSTR bstrOptions;             // custom options, specific to each clsidCustom (NULL is recommended)
        VSDBGLAUNCHFLAGS grfLaunch;   // launch flags that were passed to IVsDebuggableProjectCfg::Launch        
        HANDLE hStdInput;             // for file redirection
        HANDLE hStdOutput;            // for file redirection
        HANDLE hStdError;             // for file redirection

        // for multiple-engine launch
        // most users can use clsidCustom instead and leave these as zero
        DWORD dwClsidCount;           // number of guids in the array
        CLSID *pClsidList;            // array of guids, or NULL is if dwClsidCount is zero

        BOOL fSendStdoutToOutputWindow;  // if TRUE, then stdout and stderr will be routed to the debug-output window
    } VsDebugTargetInfo;

    //----------------------------------------------------------------------------
    // IVsDebugLaunch
    //----------------------------------------------------------------------------
    // Implemented by host applications which do not use IVsSolutionBuildManager.
    // Used by the Debugger.
    [
        uuid(uuid_IVsDebugLaunch),
        version(1.0),
        pointer_default(unique)
    ]
    interface IVsDebugLaunch  : IUnknown
    {
        HRESULT DebugLaunch([in] VSDBGLAUNCHFLAGS grfLaunch);
        HRESULT QueryDebugLaunch([in] VSDBGLAUNCHFLAGS grfLaunch, [out] BOOL *pfCanLaunch);
    }
    cpp_quote("#define SID_SVsDebugLaunch IID_IVsDebugLaunch")

    //----------------------------------------------------------------------------
    // IVsDebugger
    //----------------------------------------------------------------------------
    // Implemented by the Debugger.
    // Used by project implementations that particpate in DebugLaunch.
    [
        uuid(uuid_IVsDebugger),
        version(1.0),
        pointer_default(unique)
    ]
    interface IVsDebugger: IUnknown
    {
        // If pitemid is VSITEMID_SELECTION, then the selection is retrieved
        // via the IVsMultiSelectItem object.
        HRESULT GetMode ([out] DBGMODE *pdbgmode);

        HRESULT AdviseDebuggerEvents([in]  IVsDebuggerEvents *psink,
            [out] VSCOOKIE  *pdwCookie);

        HRESULT UnadviseDebuggerEvents([in] VSCOOKIE dwCookie);

        HRESULT GetDataTipValue ([in] IVsTextLines *pTextBuf,
            [in] const  TextSpan *pTS,
            [in] WCHAR  *pszExpression,
            [out] BSTR  *pbstrValue);

        HRESULT QueryStatusForTextPos ([in] VsTextPos *pTextPos,
            [unique][in]    const GUID *pguidCmdGroup,
            [in]     ULONG cCmds,
            [out][in][size_is (cCmds)] OLECMD prgCmds[ ],
            [unique][out][in] OLECMDTEXT    *pCmdText);

        HRESULT ExecCmdForTextPos ([in] VsTextPos *pTextPos,
            [unique][in]    const GUID *pguidCmdGroup,
            [in]    DWORD nCmdID,
            [in]    DWORD nCmdexecopt,
            [unique][in]    VARIANT *pvaIn,
            [unique][out][in] VARIANT *pvaOut);

        // following two APIs are for SQL to let them hook into our IDebugEventCallback2
        HRESULT AdviseDebugEventCallback([in]IUnknown *punkDebuggerEvents);
        HRESULT UnadviseDebugEventCallback([in]IUnknown *punkDebuggerEvents);

        HRESULT LaunchDebugTargets([in] ULONG cTargets, [in, out, size_is(cTargets)] VsDebugTargetInfo *rgDebugTargetInfo);

        HRESULT InsertBreakpointByName([in] REFGUID guidLanguage,
            [in]    LPCOLESTR pszCodeLocationText);

        HRESULT RemoveBreakpointsByName([in] REFGUID guidLanguage,
            [in] LPCOLESTR pszCodeLocationText);

        HRESULT ToggleBreakpointByName([in] REFGUID guidLanguage,
            [in]    LPCOLESTR pszCodeLocationText);

        HRESULT IsBreakpointOnName([in] REFGUID guidLanguage,
            [in]    LPCOLESTR pszCodeLocationText,
            [out] BOOL* pfIsBreakpoint);
        // pbstrArgsProcessed will contain the args string with all the redirection stuff stripped off
        HRESULT ParseFileRedirection([in] LPOLESTR pszArgs, [out] BSTR *pbstrArgsProcessed, [out] HANDLE *phStdInput, [out] HANDLE *phStdOutput, [out] HANDLE *phStdError);

        HRESULT GetENCUpdate([out] IUnknown** ppUpdate);

        // Whether the user wants files to be read-only while 
        // debuggging.  Based on a checkbox in Tools.Options.Debugging, which
        // only exposes this for C# and VB
        //
        // S_OK if allowed, S_FALSE if not
        HRESULT AllowEditsWhileDebugging (REFGUID guidLanguageService);

    }
    cpp_quote("#define SID_SVsShellDebugger IID_IVsDebugger")

    //----------------------------------------------------------------------------
    //  interface IVsDebuggableProtocol
    //----------------------------------------------------------------------------
    //      WHO: implemented by packages that implement debugging services (e.g. vsdebug)
    //      CALLED BY: packages that implement protocols that should be debuggable
    //                 by shell debugging services
    //      FORMAT: all inputs should be a protocol name followed by a : (i.e. last
    //              char must be a colon)
    cpp_quote("#define SID_SVsDebuggableProtocol IID_IVsDebuggableProtocol")

    // ------------------------------------------------------------------
    // IVsDebuggableProtocol - allows clients to add to debuggable protocol list
    [
        object,
        uuid(ca647009-a436-4d08-ba0f-9027a97a818b),
        pointer_default(unique)
    ]
    interface IVsDebuggableProtocol : IUnknown
    {
        // adds a protocol to the debuggable protocol list.  
        // implementations will typically check the list to avoid a double-add
        // returns S_OK if add is successful, returns S_FALSE if add is unsuccessful
        HRESULT AddDebuggableProtocol(
            [in] LPOLESTR bstrProtocol);

        // removes the indicated protocol from the list
        // returns S_OK if removal is successful, returns S_FALSE if removal is
        // unsuccessful (e.g. if the protocol is not in the list)
        HRESULT RemoveDebuggableProtocol(
            [in] LPOLESTR bstrProtocol);

        // returns S_OK if protocol is in the list
        // returns S_FALSE if protocol is not in the list
        // the [in] arg can be a full URL, the method will return S_OK if the
        // URL starts with a protocol that is in the list
        HRESULT IsProtocolDebuggable(
            [in] LPOLESTR bstrProtocol);
    };

    //----------------------------------------------------------------------------
    //  SID_SVsLaunchPad
    //----------------------------------------------------------------------------
    // Implemented by the Environment.
    // Interface retrieved by IVsLaunchPadFactory::CreateLaunchPad.
    // This service is used to launch a console app.  It is useful when a project 
    // needs to spawn command line tools and batch files as part of its build process.
    typedef enum
    {
        LPF_PipeStdoutToOutputWindow = 0x1,
        LPF_PipeStdoutToTaskList     = 0x2,
        LPF_ClearOutputWindow        = 0x4,  // clears the specified pane of the output window before spawning the tool
        LPF_PauseAfterExecution      = 0x8,  // wait for keypress to close process spawned in external command window
    } _LAUNCHPAD_FLAGS;
    typedef DWORD LAUNCHPAD_FLAGS;

    [
        uuid(uuid_IVsLaunchPad),
        version(1.0),
        pointer_default(unique)
    ]
    interface IVsLaunchPad: IUnknown
    {
        HRESULT ExecCommand(
            [in] LPCOLESTR pszApplicationName, // passed on to CreateProcess (see Win32 API for details)
            [in] LPCOLESTR pszCommandLine,     // passed on to CreateProcess (see Win32 API for details)
            [in] LPCOLESTR pszWorkingDir,      // may be NULL, passed on to CreateProcess (wee Win32 API for details)
            [in] LAUNCHPAD_FLAGS lpf,
            [in] IVsOutputWindowPane *pOutputWindowPane, // if LPF_PipeStdoutToOutputWindow, which pane in the output window should the output be piped to
            [in] ULONG nTaskItemCategory,           // if LPF_PipeStdoutToTaskList is specified
            [in] ULONG nTaskItemBitmap,             // if LPF_PipeStdoutToTaskList is specified
            [in] LPCOLESTR pszTaskListSubcategory,  // if LPF_PipeStdoutToTaskList is specified
            [in] IVsLaunchPadEvents *pVsLaunchPadEvents,
            [out] DWORD *pdwProcessExitCode,    // value return by process
            [out] BSTR *pbstrOutput);     // all output generated (may be NULL)

        HRESULT ExecBatchScript(
            [in] LPCOLESTR pszBatchFileContents,
            [in] LPCOLESTR pszWorkingDir,           // may be NULL, passed on to CreateProcess (wee Win32 API for details)
            [in] LAUNCHPAD_FLAGS lpf,
            [in] IVsOutputWindowPane *pOutputWindowPane, // if LPF_PipeStdoutToOutputWindow, which pane in the output window should the output be piped to
            [in] ULONG nTaskItemCategory,           // if LPF_PipeStdoutToTaskList is specified
            [in] ULONG nTaskItemBitmap,             // if LPF_PipeStdoutToTaskList is specified
            [in] LPCOLESTR pszTaskListSubcategory,  // if LPF_PipeStdoutToTaskList is specified
            [in] IVsLaunchPadEvents *pVsLaunchPadEvents,
            [out] BSTR *pbstrOutput);               // all output generated (may be NULL)

        HRESULT ParseOutputStringForTaskItem(
            [in] LPCOLESTR pszOutputString,         // one line of output text
            [out] ULONG *pnPriority,                // all output params (may be NULL)
            [out] BSTR *pbstrFilename,
            [out] ULONG *pnLineNum,
            [out] BSTR *pbstrTaskItemText,
            [out] BOOL *pfTaskItemFound);

    }
    // NOTE: only Query for this service if you are calling from the Main UI Thread!!!!
    // On other threads use IVsLaunchPadFactory::CreateLaunchPad.
    cpp_quote("#define SID_SVsLaunchPad IID_IVsLaunchPad")

    [
        uuid(uuid_IVsLaunchPadEvents),
        version(1.0),
        pointer_default(unique)
    ]
    interface IVsLaunchPadEvents: IUnknown
    {
        HRESULT Tick(
            [in, out] BOOL *pfCancel);
    };

    //----------------------------------------------------------------------------
    //  IVsLaunchPadFactory
    //----------------------------------------------------------------------------
    // Implemented by the Environment.
    // This service is used to create an IVsLaunchPad that can be called from a background thread. 
    // This is useful when a project needs to spawn command line tools and batch files as part of 
    // its build process.
    [
        uuid(uuid_IVsLaunchPadFactory),
        version(1.0),
        pointer_default(unique)
    ]
    interface IVsLaunchPadFactory : IUnknown
    {
        // This method creates an IVsLaunchPad object that can be used to spawn command line tools and batch files.
        // The LaunchPad object handles the chores of piping output to the output window and of allowing the user to 
        // cancel. If the user cancels, it kills the spawned process. Some project systems will use this functionality to 
        // implement IVsBuildableProjectCfg::Build. It is specifically possible to create a LaunchPad object on a 
        // background builder thread. In order to do this, the project system should QueryService for the 
        // SVsLaunchPadFactory service from the main UI thread. It should pass the IVsLaunchPadFactory interface 
        // unmarshalled to their builder thread and then call pVsLaunchPadFactory->CreateLaunchPad from the 
        // builder thread in order to create the LaunchPad object on the builder thread. 
        // NOTE: this does slightly bend the marshalling rules of COM but is necessary to get the LaunchPad object 
        // created on the proper thread. The IVsLaunchPad object returned is an Apartment Model object.
        HRESULT CreateLaunchPad([out] IVsLaunchPad **ppLaunchPad);
    }

    cpp_quote("#define SID_SVsLaunchPadFactory IID_IVsLaunchPadFactory")

    //----------------------------------------------------------------------------
    // IVsTextBufferProvider
    //----------------------------------------------------------------------------
    // Implemented by special DocData objects that delegate to an implementation 
    // of a TextBuffer (IVsTextLines). Clients of a DocData object that want 
    // to get a pointer to IVsTextLines should first QI directly on the DocData for 
    // IVsTextLines. If that fails then they should QI for IVsTextBufferProvider and
    // call GetTextBuffer.
    [
        uuid(uuid_IVsTextBufferProvider),
        version(1.0),
        pointer_default(unique)
    ]
    interface IVsTextBufferProvider : IUnknown
    {
        HRESULT GetTextBuffer ([out] IVsTextLines **ppTextBuffer);
        HRESULT SetTextBuffer ([in] IVsTextLines *pTextBuffer);
        HRESULT LockTextBuffer ([in] BOOL fLock);
    }
#ifndef INTEROPLIB
}
#endif // INTEROPLIB
#endif //VS_PACKAGE_INCLUDE

//----------------------------------------------------------------------------
// IVsToolboxDataProvider
//----------------------------------------------------------------------------
// Implemented by VsPackages that want to provide special tool box items for 
// clipboard IDataObjects in the Clipboard Ring as well as for files dragged 
// from the WindowsExplorer to the Toolbox.
// Interface passed to the Environment via IVsToolbox::RegisterDataProvider.
enum __TBXITEMINFOFLAGS
{
    TBXIF_DELETEBITMAP = 0x00000001, // Toolbox deletes bitmap
    TBXIF_DONTPERSIST    = 0x00000002, // Item is not persisted
    TBXIF_CANTREMOVE     = 0x00000004, // User cannot remove item
    TBXIF_IMAGEINDEX     = 0x00000008  // TBXITEMINFO iImageIndex and iImageWidth are valid
};
typedef DWORD TBXITEMINFOFLAGS;

// Stuct used on IVsToolbox::AddItem() and IVsToolboxDataProvider::GetItemInfo()
// NOTE: hBmp is placed in an ImageList, so caller can destroy on return, or have
//       toolbox delete it via TBXIF_DELETEBITMAP
typedef struct tagTBXITEMINFO
{
    BSTR             bstrText;      // Tool tips/label text of toolbox item
    HBITMAP          hBmp;          // 16x16 bitmap for toolbox
    COLORREF         clrTransparent;// Transparent color in bitmap
    TBXITEMINFOFLAGS dwFlags;       // TBXITEMINFOFLAGS
    INT              iImageIndex;   // Valid only if TBXIF_IMAGEINDEX provided
    INT              iImageWidth;   // Valid only if TBXIF_IMAGEINDEX provided
    // NOTE: If TBXIF_IMAGEINDEX is given, hBmp
    //      is an image strip. iImageIndex is a zero
    //      based index into this bitmap whose images
    //      have a width of iImageWidth.
} TBXITEMINFO, *PTBXITEMINFO;

[
    uuid(uuid_IVsToolboxDataProvider),
    version(1.0),
    pointer_default(unique)
]
interface IVsToolboxDataProvider : IUnknown
{
    HRESULT FileDropped     ([in]LPCOLESTR pszFileName,
        [in]IVsHierarchy *pHierSource,  // May be NULL
        [out,retval]BOOL *pfFileProcessed);
    [custom(uuid_IVsToolboxDataProvider, "preservesig")]
    HRESULT IsSupported     ([in]IDataObject* pDO);
    [custom(uuid_IVsToolboxDataProvider, "preservesig")]
    HRESULT IsDataSupported ([in]FORMATETC* pfetc, [in]STGMEDIUM* pstm);
    HRESULT GetItemInfo     ([in]IDataObject* pDO, [out]PTBXITEMINFO ptif);
}

cpp_quote("extern const __declspec(selectany) GUID SID_SVsToolboxActiveXDataProvider = {0x35222106, 0xbb44, 0x11d0, 0x8c, 0x46, 0x0, 0xc0, 0x4f, 0xc2, 0xaa, 0xe2};")

//----------------------------------------------------------------------------
// IVsToolboxUser
//----------------------------------------------------------------------------
// Implemented by editors and projects that want to control what is enabled on the toolbox.
// Editors also handle the DBLCLK of a toolbox item through ItemPicked.
// Normally this interface is implemented on the VSFPROPID_DocView or VSFPROPID_ViewHelper 
// object associated with a window that uses the toolbox. Also the project (or parent projects)
// that own the editor window are called to see if they want to filter out any toolbox
// items based on the context of the project. In this case the interface is retrieved
// by QI from the IVsHierarchy object or its VSHPROPID_ParentHierarchy.
[
    uuid(uuid_IVsToolboxUser),
    version(1.0),
    pointer_default(unique)
]
interface IVsToolboxUser : IUnknown
{
    [custom(uuid_IVsToolboxUser, "preservesig")]
    HRESULT IsSupported ([in]IDataObject* pDO);

    [custom(uuid_IVsToolboxUser, "preservesig")]
    HRESULT ItemPicked  ([in]IDataObject* pDO);
}

//----------------------------------------------------------------------------
// IEnumToolboxItems
//----------------------------------------------------------------------------
// Implemented by the Environment.
[
    uuid(uuid_IEnumToolboxItems),
    version(1.0),
    pointer_default(unique)
]
interface IEnumToolboxItems : IUnknown
{
    HRESULT Next([in]   ULONG celt, [out, size_is(celt), length_is(*pceltFetched)] IDataObject **rgelt, [out] ULONG *pceltFetched);
    HRESULT Skip([in]   ULONG celt);
    HRESULT Reset(void);
    HRESULT Clone([out] IEnumToolboxItems   **ppenum);
}

//----------------------------------------------------------------------------
// IEnumToolboxTabs
//----------------------------------------------------------------------------
// Implemented by the Environment.
[
    uuid(uuid_IEnumToolboxTabs),
    version(1.0),
    pointer_default(unique)
]
interface IEnumToolboxTabs : IUnknown
{
    HRESULT Next([in]   ULONG celt, [out, size_is(celt), length_is(*pceltFetched)] BSTR *rgelt, [out] ULONG *pceltFetched);
    HRESULT Skip([in]   ULONG celt);
    HRESULT Reset(void);
    HRESULT Clone([out] IEnumToolboxTabs **ppenum);
}

typedef enum __VSTBXTABVIEW
{
    TBXTV_ListView = 0,
    TBXTV_IconView = 1,
} VSTBXTABVIEW;

//----------------------------------------------------------------------------
// IVsToolbox[2]
//----------------------------------------------------------------------------
// Implemented by the Environment on the Toolbox tool window.
// Used by packages that make use of the toolbox.
[
    uuid(uuid_IVsToolbox),
    version(1.0),
    pointer_default(unique)
]
interface IVsToolbox : IUnknown
{
    [custom(uuid_IVsToolbox, "preservesig")]
    HRESULT SetCursor   (void);
    HRESULT GetData     ([out, retval]IDataObject** ppDO);
    HRESULT DataUsed    (void);
    HRESULT GetFrame    ([out, retval]IVsWindowFrame** ppWindowFrame);
    HRESULT AddItem     ([in]IDataObject* pDO, [in]PTBXITEMINFO ptif, [in]LPCOLESTR lpszTab);
    HRESULT RemoveItem  ([in]IDataObject* pDO);
    HRESULT RegisterDataProvider  ([in]IVsToolboxDataProvider* pDP, [out, retval]VSCOOKIE* pdwProvider);
    HRESULT UnregisterDataProvider([in]VSCOOKIE dwProvider);
    HRESULT GetTab      ([out, retval]BSTR* pbstrTab);
    HRESULT AddTab      ([in]LPCOLESTR lpszTab);
    HRESULT RemoveTab   ([in]LPCOLESTR lpszTab);
    HRESULT SelectTab   ([in]LPCOLESTR lpszTab);
    HRESULT EnumTabs    ([out, retval]IEnumToolboxTabs** pEnum);
    HRESULT SelectItem  ([in]IDataObject* pDO);
    HRESULT EnumItems   ([in]LPCOLESTR lpszTab, [out]IEnumToolboxItems** pEnum);
    HRESULT SetItemInfo ([in]IDataObject* pDO, [in]PTBXITEMINFO ptif);
    HRESULT AddActiveXItem([in]REFCLSID clsid, [in]LPCOLESTR lpszTab, [in]IVsHierarchy *pHierarchy); //pHierarchy is NYI
    HRESULT UpdateToolboxUI(void);
    HRESULT AddItemFromFile([in]LPCOLESTR pszFilename,
        [in]IVsHierarchy *pHierSource, // May be NULL
        [out,retval]BOOL *pfItemAdded);
    HRESULT IsCurrentUser(IVsToolboxUser *pUser, [out,retval] BOOL *pfCurrent);
    HRESULT AddTabEx    ([in]LPCOLESTR lpszTab, [in]VSTBXTABVIEW tv);
    HRESULT SetTabView  ([in]LPCOLESTR lpszTab, [in]VSTBXTABVIEW tv);
    HRESULT GetTabView  ([in]LPCOLESTR lpszTab, [out,retval]VSTBXTABVIEW *ptv);
};

cpp_quote("#define SID_SVsToolbox IID_IVsToolbox")

[
    uuid(uuid_IVsToolbox2),
    version(1.0),
    pointer_default(unique)
]
interface IVsToolbox2 : IVsToolbox
{
    HRESULT AddItem2        ([in]IDataObject* pDO, [in]PTBXITEMINFO ptif, [in]LPCOLESTR lpszTab, [in]REFGUID guidPkg);
    HRESULT AddTab2     ([in]LPCOLESTR lpszTab, [in]REFGUID guidPkg);
    HRESULT AddActiveXItem2([in]REFCLSID clsid, [in]LPCOLESTR lpszTab, [in]IVsHierarchy *pHierarchy, [in]REFGUID guidPkg); //pHierarchy is NYI
    HRESULT AddItemFromFile2([in]LPCOLESTR pszFilename,
        [in]IVsHierarchy *pHierSource, // May be NULL
        [in]REFGUID guidPkg,
        [out,retval]BOOL *pfItemAdded);
    HRESULT AddTabEx2   ([in]LPCOLESTR lpszTab, [in]VSTBXTABVIEW tv, [in]REFGUID guidPkg);
};

//----------------------------------------------------------------------------
// IVsToolboxClipboardCycler
//----------------------------------------------------------------------------
// Implemented by the Environment.
// Interface retrieved by QueryService(SID_SVsToolbox, IID_IVsToolboxClipboardCycler,...).
// Used by editors that participate with the Clipboard Ring by handling the 
// CLSID_StandardCommandSet97/cmdidPasteNextTBXCBItem command.
[
    uuid(uuid_IVsToolboxClipboardCycler),
    version(1.0),
    pointer_default(unique)
]
interface IVsToolboxClipboardCycler : IUnknown
{
    /*
    In both these methods the IVsToolboxUser param is used by the toolbox to ensure that
    the next item is supported.
    */
    HRESULT AreDataObjectsAvailable([in] IVsToolboxUser *pTarget, [out] BOOL *pbItemsAvailable); // whether any items are available to preview
    HRESULT GetAndSelectNextDataObject([in] IVsToolboxUser *pTarget, [out] IDataObject **ppDO);
    HRESULT BeginCycle(void); // (fast) Next GetAndSelectNextDataObject call gets the first (current) object
};

//----------------------------------------------------------------------------
// IVsStatusbarUser
//----------------------------------------------------------------------------
// Implemented by objects sited in IVsWindowFrame that want to display information
// in the Statusbar. 
// This interface is retrieved by QI on the VSFPROPID_ViewHelper or VSFPROPID_DocView 
// object in a WindowFrame that uses the statusbar.The Environment watches for window 
// activations and automatically calls IVsStatusbarUser::SetInfo.
[
    uuid(uuid_IVsStatusbarUser),
    version(1.0),
    pointer_default(unique)
]
interface IVsStatusbarUser : IUnknown
{
    HRESULT SetInfo(void);  // Document that uses the statusbar was activated
}

//----------------------------------------------------------------------------
// IVsStatusbar
//----------------------------------------------------------------------------
#ifdef INTEROPLIB

typedef enum _STATUSBARCONSTS
{
    SBAI_MIN = 0,
    SBAI_Gen = 0,
    SBAI_Pri = 1,
    SBAI_Sav = 2,
    SBAI_Dep = 3,
    SBAI_Syn = 4,
    SBAI_Bui = 5,
    SBAI_Fin = 6,
    SBAI_MAX = 6

} STATUSBARCONSTS;

#endif

// Implemented by the Environment.
cpp_quote("#define SBAI_MIN     0")
// SBAI_MIN must equal first Animation Icon index and MUST be zero
cpp_quote("#define SBAI_General 0")
cpp_quote("#define SBAI_Print   1")
cpp_quote("#define SBAI_Save    2")
cpp_quote("#define SBAI_Deploy  3")
cpp_quote("#define SBAI_Synch   4")
cpp_quote("#define SBAI_Build   5")
cpp_quote("#define SBAI_Find    6")
// SBAI_MAX must equal last Animation Icon index
cpp_quote("#define SBAI_MAX     6")

[
    uuid(uuid_IVsStatusbar),
    version(1.0),
    pointer_default(unique)
]
interface IVsStatusbar : IUnknown
{
    HRESULT Clear (void);   // Clears everything but Progressbar and Icon

    HRESULT SetText  ([in]LPCOLESTR pszText);       // Basic statusbar text

    HRESULT Progress ([in,out]VSCOOKIE *pdwCookie,      // Determines current user, to prevent multiple users
        //  NOTE: User must initialize to ZERO on first call
        [in]BOOL         fInProgress,   // TRUE while using, FALSE when complete
        [in]LPCOLESTR    pwszLabel,     // Text to display in status field while using
        [in]ULONG        nComplete,     // Current position
        [in]ULONG        nTotal);       // Max value

    HRESULT Animation([in]BOOL     fOnOff,  // Ref count for: TRUE turn on, FALSE turn off
        [in]VARIANT *pvIcon);   // VT_I2: SBAI_Index of predefined animated Icons, SBAI_index
    // VT_I4: HBITMAP containing filmstrip image for animation
    //        width should be multiple of height.  Frame size is then
    //        height x height.  Displayed at 5 frames/se
    //        Caller responsible for destroying bitmap
    // NOTE: Index/HBITMAP MUST be passed in on both On and Off

    // - VARIANT must be VT_I4 or VT_BSTR
    // - See v6\inc\stdiduie.h for valid VT_I4 values
    HRESULT SetSelMode  ([in]VARIANT *pvSelMode);
    HRESULT SetInsMode  ([in]VARIANT *pvInsMode);

    // - Pass in NULL to leave value unchanged
    // - VARIANT must be VT_I2, VT_I4, VT_BSTR, or VT_EMPTY
    // - If VT_I2 or VT_I4, the number is formatted into: Ln ##, Ch ##
    // - If VT_BSTR, the text is displayed as is with nor formatting: Text Text
    // - If VT_EMPTY, that field is not displayed at all
    HRESULT SetLineChar ([in]VARIANT *pvLine, [in]VARIANT *pvChar);

    // - Pass in NULL to ingnore parameter
    // - VARIANT must be VT_I2, VT_I4, VT_R4, or VT_R8
    HRESULT SetXYWH ([in]VARIANT *pvX, [in]VARIANT *pvY, [in]VARIANT *pvW, [in]VARIANT *pvH);           

    // - Pass in NULL to leave value unchanged
    // - VARIANT must be VT_I2, VT_I4, VT_BSTR, or VT_EMPTY
    // - If VT_I2 or VT_I4, the number is formatted into: Ln ##, Ch ##
    // - If VT_BSTR, the text is displayed as is with nor formatting: Text Text
    // - If VT_EMPTY, that field is not displayed at all
    HRESULT SetLineColChar([in]VARIANT *pvLine, [in]VARIANT *pvCol, [in]VARIANT *pvChar);

    HRESULT IsCurrentUser(IVsStatusbarUser *pUser, BOOL *pfCurrent);

    // Same as SetText, but sets text to the specified RGB foreground and background colors.
    // Standard highlight is:
    //  pSB->SetColorText(psz, GetSysColor(COLOR_HIGHLIGHTTEXT), GetSysColor(COLOR_HIGHLIGHT));
    // Default text is:
    //  pSB->
    HRESULT SetColorText([in]LPCOLESTR pszText, [in] COLORREF crForeColor, [in] COLORREF crBackColor);

    HRESULT GetText([out]BSTR   *pszText);

    HRESULT FreezeOutput([in]   BOOL fFreeze);
    HRESULT IsFrozen([out] BOOL *pfFrozen);
    HRESULT GetFreezeCount([out] long   *plCount);
};

cpp_quote("#define SID_SVsStatusbar IID_IVsStatusbar")

//----------------------------------------------------------------------------
//  enum __VSOUTLINESTATE
//
//      Document outline state values
//----------------------------------------------------------------------------
enum __VSOUTLINESTATE
{
    OUTLINE_DETACHED    = 0x00000001,   // outline detached from document window
    OUTLINE_VISIBLE = 0x00000002,   // outline visible when not detached
};
typedef DWORD VSOUTLINESTATES;

//----------------------------------------------------------------------------
//  enum __VSOUTLINECAPTION
//
//      Document outline caption types
//----------------------------------------------------------------------------
typedef enum __VSOUTLINECAPTION
{
    OUTLINECAPTION_SIMPLE   = 0,    // name of outline view
    OUTLINECAPTION_FULL = 1,    // name of outline view - document name
} VSOUTLINECAPTION;

//----------------------------------------------------------------------------
// IVsDocOutlineProvider
//----------------------------------------------------------------------------
// This interface is implemented by object sited in a document window that wants 
// to supply content to the "Document Outline" tool window.
// This interface is retrieved by QI on the VSFPROPID_ViewHelper or VSFPROPID_DocView 
// object in a WindowFrame.
[
    uuid(uuid_IVsDocOutlineProvider),
    version(1.0),
    pointer_default(unique)
]
interface IVsDocOutlineProvider : IUnknown
{
    HRESULT GetOutlineCaption([in] VSOUTLINECAPTION nCaptionType, [out] BSTR* pbstrCaption);
    HRESULT GetOutline([out] HWND* phwnd, [out] IOleCommandTarget** ppCmdTarget);
    HRESULT ReleaseOutline([in] HWND hwnd, [in] IOleCommandTarget* pCmdTarget);
    HRESULT OnOutlineStateChange([in] VSOUTLINESTATES dwMask, [in] VSOUTLINESTATES dwState);
};

cpp_quote("DEFINE_GUID(CLSID_VsDocOutlinePackage, 0x21af45b0, 0xffa5, 0x11d0, 0xb6, 0x3f, 0x00, 0xa0, 0xc9, 0x22, 0xe8, 0x51);")


//----------------------------------------------------------------------------
// IVsComponentSelectorProvider
//----------------------------------------------------------------------------
// Implemented by VsPackages that provide pages to the ComponentPicker dialog.
// Interface retrieved by QI on IVsPackage object.
[
    uuid(uuid_IVsComponentSelectorProvider),
    version(1.0),
    pointer_default(unique)
]
interface IVsComponentSelectorProvider : IUnknown
{
    HRESULT GetComponentSelectorPage([in]   REFGUID rguidPage,
        [in,    out] VSPROPSHEETPAGE *pPage);
}

//----------------------------------------------------------------------------
// IVsComponentUser
//----------------------------------------------------------------------------
// Implemented by clients that use the ComponentPicker dialog. This is the callback
// interface that the dialog calls on the client when an item is picked.
// This interface is passed to IVsComponentSelectorDlg::ComponentSelectorDlg.
typedef enum __VSADDCOMPOPERATION
{
    VSADDCOMPOP_ADD         = 1,    // simplest case
} VSADDCOMPOPERATION;

typedef enum __VSADDCOMPRESULT
{
    ADDCOMPRESULT_Success     = -1, // add succeeded, close the dialog
    ADDCOMPRESULT_Failure     = 0,  // add failed, do not close the dialog
    ADDCOMPRESULT_Cancel      = 1,  // user canceled, close the dialog
} VSADDCOMPRESULT;

typedef enum __VSCOMPONENTTYPE
{
    VSCOMPONENTTYPE_File = 0,
    VSCOMPONENTTYPE_ComPlus =   1,
    VSCOMPONENTTYPE_Com2 = 2,
    VSCOMPONENTTYPE_Project =   3,
    VSCOMPONENTTYPE_Custom = 4,
    VSCOMPONENTTYPE_Path = 5,
} VSCOMPONENTTYPE;

typedef struct _VSCOMPONENTSELECTORDATA
{
    DWORD      dwSize;           // size of structure (for forward compatibility)

    // Common   component info
    VSCOMPONENTTYPE type;         // type of component from type enumeration
    BSTR      bstrTitle;          // human-readable name of component (not identity info)

    // File info
    // VSCOMPONENTTYPE_File :   full path to the file
    // VSCOMPONENTTYPE_ComPlus : full   path to the assembly
    // VSCOMPONENTTYPE_Com2 :   full path to the typelib    
    BSTR      bstrFile;               // full path to component file
    WORD      wFileMajorVersion;      // win32 major version number of file   (7.         ) (optional)
    WORD      wFileMinorVersion;      // win32 minor version number of file   (  10.      ) (optional)
    WORD      wFileRevisionNumber;    // win32 build revision number of file  (     1234. ) (optional)
    WORD      wFileBuildNumber;       // win32 build number of file           (          2) (optional)

    // Typelib info used for type   VSCOMPONENTTYPE_Com2
    GUID      guidTypeLibrary;            // type library GUID (optional)
    WORD      wTypeLibraryMajorVersion;   // typelib major version (optional)
    WORD      wTypeLibraryMinorVersion;   // typelib minor version (optional)
    LCID      lcidTypeLibrary;            // typelib locale (optional)

    // VSCOMPONENTTYPE_Project
    BSTR      bstrProjRef;        // IVsSolution::GetProjrefOfProject

    // VSCOMPONENTTYPE_Custom
    LPARAM  lCustom;              // Custom data
} VSCOMPONENTSELECTORDATA, *PVSCOMPONENTSELECTORDATA;

cpp_quote("#define CleanupComponentDataStrings(pComponentData) { \\")
cpp_quote("  if (pComponentData != NULL) { \\")
cpp_quote("  if ((pComponentData)->bstrTitle)         ::SysFreeString((pComponentData)->bstrTitle); \\")
cpp_quote("  if ((pComponentData)->bstrFile)          ::SysFreeString((pComponentData)->bstrFile); \\")
cpp_quote("  if ((pComponentData)->bstrProjRef)       ::SysFreeString((pComponentData)->bstrProjRef); } }")

[
    uuid(uuid_IVsComponentUser),
    version(1.0),
    pointer_default(unique)
]
interface IVsComponentUser : IUnknown
{
    // AddComponent is called   back from IVsComponentSelectorDlg::ComponentSelectorDlg.
    // The AddComponent method of   the IVsComponentUser interface provided in the call to IVsComponentSelectorDlg::ComponentSelectorDlg
    // will be invoked when the component   selector dialog is dismissed.  The contents of pResult determine whether the dialog closes.
    HRESULT AddComponent([in]   VSADDCOMPOPERATION dwAddCompOperation,
        [in]    ULONG cComponents,
        [in,    size_is(cComponents)] PVSCOMPONENTSELECTORDATA rgpcsdComponents[],
        [in]    HWND hwndPickerDlg,
        [out, retval] VSADDCOMPRESULT *pResult);
}

//---------------------------------------------------------------------------
// interface IVsComponentSelectorDlg
//---------------------------------------------------------------------------
// Implemented by the Environment as re-useable ComponentPicker dialog.
// Used most often by projects that manage project references to components of
// various types.

// notifications sent from page dialogs to Component Selector dialog
cpp_quote("#define CPDN_SELCHANGED        (WM_USER + 1280) // inform of selection change on page")
cpp_quote("                                                // wParam is unused, lParam == HWND hwndPageDialog")
cpp_quote("#define CPDN_SELDBLCLICK       (WM_USER + 1281) // inform of doubld-click on selected item on page")
cpp_quote("                                                // wParam is unused, lParam == HWND hwndPageDialog")

// messages sent from Component Selector dialog to page dialogs
cpp_quote("#define CPPM_INITIALIZELIST    (WM_USER + 1285) // initialize list of available components")
cpp_quote("                                                // wParam is unused, lParam is unused")
cpp_quote("#define CPPM_QUERYCANSELECT    (WM_USER + 1286) // determine whether Select button should be enabled")
cpp_quote("                                                // wParam is unused, lParam == BOOL *pbCanSelect")
cpp_quote("#define CPPM_GETSELECTION      (WM_USER + 1287) // retrieve information about selection")
cpp_quote("                                                // wParam == int *pnComponents, lParam == VSCOMPONENTSELECTORDATA ***pppComponents")
cpp_quote("#define CPPM_INITIALIZETAB     (WM_USER + 1288) // initialize tab with VARIANT in VSCOMPONENTSELECTORTABINIT")
cpp_quote("                                                // wParam is unused, lParam == VARIANT varTabInitInfo")
cpp_quote("#define CPPM_SETMULTISELECT    (WM_USER + 1289) // set multiple-selection mode for picker")
cpp_quote("                                                // wParam is unused, lParam == BOOL fMultipleSelect")
cpp_quote("#define CPPM_CLEARSELECTION    (WM_USER + 1290) // reset and clear selection in list of available components")
cpp_quote("                                                // wParam is unused, lParam is unused")

// Component Selector page GUIDs
// GUID_COMPlusPage --    {9A341D95-5A64-11d3-BFF9-00C04F990235}
cpp_quote("DEFINE_GUID(GUID_COMPlusPage,    0x9a341d95, 0x5a64, 0x11d3, 0xbf, 0xf9, 0x00, 0xc0, 0x4f, 0x99, 0x02, 0x35);")
// GUID_COMClassicPage -- {9A341D96-5A64-11d3-BFF9-00C04F990235}
cpp_quote("DEFINE_GUID(GUID_COMClassicPage, 0x9a341d96, 0x5a64, 0x11d3, 0xbf, 0xf9, 0x00, 0xc0, 0x4f, 0x99, 0x02, 0x35);")
// GUID_SolutionPage --   {9A341D97-5A64-11d3-BFF9-00C04F990235}
cpp_quote("DEFINE_GUID(GUID_SolutionPage,   0x9a341d97, 0x5a64, 0x11d3, 0xbf, 0xf9, 0x00, 0xc0, 0x4f, 0x99, 0x02, 0x35);")

enum __VSCOMPSELFLAGS
{
    VSCOMSEL_MultiSelectMode        = 0x00000001,  // allow selection of multiple components
    VSCOMSEL_ShowOnlySpecifiedTab   = 0x00000002,  // show only tab specified by rguidShowOnlyThisTab
    VSCOMSEL_HideCOMPlusTab     = 0x00000004,  // don't show the 'COM+' tab provided by environment
    VSCOMSEL_HideCOMClassicTab  = 0x00000008,  // don't show the 'COM Classic' tab provided by environment
    VSCOMSEL_HideSolutionTab        = 0x00000010,  // don't show the 'Solution' tab provided by environment
    VSCOMSEL_HideBrowseButton       = 0x00000020,  // don't show the 'Browse...' button on the dialog
    VSCOMSEL_IgnoreMachineName  = 0x00000040,  // don't use lpszMachineName--enumerate local machine
};
typedef DWORD VSCOMPSELFLAGS;

typedef struct _VSCOMPONENTSELECTORTABINIT
{
    DWORD      dwSize;           // size of structure (for forward compatibility)
    GUID       guidTab;          // tab identification GUID
    VARIANT  varTabInitInfo;     // initialization info for tab
} VSCOMPONENTSELECTORTABINIT, *PVSCOMPONENTSELECTORTABINIT;

[
    uuid(uuid_IVsComponentSelectorDlg),
    version(1.0),
    pointer_default(unique)
]
interface IVsComponentSelectorDlg : IUnknown
{
    HRESULT ComponentSelectorDlg([in]   VSCOMPSELFLAGS grfFlags,         // VSCOMSEL_* flags
        [in]    IVsComponentUser *pUser,         // interface on which AddComponent will be called
        [in]    LPCOLESTR lpszDlgTitle,          // dialog caption (NULL == "Component Selector")
        [in]    LPCOLESTR lpszHelpTopic,         // F1 help topic (NULL == "VS.ComponentPicker")
        [in]    REFGUID rguidShowOnlyThisTab,    // tab to show exclusively
        [in]    REFGUID rguidStartOnThisTab,     // tab to show when the dialog starts up
        [in]    LPCOLESTR pszMachineName,        // enumerate COM components on this machine
        [in]    ULONG cTabInitializers,          // number of tab initialization structs in prgcstiTabInitializers
        [in]    VSCOMPONENTSELECTORTABINIT *prgcstiTabInitializers,// tab initialization info
        [in]    LPCOLESTR pszBrowseFilters,      // list of filters to use in 'Browse...' dialog
        [in,    out] BSTR *pbstrBrowseLocation); // directory (initial/return value) to start the 'Browse...' dialog in
}
cpp_quote("#define SID_SVsComponentSelectorDlg IID_IVsComponentSelectorDlg")


//----------------------------------------------------------------------------
// Code Reading Tools (Object Browser, Find Symbol and ClassView) Interfaces
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
// IVsLiteTreeList
//----------------------------------------------------------------------------
// Implemented by VsPackages that participate in Object Browser, Find Symbol and ClassView.
enum _VSTREEFLAGS
{
    TF_NOEXPANSION      = 0x0001, //None of the children of this node are expandable
    TF_NORELOCATE       = 0x0002, //LocateExpandedList not supported.  If this is set a ReAlign command will close all children
    TF_NOINSERTDELETE   = 0x0004, //InsertItems/DeleteItems won't be called
    TF_NOUPDATES        = 0x0008, //Don't call updated required
    TF_NOREALIGN        = 0x0010, //List is static, ReAlign will never be called with this list
    TF_NOSTATECHANGE    = 0x0020, //Don't call ToggleState
    TF_NOEFFECTS        = 0x0040, //All items are to be drawn without special effects
    TF_NOCOLORS         = 0x0080, //Fore and backcolor are standard
    TF_NOEVERYTHING     = 0x00ff, //Combination of all NO fields
    TF_OWNERDRAWTEXT    = 0x0080, //Let user draw the text portion of all items
    TF_OWNERDRAWALL     = 0x0180  //Let user draw the glyph and text portion (all except hierarchy)
};
typedef DWORD VSTREEFLAGS;

typedef enum _VSTREECLOSEACTIONS
{
    TCA_CLOSEANDDISCARD = 0x0000, //Toss this and all children
    TCA_CLOSECHILDREN   = 0x0001, //Discard children (the children will also get an OnClose)
    TCA_NOTHING         = 0x0002, //Don't do any discarding, just unexpand the node
} VSTREECLOSEACTIONS;

// These options are used with IVsLiteTreeList::GetText to specify the type of text being requested
//
// TTO_SORTTEXT is used for sorting the object lists and can be different than the DEFAULT text to
// control the sort order. For instance, if you want Folder nodes to sort above members even when sorting
// alphabetically, prepend a "1" to the sort text. Note however, the object manager requires you to
// keep these pointers for TTO_SORTTEXT valid and unchanged (after being asked for) until the list is 
// released. For all other TTO_ types you can reuse the same buffer over and over again.
//
// TTO_SEARCHTEXT is used for search thru and filtering the lists. Typically you would not provide
// a different search text, but rather use either the TTO_SORTTEXT or TTO_DISPLAYTEXT. If you don't want
// a particular item to be part of the search, return an empty string.
//
// TTO_DEFAULT or TTO_DISPLAYTEXT is used to actually paint the name in the tree. Your implementation 
// should also default to returning this text if asked for a text type you don't support (with the exception
// of TTO_PREFIX and TTO_PREFIX2).
//
// TTO_PREFIX2 and TTO_PREFIX represent upto two possible prefixes on the name that are prepended on the
// default name to get fully-qualified name (TTO_EXTENDED). In object list scenarios, TTO_PREFIX refers to
// the qualified classes name and TTO_PREFIX2 refers to the qualified namespaces name. If you don't have
// any special names here, it is ok to return an empty string or E_FAIL the call. However, returning the
// same name as TTO_DEFAULT is wrong!
//
// Examples: For a class member function m_Foo, TTO_DEFAULT, TTO_SEARCHTEXT & TTO_SORTTEXT can return 
// "m_Foo(int, void **)", TTO_PREFIX can return "CMyClass" and TTO_PREFIX can return 
// "MyNamespace::MyNestedNamespace". For a folder node such as "Bases and Implemented Interfaces", 
// TTO_DEFAULT can be "Bases and Implemented Interfaces", TTO_SEARCHTEXT can be "" (don't want this showing up in search), 
// TTO_SORTTEXT can be "1Bases and Implemented Interfaces" (to sort above members), and TTO_PREFIX* can be ""

typedef enum _VSTREETEXTOPTIONS
{
    TTO_DEFAULT         = 0x0000,       // Default base text
    TTO_DISPLAYTEXT     = TTO_DEFAULT,  // Alternte name for TTO_DEFAULT
    TTO_PREFIX          = 0x0001,       // Prefix 1 to default base text, if any
    TTO_PREFIX2         = 0x0002,       // Prefix 2 to default base text, if any
    TTO_EXTENDED        = 0x0004,       // DO NOT IMPLEMENT, Generated Full text (prefix2 + prefix + default) by object manager
    TTO_SORTTEXT        = 0x0008,       // Unique pointer used for sorts.  May be same as TTO_DISPLAYTEXT
    TTO_SEARCHTEXT      = 0x0010,       // Text used in searching, typically same as TTO_DISPLAYTEXT.
    TTO_BASETEXT        = 0x0020,       // DO NOT IMPLEMENT, used internally (Shortest form of the name possible)
    TTO_CUSTOM          = 0x0040,       // Custom text (depends on the context where used)
} VSTREETEXTOPTIONS;

typedef enum _VSTREETOOLTIPTYPE
{
    TIPTYPE_DEFAULT     = 0x0000,       // Default text. If same as default display text (TTO_DISPLAYTEXT), implementers don't even need to implement
    TIPTYPE_ICON        = 0x0001,       // Tip text over the icon
    TIPTYPE_STATEICON   = 0x0002,       // Tip text over the state icon
}
VSTREETOOLTIPTYPE;

//Note: Everything <=0x40 correspond to TVIF_* flags
enum _VSTREEDISPLAYMASK 
{
    TDM_IMAGE           = 0x0002,
    TDM_STATE           = 0x0008,
    TDM_SELECTEDIMAGE   = 0x0020,
    TDM_FORCESELECT     = 0x0080,
};
typedef DWORD VSTREEDISPLAYMASK;

//Note: Everything <= 0xF000 correspond to TVIS_* flags
enum _VSTREEDISPLAYSTATE
{
    TDS_SELECTED        = 0x000002, //this is not valid since there is no way to set it, can't be up to date
    TDS_CUT             = 0x000004,
    TDS_DROPHILITED     = 0x000008,
    TDS_BOLD            = 0x000010,
    TDS_DISPLAYLINK     = 0x000020, //Draw item text in same color as IE link, underline, change cursor on mouse-over
    TDS_OVERLAYMASK     = 0x000F00,
    TDS_STATEIMAGEMASK  = 0x00F000,
    TDS_USERMASK        = 0x00F000,
    TDS_FORCESELECT     = 0x010000,
    TDS_GRAYTEXT        = 0x020000,
    TDS_EXPANDED        = 0x040000, //used for notification only. Do NOT set!
    TDS_TEXTTYPEMASK    = 0xF00000,
};
typedef DWORD VSTREEDISPLAYSTATE;

typedef struct _VSTREEDISPLAYDATA
{
    VSTREEDISPLAYMASK   Mask;       //Items we care about in this structure
    VSTREEDISPLAYSTATE  State;      //State information
    VSTREEDISPLAYSTATE  StateMask;  //Items we care about in State
    USHORT  Image;                  //Normal image
    USHORT  SelectedImage;          //Selected image
    HANDLE  hImageList;             //0 to use current image list.  This gives alternate.
    USHORT  ForceSelectStart;       //Start of part of item to always select (for showing search hits)
    USHORT  ForceSelectLength;      //Length of forced selection
} VSTREEDISPLAYDATA;

cpp_quote("#define VSTDDSetUserState(tdd,v) ((tdd).State |= ((DWORD(v)) << 12))")
cpp_quote("#define VSTDDGetUserState(state) ((int)((((DWORD)(state)) >> 12) & 0xF))")
cpp_quote("#define VSTDDSetTextType(tdd,v) ((tdd).State |= ((DWORD(v)) << 20))")
cpp_quote("#define VSTDDGetTextType(state) ((VSTREETEXTOPTIONS)((((DWORD)(state)) >> 20) & 0xF))")

enum _VSTREESTATECHANGEREFRESH
{
    TSCR_NONE             = 0x0000, //No refresh required
    TSCR_CURRENT          = 0x0001, //Refresh toggled item
    TSCR_CHILDREN         = 0x0002, //Refresh children of toggled item
    TSCR_PARENTS          = 0x0004, //Refresh parents of toggled item
    TSCR_PARENTSCHILDREN  = 0x0008, //Refresh children of all parents
    TSCR_ENTIRE           = 0x0010, //Refresh entire tree
};
typedef DWORD VSTREESTATECHANGEREFRESH;

// To support dynamic updating of trees
enum _VSTREEITEMCHANGESMASK
{
    TCT_NOCHANGE          = 0x0000,
    TCT_ITEMADDED         = 0x0001,
    TCT_ITEMDELETED       = 0x0002,
    TCT_ITEMNAMECHANGED   = 0x0004, // Value returned by GetText(TTO_DEFAULT) changed
    TCT_ITEMPROPSCHANGED  = 0x0008,
    TCT_TOOMANYCHANGES    = 0xffff
};

typedef DWORD VSTREEITEMCHANGESMASK;

typedef struct _VSTREELISTITEMCHANGE
{
    ULONG Index;
    VSTREEITEMCHANGESMASK grfChange;
} VSTREELISTITEMCHANGE;

[
    uuid(uuid_IVsLiteTreeList),
    version(1.0),
    pointer_default(unique)
]
interface IVsLiteTreeList : IUnknown
{
    //Fetches VSTREEFLAGS
    HRESULT GetFlags([out] VSTREEFLAGS *pFlags);
    //Count of items in this list
    HRESULT GetItemCount([out] ULONG* pCount);
    //An item has been expanded, get the next list
    HRESULT GetExpandedList([in] ULONG Index, [out] BOOL *pfCanRecurse, [out] IVsLiteTreeList **pptlNode);
    //Called during a ReAlign command if TF_CANTRELOCATE isn't set.  Return
    //E_FAIL if the list can't be located, in which case the list will be discarded.
    HRESULT LocateExpandedList([in] IVsLiteTreeList* ExpandedList, [out] ULONG *iIndex);
    //Called when a list is collapsed by the user.
    HRESULT OnClose([out] VSTREECLOSEACTIONS *ptca);
    //Get a pointer to the main text for the list item. Caller will NOT free, implementor
    //can reuse buffer for each call to GetText except for TTO_SORTTEXT. See VSTREETEXTOPTIONS for tto details
    HRESULT GetText([in] ULONG Index, [in] VSTREETEXTOPTIONS tto, [out] const WCHAR **ppszText);
    //Get a pointer to the tip text for the list item. Like GetText, caller will NOT free, implementor
    //can reuse buffer for each call to GetTipText. If you want tiptext to be same as TTO_DISPLAYTEXT, you can
    //E_NOTIMPL this call.
    HRESULT GetTipText([in] ULONG Index, [in] VSTREETOOLTIPTYPE eTipType, [out] const WCHAR **ppszText); 
    //Is this item expandable?  Not called if TF_NOEXPANSION is set
    HRESULT GetExpandable([in] ULONG Index, [out] BOOL *pfExpandable);
    //Retrieve information to draw the item
    [local] HRESULT GetDisplayData([in] ULONG Index, [out] VSTREEDISPLAYDATA *pData);
    //Return latest update increment.  True/False isn't sufficient here since
    //multiple trees may be using this list.  Returning an update counter > than
    //the last one cached by a given tree will force calls to GetItemCount and
    //LocateExpandedList as needed.
    HRESULT UpdateCounter([out] ULONG *pCurUpdate,  [out] VSTREEITEMCHANGESMASK *pgrfChanges);
    // If prgListChanges is NULL, should return the # of changes in pcChanges. Otherwise
    // *pcChanges will indicate the size of the array (so that caller can allocate the array) to fill
    // with the VSTREELISTITEMCHANGE records
    HRESULT GetListChanges([in,out] ULONG *pcChanges, [in, size_is(*pcChanges)] VSTREELISTITEMCHANGE *prgListChanges);
    //Toggles the state of the given item (may be more than two states)
    HRESULT ToggleState([in] ULONG Index, [out] VSTREESTATECHANGEREFRESH *ptscr);
};


//---------------------------------------------------------------------------
// IVsLiteTree
//---------------------------------------------------------------------------
// Implemented by the Environment.

//Define additional LiteTree window messages
cpp_quote("#define LTVN_CARETCHANGINGA TVN_FIRST - 25  //normal TVN's go to TVN_FIRST - 15")
cpp_quote("#define LTVN_CARETCHANGINGW TVN_FIRST - 74  //A version - 49")
cpp_quote("#define LTVN_CARETCHANGEDA  TVN_FIRST - 26")
cpp_quote("#define LTVN_CARETCHANGEDW  TVN_FIRST - 75")
cpp_quote("#ifdef UNICODE")
cpp_quote("#define LTVN_CARETCHANGING LTVN_CARETCHANGINGW")
cpp_quote("#define LTVN_CARETCHANGED LTVN_CARETCHANGEDW")
cpp_quote("#else")
cpp_quote("#define LTVN_CARETCHANGING LTVN_CARETCHANGINGA")
cpp_quote("#define LTVN_CARETCHANGED LTVN_CARETCHANGEDA")
cpp_quote("#endif //UNICODE")

//no need for A/W here since passing indices only
cpp_quote("#define LTVM_GETSELCOUNT TV_FIRST + 48  //last normal end at TV_FIRST + 41")
cpp_quote("#define LTVM_GETSELITEMS TV_FIRST + 49")

//TVGN_'s go up to 0x000A, so we'll start LTVGN_'s at 0x0020
cpp_quote("#define LTVGN_FIRSTSEL  0x0020")
cpp_quote("#define LTVGN_NEXTSEL   0x0021")
cpp_quote("#define LTVGN_PREVIOUSSEL   0x0022")

enum __VSLITETREEOPTS
{
    LT_ALLOWMULTISELECT   = 0x00000001,
    LT_ALLOWEDITLABELS    = 0x00000002
};
typedef DWORD VSLITETREEOPTS;

[
    uuid(uuid_IVsLiteTree),
    version(1.0),
    pointer_default(unique)
]
interface IVsLiteTree : IUnknown
{
    //Set the root object for the tree. ppClone can be NULL.
    HRESULT SetRoot([in] IVsLiteTreeList *pList, [out] IVsLiteTree **ppClone);
    //Clone the tree structure
    HRESULT CloneTreeAbsolute([in] ULONG AbsIndex, [out, retval] IVsLiteTree **retVal);
    //NULL means realign all.  This will call GetChildCount and LocateChildNode as needed.
    //If a list doesn't support relocation, then the expanded list will be collapsed.
    HRESULT ReAlign([in] IVsLiteTreeList *pNode);
    //Use to insert items without forcing a realign. Use sparingly to adjust an existing
    //node--don't add a 0 child node and then insert a bunch of items. -1 = at beginning.
    HRESULT InsertItems([in] IVsLiteTreeList *pNode, [in] ULONG iAfter, [in] ULONG Count);
    //Use to delete specific items without doing a realign.
    HRESULT DeleteItems([in] IVsLiteTreeList *pNode, [in] ULONG iStart, [in] ULONG Count);
    //Expand item by absolute index
    HRESULT ToggleExpansionAbsolute([in] ULONG Index, [out] BOOL *pfCanRecurse, [out] long *pChange);
    //Is the item at this absolute index expanded?
    HRESULT GetExpandedAbsolute([in] ULONG AbsIndex, [out] BOOL *pfExpanded);
    //Is the item at this absolute index expanded?
    HRESULT GetExpandableAbsolute([in] ULONG AbsIndex, [out] BOOL *pfCanExpand);
    //Retrieve the parent list and index corresponding to the absolute position.
    HRESULT GetItemInfoAbsolute([in] ULONG AbsIndex, [out] IVsLiteTreeList **pptl, [out] ULONG *pIndex, [out] ULONG *pLevel);
    //Number of items currently displayed
    HRESULT VisibleItemCount([out] ULONG *pCount);
    //Call UpdateRequired on children as necessary
    HRESULT Refresh();
    //Return the number of descendants of a given node, 0 if not expanded
    HRESULT GetDescendantItemCount([in] ULONG AbsIndex, [out] ULONG *pCount);
    //Get the next visible expanded list.  Seed with -1 or the Index of an expansion.
    //Returns S_FALSE (and *pptl == NULL) if no more, E_FAIL for bad index
    HRESULT GetParentIndexAbsolute([in] ULONG AbsIndex, [out] ULONG* pParentIndex);
    //Returns the expanded list at the given index, if any
    HRESULT GetExpandedListAbsolute([in] ULONG AbsIndex, [out] ULONG* pLevel, [out] IVsLiteTreeList** pptl);
    //Toggles the state of the given item (may be more than two states)
    HRESULT ToggleStateAbsolute([in] ULONG AbsIndex, [out] VSTREESTATECHANGEREFRESH *ptscr);
    HRESULT AdviseTreeEvents([in] IVsLiteTreeEvents *pEventSink, [out] VSCOOKIE *pdwCookie);
    HRESULT UnadviseTreeEvents([in] VSCOOKIE dwCookie);
    HRESULT EnableTreeEvents([in] VSCOOKIE dwCookie, [in] BOOL fEnable);
    //Given a treelist and an index, walk all of the items in the list
    [local] HRESULT EnumAbsoluteIndices([in] IVsLiteTreeList *pList, [in] ULONG Index, [in,out] void** ppvNext, [out] ULONG *pAbsIndex);
    HRESULT GetOffsetFromParent([in] ULONG ParentAbsIndex, [in] ULONG RelIndex, [out] ULONG *pOffset);
    HRESULT EnumOrderedListItems([in,out] ULONG *pNextStartIndex, [out] IVsLiteTreeList  **pptl, [out] ULONG *pFirstRelIndex, [out] ULONG *pLastRelIndex, [out] ULONG *pLevel);
    //Addrefed redraw toggle FALSE turns off, TRUE turns on (depending on refcount)
    //OnSetRedraw fires only when toggling to/from 0 refcount
    HRESULT SetRedraw([in] BOOL fOn);
    HRESULT DelayRedraw([in] BOOL fOn);
    HRESULT QueryItemVisible([in] ULONG AbsIndex, [out] BOOL *pfVisible);
    HRESULT Init([in]VSLITETREEOPTS grfOpts);
    HRESULT GetInitFlags([out]VSLITETREEOPTS *pgrfOpts);
};


//---------------------------------------------------------------------------
// IVsLiteTreeEvents
//---------------------------------------------------------------------------
// Implemented by the Environment and used internally as part Object Browser, 
// Find Symbol and ClassView.
[
    uuid(uuid_IVsLiteTreeEvents),
    version(1.0),
    pointer_default(unique)

]
interface IVsLiteTreeEvents : IUnknown
{
    //The expanded state of an item has been toggled
    HRESULT OnToggleExpansion([in] ULONG AbsIndex, [in] long cChange);
    //The state icon was clicked
    HRESULT OnToggleState([in] ULONG AbsIndex, [in] VSTREESTATECHANGEREFRESH tscr);
    //The list has been refreshed (update count, window, current selection)
    HRESULT OnRefresh();
    //Count items have been inserted after iAfter
    HRESULT OnInsertItems([in] ULONG iAfter, [in] ULONG Count);
    //Count items have been deleted starting with iStart
    HRESULT OnDeleteItems([in] ULONG iStart, [in] ULONG Count);
    //Turn redraw on/off
    HRESULT OnSetRedraw([in] BOOL fOn);
    //Is specified item visible
    HRESULT OnQueryItemVisible([in] ULONG AbsIndex, [out] BOOL *pfVisible);
}


//----------------------------------------------------------------------------
// IVsLibrary
//----------------------------------------------------------------------------
// Implemented by VsPackages that participate in Object Browser, Find Symbol and ClassView.
// Interface retrieved by the Environment via IVsLibraryMgr::GetLibraryAt.

typedef enum
{
    LCS_UNCHECKED   = 1,
    LCS_CHECKEDGRAY = 2,
    LCS_CHECKED     = 3,
} LIB_CHECKSTATE;

enum _LIB_LISTTYPE
{
    LLT_HIERARCHY               = 0x000001, // special list type to support grouped base and derived classes list in CV
    LLT_NAMESPACES              = 0x000002,
    LLT_CLASSES                 = 0x000004, 
    LLT_MEMBERS                 = 0x000008, 
    LLT_PHYSICALCONTAINERS      = 0x000010, 
    LLT_PACKAGE                 = 0x000010, //same as above (old name)

    // OBSOLETE: Don't use the following
    LLT_CONTAINMENT             = 0x000020,
    LLT_CONTAINEDBY             = 0x000040,
    LLT_USESCLASSES             = 0x000080,
    LLT_USEDBYCLASSES           = 0x000100,
    LLT_NESTEDCLASSES           = 0x000200,
    LLT_INHERITEDINTERFACES     = 0x000400,
    LLT_INTERFACEUSEDBYCLASSES  = 0x000800,
    LLT_DEFINITIONS             = 0x001000,
    LLT_REFERENCES              = 0x002000,
    //end OBSOLETE

    // special list type to indicate getting expansion info for its children using 
    // the IVsLiteTreeList mechanism (GetExpandable and GetExpandedList) instead
    // of using the GetCategoryField mechanism
    LLT_DEFEREXPANSION          = 0x100000, 
};
typedef DWORD LIB_LISTTYPE;

enum _LIB_LISTFLAGS
{
    LLF_NONE                = 0x0000,
    LLF_IGNORESUBSET        = 0x0001, // For classview
    LLF_TRUENESTING         = 0x0002, // For classview 
    LLF_PROJECTONLY         = 0x0004, // For classview
    LLF_USESEARCHFILTER     = 0x0008, // For find symbol
    LLF_DONTUPDATELIST      = 0x0010, // For find symbol
    LLF_RESOURCEVIEW        = 0x0020, // For resource view
};
typedef DWORD LIB_LISTFLAGS;

cpp_quote("#define VSOBJFLAGS_OBJBROWSER     (LLF_NONE)")
cpp_quote("#define VSOBJFLAGS_OBJSEARCH      (LLF_USESEARCHFILTER | LLF_DONTUPDATELIST)")
cpp_quote("#define VSOBJFLAGS_CLASSVIEW      (LLF_IGNORESUBSET | LLF_TRUENESTING | LLF_PROJECTONLY)")
cpp_quote("#define VSOBJFLAGS_RESOURCEVIEW   (LLF_RESOURCEVIEW)")

enum _LIB_FLAGS
{
    LF_PROJECT          = 0x0001, //Place library in Projects list
    LF_GLOBAL           = 0x0002, //Place library in Globals list
    LF_EXPANDABLE       = 0x0004, //Library supports GetLibList
    LF_HIDEINLIBPICKER  = 0x0008, //Don't show library or its liblist in the library picker dialog
} ;
typedef DWORD LIB_FLAGS;

typedef enum
{
    // Note that these should   be the same values as their
    // counterparts in LIB_FLAGS above
    LPT_PROJECT         = 0x0001,
    LPT_GLOBAL          = 0x0002,
} LIB_PERSISTTYPE;


typedef enum
{
    LC_MEMBERTYPE     = 1,
    LC_MEMBERACCESS   = 2,
    LC_CLASSTYPE      = 3,
    LC_CLASSACCESS    = 4,
    LC_ACTIVEPROJECT  = 5,
    LC_LISTTYPE       = 6, //Special value to determine which sublists are supported
    LC_VISIBILITY     = 7,
    LC_MODIFIER       = 8,
    LC_NODETYPE       = 9, //Special value - IVsObjectList implementers - DO NOT implement
} LIB_CATEGORY;

typedef LIB_LISTTYPE LIBCAT_LISTTYPE;

enum _LIBCAT_MEMBERTYPE
{
    LCMT_METHOD       = 0x0001,
    LCMT_FUNCTION     = 0x0002,
    LCMT_OPERATOR     = 0x0004,
    LCMT_PROPERTY     = 0x0008,
    LCMT_FIELD        = 0x0010,
    LCMT_VARIABLE     = 0x0020,
    LCMT_EVENT        = 0x0040,
    LCMT_CONSTANT     = 0x0080,
    LCMT_ENUMITEM     = 0x0100,
    LCMT_TYPEDEF      = 0x0200,
    LCMT_MAPITEM      = 0x0400,
    LCMT_DECLARATION  = 0x0800,
    LCMT_MACRO        = 0x1000,
    LCMT_ERROR        = 0x2000,
} ;
typedef DWORD LIBCAT_MEMBERTYPE;
cpp_quote("#define COUNT_LIBCAT_MEMBERTYPE 14")

enum _LIBCAT_MODIFIERTYPE
{
    LCMDT_VIRTUAL       = 0x0001,
    LCMDT_PUREVIRTUAL   = 0x0002,
    LCMDT_NONVIRTUAL    = 0x0004,
    LCMDT_FINAL         = 0x0008,
    LCMDT_STATIC          = 0x0010,
};
typedef DWORD LIBCAT_MODIFIERTYPE;
cpp_quote("#define COUNT_LIBCAT_MODIFIERTYPE 5")

enum _LIBCAT_MEMBERACCESS
{
    LCMA_PUBLIC       = 0x0001,
    LCMA_PRIVATE      = 0x0002,
    LCMA_PROTECTED    = 0x0004,
    LCMA_PACKAGE      = 0x0008,
    LCMA_FRIEND       = 0x0010,
    LCMA_SEALED       = 0x0020
};
typedef DWORD LIBCAT_MEMBERACCESS;
cpp_quote("#define COUNT_LIBCAT_MEMBERACCESS 6")

enum _LIBCAT_CLASSACCESS
{
    LCCA_PUBLIC       = 0x0001,
    LCCA_PRIVATE      = 0x0002,
    LCCA_PROTECTED    = 0x0004,
    LCCA_PACKAGE      = 0x0008,
    LCCA_FRIEND       = 0x0010,
    LCCA_SEALED       = 0x0020
};
typedef DWORD LIBCAT_CLASSACCESS;
cpp_quote("#define COUNT_LIBCAT_CLASSACCESS 6")

enum _LIBCAT_CLASSTYPE
{
    LCCT_NSPC         = 0x0001,
    LCCT_CLASS        = 0x0002,
    LCCT_INTERFACE    = 0x0004,
    LCCT_STRUCT       = 0x0008,
    LCCT_UNION        = 0x0010,
    LCCT_ENUM         = 0x0020,
    LCCT_TYPEDEF      = 0x0040,
    LCCT_MODULE       = 0x0080,
    LCCT_INTRINSIC    = 0x0100,
    LCCT_DELEGATE     = 0x0200,
    LCCT_EXCEPTION    = 0x0400,
    LCCT_MAP          = 0x0800,
    LCCT_GLOBAL       = 0x1000,
    LCCT_ERROR        = 0x2000
};
typedef DWORD LIBCAT_CLASSTYPE;
cpp_quote("#define COUNT_LIBCAT_CLASSTYPE 14")

enum _LIBCAT_ACTIVEPROJECT
{
    LCAP_SHOWALWAYS   = 0x0001,
    LCAP_MUSTBEACTIVE = 0x0002,
};
typedef DWORD LIBCAT_ACTIVEPROJECT;
cpp_quote("#define COUNT_LIBCAT_ACTIVEPROJECT 2")

enum _LIBCAT_VISIBILITY
{
    LCV_VISIBLE       = 0x0001,
    LCV_HIDDEN        = 0x0002,
};
typedef DWORD LIBCAT_VISIBILITY;
cpp_quote("#define COUNT_LIBCAT_VISIBILITY 2")

enum _LIBCAT_NODETYPE
{
    LCNT_SYMBOL       = 0x0001,
    LCNT_HIERARCHY    = 0x0002,
    LCNT_PROJECT      = 0x0004,
    LCNT_FOLDER       = 0x0008,
};
typedef DWORD LIBCAT_NODETYPE;
cpp_quote("#define COUNT_LIBCAT_NODETYPE 3")

typedef enum
{
    SO_ENTIREWORD     = 1,       
    SO_SUBSTRING      = 2,       
    SO_PRESTRING      = 3,       
} VSOBSEARCHTYPE;   

enum _VSOBSEARCHOPTIONS
{
    VSOBSO_NONE           = 0x0000,
    VSOBSO_CASESENSITIVE  = 0x0001,
    VSOBSO_LOOKINREFS     = 0x0002
};
typedef DWORD VSOBSEARCHOPTIONS;

typedef struct _VSOBSEARCHCRITERIA
{
    LPCOLESTR szName;
    VSOBSEARCHTYPE eSrchType;
    VSOBSEARCHOPTIONS grfOptions;
    DWORD dwCustom;
} VSOBSEARCHCRITERIA;

typedef struct _VSOBNAVNAMEINFONODE
{
    WCHAR* pszName;
    LIB_LISTTYPE lltName;
    struct _VSOBNAVNAMEINFONODE *pNext;
} VSOBNAVNAMEINFONODE;

typedef struct _VSOBNAVIGATIONINFO2
{
    GUID * pguidLib;
    WCHAR* pszLibName;
    VSOBNAVNAMEINFONODE *pName;
    DWORD  dwCustom;  
} VSOBNAVIGATIONINFO2;

typedef struct _VSOBJECTINFO
{
    GUID * pguidLib;
    WCHAR* pszLibName;
    WCHAR* pszNspcName;
    WCHAR* pszClassName;
    WCHAR* pszMemberName;
    DWORD  dwCustom;
} VSOBJECTINFO;

typedef struct _VSBROWSECONTAINER
{
    GUID *pguidLib;
    LPCWSTR szName;
} VSBROWSECONTAINER;

enum _LIB_ADDREMOVEOPTIONS
{
    LARO_NONE         = 0x0000,
    LARO_ALREADYADDED = 0x0001,   // [out] Library should return this flag to indicate the specified component is already added
    LARO_THRUFILEOPS  = 0x0002,   // [in] Tells library that the component is being added thru File Open
};
typedef DWORD LIB_ADDREMOVEOPTIONS;

[
    uuid(uuid_IVsLibrary),
    version(1.0),
    pointer_default(unique)
]
interface IVsLibrary : IUnknown
{
    //Return E_FAIL if category not supported.
    HRESULT GetSupportedCategoryFields([in] LIB_CATEGORY Category, [out, retval] DWORD *pCatField);

    //Retrieve a IVsObjectList interface of LISTTYPE
    HRESULT GetList([in] LIB_LISTTYPE ListType,  [in] LIB_LISTFLAGS Flags, [in] VSOBSEARCHCRITERIA *pobSrch, [out, retval] IVsObjectList **ppList);

    //Retreive a list of library contents (either PROJECT or GLOBAL.  Return S_FALSE and NULL if library not expandable
    HRESULT GetLibList([in] LIB_PERSISTTYPE lptType, [out, retval] IVsLiteTreeList **ppList);

    //Get various settings for the library
    HRESULT GetLibFlags([out, retval] LIB_FLAGS *pfFlags);

    //Counter to check if the library has changed
    HRESULT UpdateCounter([out] ULONG *pCurUpdate);

    // Unqiue guid identifying each library that never changes (even across shell instances)
    HRESULT GetGuid(const GUID **ppguidLib);

    // Returns the separator string used to separate namespaces, classes and members 
    // eg. "::" for VC and "." for VB
    HRESULT GetSeparatorString(LPCWSTR *pszSeparator);

    //Retrieve the persisted state of this library from the passed stream 
    //(essentially information for each browse container being browsed). Only
    //implement for GLOBAL browse containers
    HRESULT LoadState([in] IStream *pIStream, [in] LIB_PERSISTTYPE lptType);

    //Save the current state of this library to the passed stream 
    //(essentially information for each browse container being browsed). Only
    //implement for GLOBAL browse containers
    HRESULT SaveState([in] IStream *pIStream, [in] LIB_PERSISTTYPE lptType);

    // Used to obtain a list of browse containers corresponding to the given
    // project (hierarchy). Only return a list if your package owns this hierarchy
    // Meaningful only for libraries providing PROJECT browse containers.
    HRESULT GetBrowseContainersForHierarchy([in] IVsHierarchy *pHierarchy,
        [in] ULONG celt,
        [in, out, size_is(celt)] VSBROWSECONTAINER rgBrowseContainers[],
        [out, optional] ULONG *pcActual);


    // Start browsing the component specified in PVSCOMPONENTSELECTORDATA (name is equivalent to that
    // returned thru the liblist's GetText method for this browse container). 
    // Only meaningful for registered libraries for a given type of GLOBAL browse container 
    HRESULT AddBrowseContainer([in] PVSCOMPONENTSELECTORDATA pcdComponent, [in, out] LIB_ADDREMOVEOPTIONS *pgrfOptions, [out] BSTR *pbstrComponentAdded);

    // Stop browsing the component identified by name (name is equivalent to that
    // returned thru the liblist's GetText method for this browse container 
    // Only meaningful for registered libraries for a given type of GLOBAL browse container 
    HRESULT RemoveBrowseContainer([in] DWORD dwReserved, [in] LPCWSTR pszLibName);

};

//----------------------------------------------------------------------------
// IVsLibraryMgr
//----------------------------------------------------------------------------
// Implemented by VsPackages that participate in Object Browser, Find Symbol and ClassView.
// Interface passed to the Environment via IVsObjectManager::RegisterLibMgr.
[
    uuid(uuid_IVsLibraryMgr),
    version(1.0),
    pointer_default(unique)
]
interface IVsLibraryMgr : IUnknown
{

    //Return the number of libraries known by this manager
    HRESULT GetCount([out, retval] ULONG *pnCount);

    //Return a library interface for the designated library
    HRESULT GetLibraryAt([in] ULONG nLibIndex, [out, retval] IVsLibrary **ppLibrary);

    //Return a displayable name for the designated library
    HRESULT GetNameAt([in] ULONG nLibIndex, [out, retval] WCHAR **pszName);

    //Set the selected state for a library item
    HRESULT ToggleCheckAt([in] ULONG nLibIndex);

    //Get the selected state for a library item
    HRESULT GetCheckAt([in] ULONG nLibIndex, [out, retval] LIB_CHECKSTATE *pstate);

    //Library picker needs to tell library manager if top level group is enabled
    HRESULT SetLibraryGroupEnabled([in] LIB_PERSISTTYPE lpt, [in] BOOL fEnable);

};

//----------------------------------------------------------------------------
// IVsObjectList
//----------------------------------------------------------------------------
// Implemented by VsPackages that participate in Object Browser, Find Symbol and ClassView.
// Interface retrieved by QI from IVsLiteTreeList.
enum _LIB_LISTCAPABILITIES
{
    LLC_NONE             = 0x0000,
    LLC_HASBROWSEOBJ     = 0x0001,
    LLC_HASDESCPANE      = 0x0002,
    LLC_HASSOURCECONTEXT = 0x0004,
    LLC_HASCOMMANDS      = 0x0008,
    LLC_ALLOWDRAGDROP    = 0x0010,
    LLC_ALLOWRENAME      = 0x0020,
    LLC_ALLOWDELETE      = 0x0040,
    LLC_ALLOWSCCOPS      = 0x0080    // Source Code Control Ops
};
typedef DWORD LIB_LISTCAPABILITIES;

enum _VSOBJDESCOPTIONS
{
    ODO_NONE           = 0x0000,
    ODO_TOOLTIPDESC    = 0x0001,
    ODO_USEFULLNAME    = 0x0002
};
typedef DWORD VSOBJDESCOPTIONS;

typedef enum
{
    GS_ANY           = 0,
    GS_DEFINITION    = 1,
    GS_DECLARATION   = 2,
    GS_REFERENCE     = 3,
} VSOBJGOTOSRCTYPE;

enum _VSOBJCLIPFORMATOPTIONS
{
    CFO_NONE            = 0x0000,
    CFO_COMPOSITEFMT    = 0x0001, // Called on GetExtendedClipboardVariant to render this format
    CFO_INVALIDCF       = 0x8000, // NOTE: for object manager use only
}; 
typedef DWORD VSOBJCLIPFORMATOPTIONS;

typedef struct _VSOBJCLIPFORMAT
{
    CLIPFORMAT cfFormat;
    DWORD tymed;
    VSOBJCLIPFORMATOPTIONS dwOptions;
} VSOBJCLIPFORMAT;

enum _VSOBJCFFLAGS
{
    CFF_NONE        = 0x0000,
    CFF_MULTISELECT = 0x0001
};
typedef DWORD VSOBJCFFLAGS;

enum _VSOBJOPFLAGS
{
    OPF_NONE            = 0x0000,
    OPF_MULTISELECT = 0x0001,
    OPF_FIRSTITEM       = 0x0002,
    OPF_LASTITEM        = 0x0004
};
typedef DWORD VSOBJOPFLAGS;

[
    uuid(uuid_IVsObjectList),
    version(1.0),
    local
]
interface IVsObjectList : IVsLiteTreeList
{
    // Get list capabilities
    HRESULT GetCapabilities([out]  LIB_LISTCAPABILITIES *pCapabilities);
    // Get a sublist
    HRESULT GetList([in] ULONG Index, [in] LIB_LISTTYPE ListType, [in] LIB_LISTFLAGS Flags, [in] VSOBSEARCHCRITERIA *pobSrch, [out] IVsObjectList **ppList);  
    HRESULT GetCategoryField([in] ULONG Index, [in] LIB_CATEGORY Category, [out,retval] DWORD* pField); 
    HRESULT GetExpandable2([in] ULONG Index, [in] LIB_LISTTYPE ListTypeExcluded, [out] BOOL *pfExpandable);
    HRESULT GetNavigationInfo([in] ULONG Index, [in, out] VSOBNAVIGATIONINFO2 *pobNav);
    HRESULT LocateNavigationInfo([in] VSOBNAVIGATIONINFO2 *pobNav, [in] VSOBNAVNAMEINFONODE *pobName, [in] BOOL fDontUpdate, [out] BOOL *pfMatchedName, [out] ULONG *pIndex);
    HRESULT GetBrowseObject([in] ULONG Index, [out] IDispatch **ppdispBrowseObj);
    HRESULT GetUserContext([in] ULONG Index, [out] IUnknown **ppunkUserCtx);
    HRESULT ShowHelp([in] ULONG Index);
    HRESULT GetSourceContext([in] ULONG Index, [out] const WCHAR **pszFileName, [out] ULONG *pulLineNum);

    // Returns the count of itemids (these must be from a single hierarchy) that make up the source files
    // for the list element at Index. Also returns the hierarchy ptr and itemid if requested.
    // If there are >1 itemids, return VSITEMID_SELECTION and a subsequent call will be made
    // on GetMultipleSourceItems to get them. If there are no available source items, return
    // VSITEMID_ROOT to indicate the root of the hierarchy as a whole.
    HRESULT CountSourceItems([in] ULONG Index, [out] IVsHierarchy **ppHier, [out] VSITEMID *pitemid, [out, retval] ULONG *pcItems);
    // Used if CountSourceItems returns > 1. Details for filling up these out params are same 
    // as IVsMultiItemSelect::GetSelectedItems
    HRESULT GetMultipleSourceItems([in] ULONG Index, [in] VSGSIFLAGS grfGSI, [in] ULONG cItems, [out, size_is(cItems)] VSITEMSELECTION rgItemSel[]);
    // Return TRUE if navigation to source of the specified type (definition or declaration),
    // is possible, FALSE otherwise
    HRESULT CanGoToSource([in] ULONG Index, [in] VSOBJGOTOSRCTYPE SrcType, [out] BOOL *pfOK);
    // Called to cause navigation to the source (definition or declration) for the
    // item Index. You must must coordinate with the project system to open the
    // source file and navigate it to the approp. line. Return S_OK on success or an
    // hr error (along with rich error info if possible) if the navigation failed.
    HRESULT GoToSource([in] ULONG Index, [in] VSOBJGOTOSRCTYPE SrcType);
    HRESULT GetContextMenu([in] ULONG Index, [out] CLSID *pclsidActive, [out] LONG *pnMenuId, [out] IOleCommandTarget **ppCmdTrgtActive);   
    HRESULT QueryDragDrop([in] ULONG Index, [in] IDataObject *pDataObject, [in] DWORD grfKeyState, [in, out]DWORD * pdwEffect);
    HRESULT DoDragDrop([in] ULONG Index, [in] IDataObject * pDataObject, [in] DWORD grfKeyState, [in, out]DWORD * pdwEffect);
    // Says whether the item Index can be renamed or not. If the passed in pszNewName is NULL,
    // it simply answers the general question of whether or not that item supports rename
    // (return TRUE or FALSE). If pszNewName is non-NULL, do validation of the new name
    // and return TRUE if successful rename with that new name is possible or an an error hr (along with FALSE)
    // if the name is somehow invalid (and set the rich error info to indicate to the user
    // what was wrong) 
    HRESULT CanRename([in] ULONG Index, [in] LPCOLESTR pszNewName, [out] BOOL *pfOK);
    // Called when the user commits the Rename operation. Guaranteed that CanRename has already
    // been called with the newname so that you've had a chance to validate the name. If
    // Rename succeeds, return S_OK, other wise error hr (and set the rich error info)
    // indicating the problem encountered.
    HRESULT DoRename([in] ULONG Index, [in] LPCOLESTR pszNewName, [in] VSOBJOPFLAGS grfFlags);
    // Says whether the item Index can be deleted or not. Return TRUE if it can, FALSE if not.
    HRESULT CanDelete([in] ULONG Index, [out] BOOL *pfOK);
    // Called when the user asks to delete the item at Index. Will only happen if CanDelete on
    // the item previously returned TRUE. On a successful deletion this should return S_OK, if
    // the deletion failed, return the failure as an error hresult and set any pertinent error
    // info in the standard ole error info.
    HRESULT DoDelete([in] ULONG Index, [in] VSOBJOPFLAGS grfFlags);
    // Used to add the description pane text in OBject Browser. Also an alternate
    // mechanism for providing tooltips (ODO_TOOLTIPDESC is set in that case)
    HRESULT FillDescription([in] ULONG Index, [in] VSOBJDESCOPTIONS grfOptions, [in] IVsObjectBrowserDescription2 *pobDesc);
    // These three methods give the list a chance to provide clipboard formats for a drag-drop or 
    // copy/paste operation.
    // Caller first calls EnumClipboardFormats(index, flags, 0, NULL, &cExpected) to get the count
    // of clipboard formats the list is interested in providing, allocates an array of that size,
    // and then calls EnumClipboardFormats(index, flags, cExpected, prgCFs, &cActual)
    // Flags indicate whether this is part of a multiple selction of items. In the 
    // returned array, the list can indicate which formats it supports, on what STGMEDIUM and
    // whether the format is a composite one (caller does the actual rendering after calling
    // GetExtendedClipboardVariant) vs one that the list itself will render thru GetClipboardFormat
    // In the case of a multi-select, typically the list would only support composite formats
    // enabling the caller to write the format in the form: 
    // <count of items><foo variant from selected item1><foo variant from selected item2>..
    // (Note that only certain persistable VARIANT types are supported (as per CComVariant::WriteToStream).
    // In the single select case, the list is free to provide both traditional and composite formats
    // and will be called respectively on GetClipboardFormat or GetExtendedClipboardVariant for each.
    // Note that CV/OB will automatically provide a CF_NAVINFO and a CF_TEXT/CF_UNICODETEXT format, so
    // EnumClipboardFormats should NOT return these values.
    HRESULT EnumClipboardFormats([in] ULONG Index, 
        [in] VSOBJCFFLAGS grfFlags,
        [in] ULONG  celt, 
        [in, out, size_is(celt)] VSOBJCLIPFORMAT rgcfFormats[],
        [out, optional] ULONG *pcActual);
    HRESULT GetClipboardFormat([in] ULONG Index,
        [in]    VSOBJCFFLAGS grfFlags,
        [in]    FORMATETC *pFormatetc,
        [in]    STGMEDIUM *pMedium);
    HRESULT GetExtendedClipboardVariant([in] ULONG Index,
        [in] VSOBJCFFLAGS grfFlags,
        [in] const VSOBJCLIPFORMAT *pcfFormat,
        [out] VARIANT *pvarFormat);

};

//----------------------------------------------------------------------------
// interface IVsObjectListOwner
//----------------------------------------------------------------------------
// Implemented by the Environment.
enum _VSOBJLISTOWNEROTPIONS
{
    LOO_NONE                  = 0x0000,
    LOO_SUPPORTSEXTENDEDTEXT  = 0x0001,
    LOO_UPDATESDISPLAYDATA    = 0x0002,
};

typedef DWORD VSOBJLISTOWNEROTPIONS;

enum _VSOBJLISTOWNERCACHEDDATAKINDS
{
    LOCDK_NONE                = 0x0000,
    LOCDK_SELECTEDNAVINFO     = 0x0001,
};
typedef DWORD VSOBJLISTOWNERCACHEDDATAKINDS;

[
    uuid(uuid_IVsObjectListOwner),
    version(1.0),
    local
]
interface IVsObjectListOwner : IUnknown
{
    HRESULT GetOptions(VSOBJLISTOWNEROTPIONS *pOptions);
    HRESULT IsVisible(void);
    HRESULT ListLoadRefused(void);
    HRESULT DoWaitUI([in] BOOL fStart);
    HRESULT NotifySearchHit(void);
    HRESULT ClearSearchHit(void);
    HRESULT HaveSearchHit(void);
    HRESULT CalculateExtendedText([in] IVsObjectList *pList, [in] ULONG iItem, [in] LPCWSTR strSeperator);
    HRESULT GetExtendedText([out] LPCWSTR *pwszExtText);
    HRESULT UpdateDisplayData([in] IVsObjectList *pList, [in] ULONG iItem, [in] BOOL fPackageList, [in] DWORD dwReserved, [in,out] VSTREEDISPLAYDATA *pData);
    HRESULT ClearCachedData([in] VSOBJLISTOWNERCACHEDDATAKINDS grfDataKinds);
    HRESULT ClearListFilters([in] DWORD dwReserved);
};

//----------------------------------------------------------------------------
// interface IVsObjectManager
//----------------------------------------------------------------------------
// Implemented by the Environment.
// Used by VsPackages that participate in Object Browser, Find Symbol and ClassView.
[
    uuid(uuid_IVsObjectManager),
    version(1.0),
    pointer_default(unique)
]
interface IVsObjectManager : IUnknown
{
    HRESULT RegisterLibMgr([in] REFGUID rguidLibMgr, [in] IVsLibraryMgr* pLibMgr, [out] VSCOOKIE* pdwCookie);
    HRESULT UnregisterLibMgr([in] VSCOOKIE dwCookie);
    HRESULT EnumLibMgrs([out] ULONG *pCount, [out] IVsLibraryMgr** rgpLibMgrs);
    HRESULT RefreshLists();
    HRESULT GetList([in] LIB_LISTTYPE ListType, [in] LIB_LISTFLAGS Flags, [in] IVsLibraryMgr* pLibMgr, [in] VSOBSEARCHCRITERIA *pobSrch, [out] IVsObjectList **ppList);
};


cpp_quote("#define SID_SVsObjectManager IID_IVsObjectManager")

//----------------------------------------------------------------------------
// interface IVsObjectManagerEvents
//----------------------------------------------------------------------------
// Implemented by the Environment and used internally as part of Object Browser, 
// Find Symbol and ClassView.
[
    uuid(uuid_IVsObjectManagerEvents),
    version(1.0),
    pointer_default(unique)
]
interface IVsObjectManagerEvents : IUnknown
{
    HRESULT OnBeforeSubsetChange(void);
    HRESULT OnAfterSubsetChange(void);
}

//----------------------------------------------------------------------------
// interface IVsObjectBrowserDescription2
//----------------------------------------------------------------------------
// Implemented by the Environment.
// This interface is passed to IVsObjectList::FillDescription.
typedef enum _VSOBDESCRIPTIONSECTION {
    OBDS_MISC,
    OBDS_NAME,
    OBDS_PARAM,
    OBDS_TYPE,
    OBDS_ATTRIBUTE,
    OBDS_ENDDECL,
    OBDS_COMMA,
    OBDS_ENABLEHELP,        //Call AddDescriptionText with OBDS_ENABLEHELP, NULL, NULL to enable help command
    OBDS_ENABLEGOTOSOURCE,//Similar for goto definition command
    OBDS_NOTIFYONLY,        //FillDescription may be called on the dependent list of an LT_MEMBERS list as
    //a means of notification so that the primary list knows which class to associate
    //with the member.  In this scenario, there is no reason to proceed with actually
    //filling the description pane.  For this type of list, if AddDescriptionText(ODBS_NOTIFYONLY, NULL, NULL)
    //returns a success code, then FillDescription should return immediately.
    OBDS_ENDDECLEXPECTHTML //Same   as ENDDECL, but tells browser to look out for HTML tags
} VSOBDESCRIPTIONSECTION;

[
    uuid(uuid_IVsObjectBrowserDescription2),
    version(1.0),
    pointer_default(unique)
]
interface IVsObjectBrowserDescription2 : IUnknown
{
    //Notify when the state of a library node changes
    //Note: passing back LibraryMgr allows same sink to be used on multiple library managers
    HRESULT AddDescriptionText([in] LPCWSTR pText, [in] VSOBDESCRIPTIONSECTION obdSect, [in] VSOBJECTINFO *pHyperJump);
    HRESULT ClearDescriptionText();
};


// Tool related services

//----------------------------------------------------------------------------
// interface IVsClassView (Class View service)
//----------------------------------------------------------------------------
// Implemented by the Environment.
// Used by VsPackages that want to manipulate ClassView.
[
    uuid(uuid_IVsClassView),
    version(1.0),
    local
]
interface IVsClassView : IUnknown
{
    // Navigate to object described by VSOBJECTINFO
    HRESULT NavigateTo([in] const VSOBJECTINFO *pObjInfo, [in] DWORD dwReserved);
};

cpp_quote("#define SID_SVsClassView IID_IVsClassView")


//----------------------------------------------------------------------------
// interface IVsResourceView (Resource View service)
//----------------------------------------------------------------------------
// Implemented by the Environment.
[
    uuid(uuid_IVsResourceView),
    version(1.0),
    local
]
interface IVsResourceView : IUnknown
{
    // No methods 
};

cpp_quote("#define SID_SVsResourceView IID_IVsResourceView")


//----------------------------------------------------------------------------
// interface IVsObjBrowser (Object Browser service)
//----------------------------------------------------------------------------
// Implemented by the Environment.
// Used by VsPackages that want to manipulate Object Browser.
[
    uuid(uuid_IVsObjBrowser), 
    version(1.0),
    local
]
interface IVsObjBrowser : IUnknown
{
    // Navigate to object described by VSOBJECTINFO
    HRESULT NavigateTo([in] const VSOBJECTINFO *pObjInfo, [in] DWORD dwReserved);
};

cpp_quote("#define SID_SVsObjBrowser IID_IVsObjBrowser")


//
// Macros to deal with wide char string-constants using defined symbols
//
cpp_quote("#define _TOL(x)  L##x")
cpp_quote("#define __L(x)   _TOL(x)")


// VS-specific HRESULT failure codes - start at 0x80041FE0
//
cpp_quote("#define VS_E_PROJECTALREADYEXISTS    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1FE0)")
cpp_quote("#define VS_E_PACKAGENOTLOADED    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1FE1)")
cpp_quote("#define VS_E_PROJECTNOTLOADED    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1FE2)")
cpp_quote("#define VS_E_SOLUTIONNOTOPEN     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1FE3)")
cpp_quote("#define VS_E_SOLUTIONALREADYOPEN MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1FE4)")
cpp_quote("#define VS_E_PROJECTMIGRATIONFAILED MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1FE5)")

cpp_quote("#define VS_E_INCOMPATIBLEDOCDATA MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1FEA)")
cpp_quote("#define VS_E_UNSUPPORTEDFORMAT   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1FEB)")

cpp_quote("#define VS_E_WIZARDBACKBUTTONPRESS   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1FFF)")

// VS-specific HRESULT success codes - start at 0x00041FF0
//
cpp_quote("#define VS_S_PROJECTFORWARDED    MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 0x1FF0)")
cpp_quote("#define VS_S_TBXMARKER       MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 0x1FF1)")

// obsolete. Use VsStateIcon instead
typedef enum _eSCCIcons {      // item states (icons) used in the left channel
    STATEICON_NONE        = 0, // of the UIHierarchyWindows
    STATEICON__CHECKEDIN      = 1,
    STATEICON__CHECKEDOUT     = 2,
    STATEICON__ORPHANED   = 3,
    STATEICON__EDITABLE   = 4,
    STATEICON__BLANK          = 5,  
    STATEICON__READONLY   = 6,
    STATEICON__MAXINDEX   = 7
} eSCCIcons;


typedef enum __VsStateIcon{
    STATEICON_NOSTATEICON                   = 0, // not supported
    STATEICON_CHECKEDIN                 = 1,
    STATEICON_CHECKEDOUT                    = 2, // checked-out shared by user
    STATEICON_ORPHANED                  = 3,
    STATEICON_EDITABLE                  = 4,
    STATEICON_BLANK                     = 5,
    STATEICON_READONLY                  = 6,
    STATEICON_DISABLED                  = 7,
    STATEICON_CHECKEDOUTEXCLUSIVE           = 8, // checked-out exclusively by user
    STATEICON_CHECKEDOUTSHAREDOTHER     = 9, // checked-out shared by someone else
    STATEICON_CHECKEDOUTEXCLUSIVEOTHER  = 10,// checked-out exclusively by someone else
    STATEICON_EXCLUDEDFROMSCC               = 11,
    STATEICON_MAXINDEX                  = 12

} VsStateIcon;

//This is the overlay icon that your ui hierarchy should return
//when asked for VSHPROPID_OverlayIconIndex.  This will be transparently
//drawn on top of your item's normal icon
typedef enum __VSOVERLAYICON
{
    OVERLAYICON_NONE            = 0,
    OVERLAYICON_SHORTCUT        = 1,
    OVERLAYICON_POLICY          = 2,
    OVERLAYICON_CONNECTED       = 3,
    OVERLAYICON_DISCONNECTED    = 4,
    OVERLAYICON_MAXINDEX        = 4 //should be same as last valid overlay
} VSOVERLAYICON;

//----------------------------------------------------------------------------
// This typedef represents a COM object
//----------------------------------------------------------------------------
typedef struct tagCOMREFERENCE
{
    GUID     guidTypelib;
    WORD     wVerMajor;
    WORD     wVerMinor;
} COMREFERENCE, *PCOMREFERENCE;

typedef struct tagCOMREFERENCEINFO
{
    GUID     guidTypelib;      // guid to typelib
    WORD     wVerMajor;        // typelib version #'s
    WORD     wVerMinor;
    LCID     lcidTypelib;      // lcid of typelib
    DWORD    dwLibFlags;       // typelib flags
    BSTR     bstrDescription;  // typelib friendly name
    BSTR     bstrPath;         // full path to typelib file
} COMREFERENCEINFO, *PCOMREFERENCEINFO;

//----------------------------------------------------------------------------
// interface IEnumComReferences
//----------------------------------------------------------------------------
// Implemented by the Environment.
// Enumerator object for COM references.
[
    uuid(uuid_IEnumComReferences),
    version(1.0),
    pointer_default(unique)
]
interface IEnumComReferences : IUnknown
{
    HRESULT Next([in]   ULONG celt, [out, size_is(celt), length_is(*pceltFetched)] PCOMREFERENCE rgRefs, [out] ULONG *pceltFetched);
    HRESULT Skip([in]   ULONG celt);
    HRESULT Reset(void);
    HRESULT Clone([out] IEnumComReferences **ppenum);
};

//----------------------------------------------------------------------------------
//  IVsExtensibleObject
//----------------------------------------------------------------------------------
// Implemented by VsPackages that provide OLE Automation objects.
// This is a general interface that is used in many scenarios where one object provides
// a different object as its Automation IDispatch implementation. 
[
    uuid(uuid_IVsExtensibleObject),
    version(1.0),
    pointer_default(unique)
]
interface IVsExtensibleObject : IUnknown
{
    HRESULT GetAutomationObject(
        [in] LPCOLESTR  pszPropName,
        [out] IDispatch **ppDisp);
}

//----------------------------------------------------------------------------------
//  IVsLanguageInfoPackage
//----------------------------------------------------------------------------------
// Implemented by the Environment.
// Used between the Environment's tools.options code and the text manager for per-language
// pages under the per-language editor settings (for instance "Tabs").
[
    uuid(uuid_IVsLanguageInfoPackage),
    version(1.0),
    pointer_default(unique)
]
interface IVsLanguageInfoPackage: IUnknown
{
    // guidLang is the language service this page is being displayed for
    HRESULT GetLanguagePropertyPage([in] REFGUID rguidPage, [in] REFGUID guidLang, [in, out] VSPROPSHEETPAGE *ppage);
}

//----------------------------------------------------------------------------------
//  IVsSwitchToolWindow
//----------------------------------------------------------------------------------
// OBSOLETE interface.
[
    uuid(uuid_IVsSwitchToolWindow),
    version(1.0),
    pointer_default(unique)
]
interface IVsSwitchToolWindow : IUnknown
{
    HRESULT QueryToolWindow(
        [in] REFGUID guidToolWindow,    // window doing the switching
        [out] GUID * guidToolSwitch);   // replaced contents

    HRESULT GetSwitchedPane(
        [in] REFGUID guidToolSwitch,    // GUID returned by InquireToolWindow
        [in] IVsWindowFrame * pFrame,   // frame containing the pane
        [out] IVsWindowPane ** pPane);  // pane object implementing the pane
};


// Properties ID's for IVsMenuItem::IMISetProp/IMEGetProp and for IMenuEditorSite
// to inform IVsMenuEditor::OnChange() with.
//
//                     IVsMenuItem::
//  Property         Type: IMISetProp - IMIGetProp
//-----------------------------------------------------------
enum __VSMEPROPID
{
    VSMEPROPID_FIRST        = -1000,
    VSMEPROPID_NAME         = -1000, //      VT_BSTR
    VSMEPROPID_CAPTION      = -1001, //      VT_BSTR
    VSMEPROPID_CHECKED      = -1002, //      VT_BOOL
    VSMEPROPID_ENABLED      = -1003, //      VT_BOOL
    VSMEPROPID_VISIBLE      = -1004, //      VT_BOOL
    VSMEPROPID_BOLD         = -1005, //      VT_BOOL
    VSMEPROPID_ACCEL        = -1006, //      VT_I4   - (DWORD)
    VSMEPROPID_RADIOCHECK   = -1007, //      VT_BOOL
    VSMEPROPID_EXTRAPROPS   = -1008,
    VSMEPROPID_BREAK        = -1009,
    VSMEPROPID_BARBREAK     = -1010,
    VSMEPROPID_RIGHTJUSTIFY = -1011,
    VSMEPROPID_LAST         = -1011
};
typedef LONG VSMEPROPID;

// Return values for IVsMenuEditor::GetUIState
enum __VSMEUISTATE
{
    VSMEUISTATE_IDLE        = 0,
    VSMEUISTATE_LABELEDIT   = 1,
    VSMEUISTATE_ACCELEDIT   = 2,
    VSMEUISTATE_ACCELLIST   = 3
};
typedef DWORD VSMEUISTATE;

//----------------------------------------------------------------------------
// interface IVsMenuItem
//----------------------------------------------------------------------------
// Implemented by the Environment.
// Used by form designers that want to use the shared menu editor.
[
    uuid(uuid_IVsMenuItem),
    version(1.0),
    pointer_default(unique)
]
interface IVsMenuItem : IUnknown
{
    [custom(uuid_IVsMenuItem, "preservesig")]
    HRESULT IMISetProp([in]VSMEPROPID PropId, [in]VARIANT var);
    [custom(uuid_IVsMenuItem, "preservesig")]
    HRESULT IMIGetProp([in]VSMEPROPID PropId, [out]VARIANT *pvar);

    // For Setting/Getting properties IVsMenuEditor does not deal with directly.
    //
    // This allows IVsMenuEditor to perform all clipboard operations including
    // unknown properties.  All property values must be written to the IStream
    // Object. If no extra props, then simply return E_NOTIMPL in response to
    // IMIGetExtraPropsSize()
    //
    // IVsMenuEditor includes the SiteId in clipboard data so that an it will not
    // attempt to paste Extra data from one site to another site
    [custom(uuid_IVsMenuItem, "preservesig")]
    HRESULT IMISetExtraProps([in]LPSTREAM pstm);
    [custom(uuid_IVsMenuItem, "preservesig")]
    HRESULT IMIGetExtraProps([in]LPSTREAM pstm);
};

//----------------------------------------------------------------------------
// interface IVsMenuEditor
//----------------------------------------------------------------------------
// Implemented by the Environment.
// Used by form designers that want to use the shared menu editor.
[
    uuid(uuid_IVsMenuEditor),
    version(1.0),
    pointer_default(unique)
]
interface IVsMenuEditor : IUnknown
{
    // pIMIParent and pIMIInsertAfter can be NULL for first item in top level
    // menu.  Otherwise, only pIMIParent or pIMIInsertAfter can be valid
    HRESULT AddMenuItem([in]IVsMenuItem *pIMI,
        [in]IVsMenuItem *pIMIParent,
        [in]IVsMenuItem *pIMIInsertAfter);

    // Must be called by IMenuEditorSite if any property known by IVsMenuEditor
    // changes on any menu item
    HRESULT OnChange([in]IVsMenuItem *pIMI, [in]VSMEPROPID PropId);

    // Called whenever the selection changes. If pIMI is NULL, no menu item
    // is selected.  If Non NULL, it points to the item to be selected.
    // Only one item can be selected at a time from outside MenuDesinger.
    // This method does NOT set focus to the item; see the SetFocus method
    // below for that behavior.
    HRESULT SelectionChange([in]IVsMenuItem *pIMI);

    // Called to obtain the bounding rect for or a specific menu item
    // (pmi != NULL) or the bounding rect for all currently displayed
    // menu windows (pmi == NULL).
    //
    // fForScrolling = TRUE if getting an item rect for the purposes of
    // scrolling it into view, in this case the Designer includes the
    // items Popup rect and next item rect since these items may not yet
    // be know by the Site, and thus no way to obtain their rects for
    // making them visible.
    HRESULT GetItemRect([in]IVsMenuItem* pIMI, [out]LPRECT prc, [in]BOOL fForScrolling);

    // Can be used by the site to change the size of the host when the user
    // wishes to remove the menu.  This allows the Site an easy way to
    // determine how much to decrease the size of the host by.
    HRESULT GetHeight([out]INT *piHeight);

    // Should be the first thing called in the Destination windows WNDPROC
    // to allow the Menu designer to process a few selected messages required
    // to correctly position, paint, and activate the menus, since the menus
    // occupy NonClient space:
    //
    //  WM_NCHITTEST
    //  WM_NCCALCSIZE
    //  WM_NCPAINT
    //  WM_MOVE
    //
    // If Filter() returns S_OK, Destination window should return *plResult
    [custom(uuid_IVsMenuEditor, "preservesig")]
    HRESULT Filter([in]HWND hwnd, [in]UINT uMsg, [in]WPARAM wParam, [in]LPARAM lParam, [out]LRESULT *plResult);

    HRESULT IsActive([out, retval]BOOL *pfActive);

    // Returns the current UI state of the Menu Editor, giving the site a
    // mechanism to know if the ME has any UI operations in progress.
    HRESULT GetUIState([out, retval] VSMEUISTATE *pState);

    HRESULT DeleteMenuItem([in]IVsMenuItem *pIMI);

    // Same as SelectionChange, except this method also sets focus to the
    // selected item.
    HRESULT SelectionChangeFocus([in]IVsMenuItem *pIMI);

    // Allow the edit control to catch keystrokes just like an activex control
    HRESULT TranslateAccelerator([in]LPMSG lpMsg);
};

//----------------------------------------------------------------------------
// IMenuEditorSite
//----------------------------------------------------------------------------
// Implemented by form designers that want to use the shared menu editor.
//
// SelectionChange() commands
// NOTE: SelectionChange() takes an array of IVsMenuItem's, BUT, only supports
//   an receiving an array of IVsMenuItem's if the sel command is
//   SELCMD_SELCHANGE, since you cannot view code or properties for
//   multiple items
typedef enum __VSMESELCMD
{
    SELCMD_SELCHANGE  = 0,	// Default, just a selection change
    SELCMD_VIEWCODE   = 1,	// View code for specified item
    SELCMD_PROPERTIES = 2,  // View properties for specified item
    SELCMD_VIEWCODEDOUBLECLICK = 3, // a double click was used for view code
    SELCMD_ENTEREDIT = 4,   // Entering edit mode
    SELCMD_LEAVEEDIT = 5   // Leaving edit mode
} VSMESELCMD;

cpp_quote("#define ME_UNKNOWN_MENU_ITEM ((IVsMenuItem*)(INT_PTR)-1)")
cpp_quote("#define ME_FIRST_MENU_ITEM   ((IVsMenuItem*)(INT_PTR)-2)")

[
    uuid(uuid_IVsMenuEditorSite),
    version(1.0),
    pointer_default(unique)
]
interface IVsMenuEditorSite : IUnknown
{
    // The host is responsible for giving the menu a unique name, and providing
    // back to IVsMenuEditor a valid IVsMenuItem*.
    //
    // As in IVsMenuEditor::AddItem, both pIMIParent and pIMIInsertAfter can be NULL.
    // But only one or the other can be Non NULL.
    HRESULT CreateItem([in]IVsMenuItem    *pIMIParent,
        [in]IVsMenuItem   *pIMIInsertAfter,                 
        [out]IVsMenuItem **ppIMINew);

    // Deletes the given item.  if pIMI == NULL, the Site MUST delete its
    // entire menu structure
    HRESULT DeleteItem([in]IVsMenuItem *pIMI);

    // Moves 1 or more menu items to a new location.  If moving only one item,
    // pIMILast == pIMIFirst.  Both pIMIParent and pIMIInsertAfter can be
    // NULL, but only one or the other can be Non NULL.
    // NOTE: If moving more than one item (pIMIFirst != pIMILast), the items
    //     WILL be consective items.  Movement of non consecutive items is
    //     supported
    HRESULT MoveItems([in]IVsMenuItem   *pIMIFirst,
        [in]IVsMenuItem *pIMILast,
        [in]IVsMenuItem *pIMIParent,
        [in]IVsMenuItem *pIMIInsertAfter);

    // Called when the selection changes. If ppIMI is NULL, no items are selected
    // If Non NULL, it points to a NULL terminated array of IVsMenuItem*'s
    // which make up the new selection
    HRESULT SelectionChange([in]IVsMenuItem **ppIMI, [in]VSMESELCMD SelCmd);
};

// NOTE:  On VSMEPROPID_ACCEL:
//    If accel support is requested AND given a fixed list of accelerators
// the DWORD is a zero based index into this list
//    If Accel support is requested, and a fixed list of accelerators is NOT
// provided, the DWORD contains the same info as would an actual ACCEL struct
// minus the "cmd" field, since the Site will already know this info. So, the
// format of the DWORD is as follows:
//
//    The LOBYTE(HIWORD(dw)) will contain the "fVirt" field of an ACCEL struct
//    The LOWORD(dw) will contain the "key" field of the an ACCEL struct

//----------------------------------------------------------------------------
// Init struct for IVsMenuEditor

// MEINIT dwFlag values
enum __VSMEINIT
{
    MD_ACCELSUPPORT         = 0x00000001,   // first value should be one,
    MD_VISIBLESUPPORT       = 0x00000002,   // following values should use
    MD_BOLDSUPPORT          = 0x00000004,   // consecutive powers of two
    MD_CONTEXTMENU          = 0x00000008,   //
    MD_RADIOCHECKSUPPORT    = 0x00000010,   //
    MD_COMMANDIDSUPPORT     = 0x00000020,   // << Means NO Control names!  Like VC
    MD_VIEWCODESUPPORT      = 0x00000040,   // Supports the ViewCode cmd
    MD_NOPROPERTIESSUPPORT  = 0x00000080,   // Does not support the Properties cmd
    MD_TEXTLIMIT            = 0x00000100,   // Use the MEINIT dwTextLimit field
    MD_TOPLEVELSEPSUPPORT   = 0x00000200,   // Allow separators on the top-level menu
    MD_EDITIDSNOTEDITNAMES  = 0x00000400,   // Menu item "Edit Names" is displayed as "Edit ID's"
    MD_NAMELIMIT            = 0x00000800,   // Use the MEINIT dwNameLimit field
    MD_NOUNDOSUPPORT        = 0x00001000,   // Do not store undo information, even if passed an undo manager
    MD_BOTTOMDOCKED         = 0x00002000,   // this menu should dock on the bottom and popups should cascade upward.
    MD_BREAKSUPPORT         = 0x00004000,   // Supports the break and barbreak flags on menu items
    MD_RIGHTJUSTIFYSUPPORT  = 0x00008000    // Supports the right justification of menu bar items (moves all to the right of the bar)
};
typedef DWORD VSMEINIT;

typedef struct tagMenuEditorInit
{
    DWORD             dwSizeOfStruct;
    IVsMenuEditorSite *pMenuEditorSite;
    IServiceProvider  *pSP;
    IOleUndoManager   *pUndoMgr;
    GUID      SiteId;       // Unique Id for identifying extra data in clipboard operations
    HWND      hwnd;         // Destination window for menu
    HWND      hwndParent;   // Parent of destination window, since it may not be GetParent()
    VSMEINIT  dwFlags;      // Flags for support/no support of certain props
    LPCSTR    pszAccelList; // Fixed list of acceptable accelerators (eg.
    //  "Ctrl+A\0Ctrl+B\0...\0Alt+Bksp\0\0")
    //  Double NULL terminated.
    //  If all accelerators are allowed then
    //  pszEnumString may be NULL.
    DWORD     cchTextLimit; // Text limit for menu item captions, default is 256 chars.  This
    //  field is only used if the MD_TEXTLIMIT flag is passed.
    DWORD     cchNameLimit; // Name limit for menu name/id's, default is 256 chars.  This
    //  field is only used if the MD_NAMELIMIT flag is passed.
} MEINIT;

//----------------------------------------------------------------------------
//  interface IVsMenuEditorFactory
//----------------------------------------------------------------------------
// Implemented by the Environment.
// Used by form designers that want to use the shared menu editor.
[
    uuid(uuid_IVsMenuEditorFactory),
    version(1.0),
    pointer_default(unique)
]
interface IVsMenuEditorFactory : IUnknown
{
    HRESULT CreateMenuEditor([in]MEINIT *pMEInit, [out]IVsMenuEditor** ppME);
};

cpp_quote("#define SID_SVsMenuEditor IID_IVsMenuEditorFactory")

//----------------------------------------------------------------------------
// IVsIntelliMouseHandler
//----------------------------------------------------------------------------
// Implemented by the Environment.
// Used to expose IntelliMouse functionality to clients of the shell who are implementing
// some of their own functionality.
[
    uuid(uuid_IVsIntelliMouseHandler),
    version(1.0),
    pointer_default(unique)
]
interface  IVsIntelliMouseHandler : IUnknown
{
    HRESULT IsMouseWheelRotationMessage([in] UINT msg);
    HRESULT HandleWheelRotation([in] HWND hwnd, [in] WPARAM wp, [in] DWORD dwStyle);
    HRESULT HandleWheelButtonDown([in] HWND hwnd, [in] DWORD dwStyle);
    HRESULT MouseWheelPresent(void);
    HRESULT SetMouseCursor_([in] POINT ptOrg,  [in] POINT   ptNew,  [in] UINT  idCurOrg,  [in] UINT uNeutralRadius);
    HRESULT LoadBitmap_([in] HWND hwnd,  [in] UINT idbmp,  [in] UINT idcur, [in] POINT ptOrg, [in] DWORD* lpPanBitmap);
    HRESULT DrawBitmap_([in] DWORD* lpPanBitmap, [in] BOOL fErase);
    HRESULT GetMouseWheelMsg_([out] UINT *uMsg);
    HRESULT DeleteBitmap_([in] DWORD* lpPanBitmap);
};

cpp_quote("#define SID_SVsIntelliMouseHandler IID_IVsIntelliMouseHandler")

//----------------------------------------------------------------------------
// IVsCodeShareHandler
//----------------------------------------------------------------------------
// Implemented by the Environment. Used internally.
[
    uuid(uuid_IVsCodeShareHandler),
    version(1.0),
    pointer_default(unique)
]
interface  IVsCodeShareHandler : IUnknown
{
    HRESULT DlgInit([in] HWND hwnd);
    HRESULT VBDialogBoxParam([in] HINSTANCE hinst, [in] DWORD dwId, [in] DWORD* pFARPROC, LPARAM lp);
    HRESULT VBDialogCover([in] DWORD* pFARPROC, [in] DWORD* lpvoid, [out] HWND* lphwndParent);
    HRESULT VsGetOpenFileName([in] DWORD* pOPENFILENAMEA, [in] LONG dwHelpTopic);
    HRESULT GetStdHelp([in] UINT wCmd, [in] LONG lContext);
};

cpp_quote("#define SID_SVsCodeShareHandler IID_IVsCodeShareHandler")

//----------------------------------------------------------------------------
// IVsWindowPaneCommit
//----------------------------------------------------------------------------
// Implemented by VSFPROPID_DocView object sited in a WindowFrame.
// The Environment calls CommitPendingEdit before any command is Exec'ed.
// e.g. This allows a window to commit pending edits in a control with focus 
// before another command is invoked. This method is called with very frequent
// granularity. A related interface that is called with a coarse granularity
// is IVsBatchUpdate::FlushPendingUpdates. This is called before save operations
// and times when projects or other consumers want to extract data from a TextBuffer.
[
    uuid(uuid_IVsWindowPaneCommit),
    version(1.0),
    pointer_default(unique)
]
interface IVsWindowPaneCommit : IUnknown
{
    HRESULT CommitPendingEdit([out] BOOL *pfCommitFailed);
}

// copy in ifhost.idl... make sure to update.
typedef struct __VsPropertyBrowserState {
    DWORD cbSize;           // size of the VsPropBrsState struct (for plug&play)
    BOOL fShowStatus;       // is status pane visible
    ULONG cStatusHeight;    // count of lines displayed in status pane
    BOOL fOutline;          // show categorized outline view
    ULONG customColors[16]; // custom colors chosen.
} VsPropertyBrowserState;

//----------------------------------------------------------------------------
// IVsPropertyBrowser
//----------------------------------------------------------------------------
// Implemented by the Environment.
[
    uuid(uuid_IVsPropertyBrowser),
    version(1.0),
    pointer_default(unique)
]
interface IVsPropertyBrowser : IUnknown
{
    HRESULT GetState([in, out] VsPropertyBrowserState * pState); // struct is caller-allocated
    HRESULT SetState([in] const VsPropertyBrowserState * pState);
}

typedef enum __VSCMDNAMEOPTS
{
    CNO_GETENU    = 0,      // Get the English canonical name
    CNO_GETLOC    = 1,      // Get the localized canonical name
    CNO_GETBOTH   = 2       // Get both English and localized
} VSCMDNAMEOPTS;

//----------------------------------------------------------------------------
// IVsUIHierWinClipboardHelper
//----------------------------------------------------------------------------
// Implemented by the Environment.
// This interface is used to coordinate clipboard operations between hierarchies
// in a UIHierarchyWindow.  Any hierarchy that wishes to coordinate its clipboard
// operations with other hierarchies should implement IVsUIHierWinClipboardHelperEvents,
// and register its interest in the clipboard events with AdviseClipboardHelperEvents.
//
// Here's how a typical cut/paste sequence would work:
//
// 1) The user performs a cut of project item from a project.
//
// 2) The source project creates an IDataObject containing the data for the cut project items.
//    The source project needs to communicate to the destination project the nature of the source
//    project--i.e., whether it is a "referenced-based" or a "storage-based" project. Generally
//    a "storaged-based" project is one that will physically delete the storage for the item
//    on a MOVE operation. A "referenced-based" project will only delete its reference to the
//    storage of the item but leave the storage for the item intact. The nature of the source
//    project is communicated based on the clipboard format used: a "reference-based" project
//    uses CF_VSREFPROJECTITEMS, a "storage-based" project uses CF_VSSTGPROJECTITEMS format.
//    In addition to passing the IDataObject to OLE, the source project passes it to the environment
//    via the Cut method on the IVsUIHierWinClipboardHelper interface.  The source project then dims
//    the appearance of the cut item using IVsUIHierarchyWindow::ExpandItem and either the
//    EXPF_CutHighlightItem or EXPF_AddCutHighlightItem flag as appropriate.
//
// 3) The user performs a paste of the project item.
//
// 4) The destination project handles the contents of the IDataObject, and then communicates
//    that a paste occurred by calling the Paste method on the IVsUIHierWinClipboardHelper interface.
//    On this call the destination project specifies either DROPEFFECT_MOVE or DROPEFFECT_LINK
//    depending on the appropriate type of Cut/Paste operation that should be performed.
//    The destination project is the one that has enough information to determine whether a MOVE or
//    a LINK operation should be performed. The destination project knows the nature of the
//    source project based on whether CF_VSREFPROJECTITEMS or CF_VSSTGPROJECTITEMS format was offered.
//    It also inherently knows whether itself is "reference-based" or "storage-based". The following
//    table shows what operation should be performed based on the nature of the source and destination:
//
//                                Reference-based Target | Storage-based Target
//                               ------------------------+---------------------
//        Reference-based Source:         MOVE           |          MOVE
//        Storage-based Source  :         LINK           |          MOVE
//
// 5) When its Paste method is called, the IVsUIHierWinClipboardHelper interface iterates through its
//    list of interested listeners and calls the OnPaste method on each.  When the source project
//    gets called in this way, if DROPEFFECT_MOVE is specifed, it should complete the cut by removing
//    the cut item from itself ;otherwise the source project should un-dim the item using
//    IVsUIHierarchyWindow::ExpandItem and the EXPF_UnCutHighlightItem flag.
//
// The IVsUIHierWinClipboardHelper interface is also a clipboard watcher, so when the contents of
// the clipboard change, and the cut IDataObject is no longer on the clipboard, the OnClear method of
// each listener will be called so that the cut item can be undimmed using IVsUIHierarchyWindow::ExpandItem
// and the EXPF_UnCutHighlightItem flag.
//
// In a copy situation, of course, the item need not be dimmed since it has not been cut.
//----------------------------------------------------------------------------

// Clipboard formats registered and used by the Environment
cpp_quote("#define WSTR_CF_VSREFPROJECTS     L\"CF_VSREFPROJECTS\"")
cpp_quote("#define WSTR_CF_VSSTGPROJECTS     L\"CF_VSSTGPROJECTS\"")
cpp_quote("#define WSTR_CF_VSREFPROJECTITEMS L\"CF_VSREFPROJECTITEMS\"")
cpp_quote("#define WSTR_CF_VSSTGPROJECTITEMS L\"CF_VSSTGPROJECTITEMS\"")

cpp_quote("#define CF_VSREFPROJECTS     (RegisterClipboardFormatW(WSTR_CF_VSREFPROJECTS))")
cpp_quote("#define CF_VSSTGPROJECTS     (RegisterClipboardFormatW(WSTR_CF_VSSTGPROJECTS))")
cpp_quote("#define CF_VSREFPROJECTITEMS (RegisterClipboardFormatW(WSTR_CF_VSREFPROJECTITEMS))")
cpp_quote("#define CF_VSSTGPROJECTITEMS (RegisterClipboardFormatW(WSTR_CF_VSSTGPROJECTITEMS))")

[
    uuid(uuid_IVsUIHierWinClipboardHelper),
    version(1.0),
    pointer_default(unique)
]
interface IVsUIHierWinClipboardHelper : IUnknown
{
    HRESULT Cut([in] IDataObject *pDataObject);
    HRESULT Copy([in]   IDataObject *pDataObject);
    HRESULT Paste([in] IDataObject *pDataObject, [in]   DWORD dwEffects);
    HRESULT AdviseClipboardHelperEvents([in] IVsUIHierWinClipboardHelperEvents *pSink, [out] VSCOOKIE   *pdwCookie);
    HRESULT UnadviseClipboardHelperEvents([in] VSCOOKIE dwCookie);
}

cpp_quote("#define SID_SVsUIHierWinClipboardHelper IID_IVsUIHierWinClipboardHelper")

//----------------------------------------------------------------------------
// IVsUIHierWinClipboardHelperEvents
//----------------------------------------------------------------------------
// Implemented by IVsHierarchy implementations using the IVsUIHierWinClipboardHelper.
// All projects in the Solution Explorer must implement this if they particpate in cut/copy/paste.
[
    uuid(uuid_IVsUIHierWinClipboardHelperEvents),
    version(1.0),
    pointer_default(unique)
]
interface IVsUIHierWinClipboardHelperEvents : IUnknown
{
    // The arguments to these   methods are to be used essentially the same
    // as   the arguments to IVsHierarchyDropDataSource::OnDropNotify.
    HRESULT OnPaste([in] BOOL   fDataWasCut, [in] DWORD dwEffects);
    HRESULT OnClear([in] BOOL   fDataWasCut);
}

//----------------------------------------------------------------------------
// IVsHierarchyDeleteHandler
//----------------------------------------------------------------------------
// This interface is optional and is retrieved via QI from IVsHierarchy.  This interface supports
// implementation of the cmdidDelete command.  It is implemented by hierarchies that want to
// control the delete/remove semantics for their hierarchy contents. Hierarchies can optionally
// support both destructive, "DeleteFromStorage" semantics and non-destructive, "RemoveFromProject"
// semantics on a per item basis.  The UIHierarchyWindow handles the cmdidDelete command--to remove
// or delete an item the UIHierarchyWindow calls QueryDeleteItem/DeleteItem with appropriate op.

enum __VSDELETEITEMOPERATION
{
    DELITEMOP_DeleteFromStorage =   1,   // Physically delete item--valid for VSITEMID_ROOT.
    DELITEMOP_RemoveFromProject =   2,   // Do not physically delete item--not valid for VSITEMID_ROOT.
};
typedef DWORD VSDELETEITEMOPERATION;

[
    uuid(uuid_IVsHierarchyDeleteHandler),
    version(1.0),
    pointer_default(unique)
]
interface IVsHierarchyDeleteHandler : IUnknown
{
    HRESULT QueryDeleteItem([in] VSDELETEITEMOPERATION dwDelItemOp,
        [in] VSITEMID   itemid, // VSITEMID_ROOT to delete all--VSITEMID_SELECTION is not suppported.
        [out,   retval] BOOL *pfCanDelete);
    HRESULT DeleteItem([in] VSDELETEITEMOPERATION   dwDelItemOp,
        [in] VSITEMID itemid);      // VSITEMID_ROOT to delete all--VSITEMID_SELECTION is not suppported.
}


[
    //----------------------------------------------------------------------------
    //  interface IVsCmdNameMapping
    //----------------------------------------------------------------------------
    // Implemented by the Environment.
    uuid(uuid_IVsCmdNameMapping),
    version(1.0),
    pointer_default(unique)
]
interface IVsCmdNameMapping : IUnknown
{
    HRESULT MapGUIDIDToName ([in] const GUID *pguidCmdGroup, [in] DWORD dwCmdID, [in] VSCMDNAMEOPTS grfOptions, [out] BSTR *pbstrCmdName);
    HRESULT MapNameToGUIDID ([in] const LPCOLESTR pszCmdName, [out] GUID *pguidCmdGroup, [out] DWORD *pdwCmdID);
    HRESULT EnumNames ([in] VSCMDNAMEOPTS grfOptions, [out, retval] IEnumString **ppEnumString);
    HRESULT GetLastUpdated ([out, retval] DWORD *pdwTickCount);
    HRESULT EnumMacroNames ([in] VSCMDNAMEOPTS grfOptions, [out, retval] IEnumString **ppEnumString);
}

cpp_quote("#define SID_SVsCmdNameMapping IID_IVsCmdNameMapping")



//----------------------------------------------------------------------------
//  interface IVsParseCommandLine
//----------------------------------------------------------------------------
// Implemented by the Environment. 
// This is a helper service used by IOleCommandTarget implementations for commands 
// that take arguments.

cpp_quote("#define PCL_AUTO_COMMANDS   -1")

[
    uuid(uuid_IVsParseCommandLine),
    version(1.0),
    pointer_default(unique)
]
interface IVsParseCommandLine : IUnknown
{
    HRESULT ParseCommandLine([in, ref] LPCOLESTR szCommandLine, 
        [in] int iMaxParams, [in] int iCursorPos);
    HRESULT ParseCommandTail([in, ref] LPCOLESTR szCommandTail, [in] int iMaxParams);

    HRESULT HasParams();
    HRESULT HasSwitches();
    HRESULT HasSwitchValues();

    HRESULT GetParamCount([out, retval] int* piParamCount);
    HRESULT GetSwitchCount([out, retval] int* piSwitchCount);
    HRESULT GetSwitchValueCount([out, retval] int* piSwitchValueCount);

    HRESULT SwitchHasValue([in] int iIndex);

    HRESULT GetCommand([out, retval] BSTR* pbstrCommand);
    HRESULT GetParam([in] int iIndex, [out, retval] BSTR* pbstrParam);
    HRESULT GetRawSwitch([in] int iIndex, [out, retval] BSTR* pbstrRawSwitch);
    HRESULT GetRawSwitchValue([in] int iIndex, [out, retval] BSTR* pbstrRawSwitchValue);
    HRESULT GetCommandTail([out, retval] BSTR* pbstrCommandTail);

    HRESULT GetACParam([out] int* piACIndex, [out] int* piACStart, 
        [out] int* pcchACLength, [out, retval] BSTR* pbstrACParam);

    HRESULT RejectAllSwitches();
    HRESULT ValidateParamCount([in] int cParamsMin, [in] int cParamsMax);

    HRESULT EvaluateSwitches([in,   ref] LPCOLESTR szSwitchDefs);

    HRESULT IsSwitchPresent([in] int iSwitchIndex);
    HRESULT GetSwitchValue([in] int iSwitchIndex,   [out, retval] BSTR* pbstrValue);

    HRESULT QuoteParam([in] LPCOLESTR   szParam, [out, retval] BSTR* pbstrQuotedParam);
};

cpp_quote("#define SID_SVsParseCommandLine IID_IVsParseCommandLine")

[
    //----------------------------------------------------------------------------
    //  interface IVsTextOut
    //----------------------------------------------------------------------------
    // Implemented by the Environment.
    // Unicode text measurement and display.
    //
    // Exposes the core editor's extended Unicode text measurement and display
    // functionality.  Compensates for defects in the Win9x W text APIs.
    local,
    uuid(uuid_IVsTextOut),
    version(1.0)
]
interface IVsTextOut : IUnknown
{
    HRESULT VsGetTextExtent (
        [in] DWORD_PTR                  hdc,
        [in] int                        cch,    // # chars, or -1 if nul-terminated
        [in, size_is(cch)] LPCOLESTR    pText,
        [out, retval] SIZE *            pSize
        );

    HRESULT VsTextOut (
        [in] DWORD_PTR                  hdc, 
        [in] int                        cch,    // # chars, or -1 if nul-terminated
        [in, size_is(cch)] LPCOLESTR    pText, 
        [in] DWORD                      grfETO, // ExtTextOut flags
        [in] int                        x, 
        [in] int                        y, 
        [in] const RECT *               prc
        );

};
cpp_quote("#define SID_SVsTextOut IID_IVsTextOut")

//----------------------------------------------------------------------------
// IVsCommandWindow
//----------------------------------------------------------------------------
// Implemented by the Enviroment on the Command Window tool window.

// These are useful constants for working with commands
cpp_quote("#define UCH_CMDPREFIX (L'>')")
cpp_quote("#define USZ_CMDPREFIX (L\">\")")


typedef enum __PREPARECOMMANDRESULT
{
    PC_SUCCESS = 0,
    PC_NOCOMMAND,             // No command name was specified
    PC_NOTFOUND,              // The name did not match any known command
    PC_NOTAVAILABLE,          // The command is disabled
    PC_PARAMSNOTACCEPTED,     // Parameters were specified, and the command does not
    // accept   parameters
    PC_FAILURE            // Failure not attributable to one of the above causes
} PREPARECOMMANDRESULT;

typedef enum __COMMANDWINDOWMODE
{
    CWM_IMMEDIATE   = 0,    // Immediate mode 
    CWM_COMMAND             // Command mode
} COMMANDWINDOWMODE;

typedef enum __LOGTOFILEOPTION
{
    LTFO_APPEND   = 0x00000000,     // Append to specified file
    LTFO_OVERWRITE  =   0x00000001,     // Overwrite specified file
    LTFO_VALIDMASK  =   0x00000001      // [Union of all valid bits]
} LOGTOFILEOPTION;
typedef DWORD LOGTOFILEOPTIONS;

[
    uuid(uuid_IVsCommandWindow),
    version(1.0),
    pointer_default(unique)
]
interface IVsCommandWindow : IUnknown
{
    // ExecuteCommand() executes the specified command. If the specified command
    // is   invalid, disabled, etc., ExecuteCommand() will report the error to the
    // user and return S_OK.
    //
    // Note that ExecuteCommand()   returns control to the caller *before* the command
    // has actually been executed.  ExecuteCommand() merely posts   a Windows
    // message.  When   that message is received by the shell, it executes the
    // command.  If an error occurs during the execution of the command, the shell
    // will report it   to the user.
    HRESULT ExecuteCommand([in, ref] LPCOLESTR szCommand);

    // PrepareCommand() performs all the steps of   preparing to execute a Command
    // Line command.    It parses the command string, looks up the command, verifies
    // that it is   enabled, determines whether it accepts parameters, prepares a
    // VARIANT containing   the parameters, etc.  Upon return the caller has all the
    // information needed   to call IOleCommandTarget::Exec().
    //
    // PrepareCommand() returns S_OK on success.    On failure, it returns E_FAIL
    // and sets *pResult to a   value of type PrepareCommandResult indicating the
    // nature   of the failure.  This allows the caller to customize the way the
    // various errors   are reported to the user.  Also on failure the thread error
    // info is set with a   meaningful string.  The routine can also return other
    // standard errors like E_OUTOFMEMORY, E_INVALIDARG, etc.
    //
    // If   PrepareCommand() returns a VARIANT via ppvaCmdArg, the caller owns that
    // data. To free it, the caller must first call VariantClear() to   clear the
    // contents, then   call CoTaskMemFree() to free the VARIANT itself.
    HRESULT PrepareCommand(
        [in, ref] LPCOLESTR szCommand, 
        [out] GUID* pguidCmdGroup, 
        [out] DWORD* pdwCmdId, 
        [out] VARIANT** ppvaCmdArg, 
        [out, retval] PREPARECOMMANDRESULT* pResult);

    // Creates the tool window and text buffer for the Command Window
    HRESULT Create();

    // Makes the Command Window visible and sets focus to   it.  This will also
    // create   the Command Window, if necessary.
    HRESULT Show();

    // Print() prints   the specified text to the Command Window.  The Command Window
    // will be shown if it is   not already visible.
    HRESULT Print([in, ref] LPCOLESTR   szTextToPrint);

    // EchoCommand() echos the specified command to the Command Window the next
    // time any text is printed into the Command Window via Print().    This allows a
    // command that was entered on the Command Line to be   echoed into the Command
    // Window   above its results (iff it prints any results)
    HRESULT EchoCommand([in, ref]   LPCOLESTR szCommand);

    // Sets the Command Window to   Immediate mode or Command mode.  The mode
    // argument must be either CWM_IMMEDIATE or CWM_COMMAND.    Refer to the
    // Command Line spec for descriptions   of these modes of operation.
    HRESULT SetMode([in] COMMANDWINDOWMODE mode);

    // Starts   logging Command Window commands and output to the specified file.
    HRESULT LogToFile([in, ref] LPCOLESTR   szLogFile, [in] LOGTOFILEOPTIONS grfFlags);

    // Stops logging started with   LogToFile().
    HRESULT StopLogging();

    // Informs the Command Window   of the language service that applies to the
    // current debugging context.    This is called by the debugger whenever the
    // active   language changes.
    HRESULT SetCurrentLanguageService([in] REFGUID rguidLanguageService);

    // Indicates whether a command that was invoked through the Command Window 
    // is   currently being executed.
    HRESULT RunningCommandWindowCommand([out,   retval] BOOL* pfCmdWin);

    // Does the same thing as   Print(), but does not show or activate the Command Window
    HRESULT PrintNoShow([in, ref]   LPCOLESTR szTextToPrint);
};


//----------------------------------------------------------------------------
// IVsThreadSafeCommandWindow
//----------------------------------------------------------------------------
// Implemented by the Environment.
// This is a thread-safe subset of IVsCommandWindow.  All these methods do is
// post commands that are handled on the main thread, which then calls the
// regular handlers.
[
    uuid(uuid_IVsThreadSafeCommandWindow),
    version(1.0)
]
interface IVsThreadSafeCommandWindow : IUnknown
{
    // Like IVsCommandWindow::PrintNoShow, but may be   called on any thread
    HRESULT ThreadSafePrintNoShow([in, ref] LPCOLESTR   szTextToPrint);
};


//---------------------------------------------------------------------------------
// IVsCommandArgInfo
//---------------------------------------------------------------------------------
// Implemented by the Environment.
// This interface is supported by the SVsCommandWindow service. It enables an
// IOleCommandTarget::QueryStatus implementation to query whether a command argument
// has been supplied. A command argument can be supplied when commands are executed
// via the Command Window, Command Line/Find Tool, or DTE.ExecuteCommand
// (programmatically, through the ExecuteCommand method of IVsCommandWindow). Some
// command handlers (e.g. a project system handling GotoDefinition) can only support
// a command if an argument has been supplied.
//
// These methods give valid results only if called from a QueryStatus handler.  In
// IOleCommandTarget::Exec the argument can be obtained from the pvaIn parameter.
[
    uuid(uuid_IVsCommandArgInfo),
    version(1.0)
]
interface IVsCommandArgInfo : IUnknown
{
    // Returns TRUE if a non-empty command argument was supplied for this   command
    HRESULT QueryCommandArgAvailable([out] BOOL* pfCmdArgAvailable);

    // Returns the argument string
    HRESULT GetCommandArg([out] BSTR*   pbstrCmdArg);
}


cpp_quote("#define SID_SVsCommandWindow IID_IVsCommandWindow")


/*************************************************************************************
//
//  NOTE - IVsTshell and IVsTestLog are internal interfaces used for testing purposes
//         only
//
*************************************************************************************/


//----------------------------------------------------------------------------
// IVsTestLog
//----------------------------------------------------------------------------
// DO NOT USE. internal interface used for testing purposes only.
[
    uuid(uuid_IVsTestLog),
    version(1.0),
    pointer_default(unique)
]
interface IVsTestLog : IUnknown
{
    // pszIdle format: ID<TAB>Idle Time in Seconds<TAB>Idle Start Time<TAB>String ID
    HRESULT LogIdleTime ([in] LPSTR pszIdle);
}

cpp_quote("#define SID_SVsTestLog IID_IVsTestLog")



typedef DWORD PFN_TSHELL_TMP;
//typedef char TSHELL_CHAR;
//----------------------------------------------------------------------------
// Necessary to get our function ptr and char's through MIDL
//----------------------------------------------------------------------------
cpp_quote("typedef HRESULT (*PfnTshell)(unsigned argc, char **rgsz);")
cpp_quote("#define PFN_TSHELL_TMP PfnTshell")
//cpp_quote("#define TSHELL_CHAR char")


typedef struct __TSHELL_CMD {
    LPSTR szName;
    PFN_TSHELL_TMP pfn;  // return E_INVALIDARG if args invalid
    LPSTR szDescription;
} TSHELL_CMD;

// Type values for IVsTshell::GetTestData
typedef enum __VSTDTYPE
{
    VSTDT_PIC           = 0x00000001,   //pguidData and pdwData must be valid, ppvData must be non-NULL
    VSTDT_PITB      = 0x00000002,   //pguidData and pdwData must be valid, ppvData must be non-NULL
    VSTDT_PITBS     = 0x00000003,   //ppvData must be non-NULL
    VSTDT_PICDATA       = 0x00000004,   //ppvData must be valid, pguidData and pdwData must be non-NULL
    VSTDT_PITBDATA  = 0x00000005    //ppvData must be valid, pguidData and pdwData must be non-NULL
} VSTDTYPE;

[
    //----------------------------------------------------------------------------
    //  interface IVsTshell
    //----------------------------------------------------------------------------
    // DO NOT USE. internal interface used for testing purposes only.
    local,
    uuid(uuid_IVsTshell),
    version(1.0),
    pointer_default(unique)
]
interface IVsTshell: IUnknown
{
    // output the string into the immediate window/ log file/ ..
    // according to the setting in the Shell's debug options    
    HRESULT DebOutputStringW([in] LPCOLESTR pwsz);
    HRESULT DebOutputStringA([in] LPSTR psz);

    HRESULT AddCmdTable ([in] UINT cCmd, [in, size_is (cCmd)] const TSHELL_CMD rgpCmd[]);

    /*  The GetValue() API is used in conjunction with the TshSetVal command, and allows a
    component to access a value (which can be a string and/or integer) that is set
    from a test-command.
    The Tshell keeps a table with these key/value pairs.

    This can be used to for example store the name of a file under a key (such as "OpenFileDlg"),
    then execute a command that shows the dialog, and in the dialog-proc try to
    read the value for this key, and if it exists then do the same as if the user had selected this file.
    */
    // Tshell keeps ownership of *ppszVal - if you need to hold on to this string, you need to
    // copy it
    HRESULT GetValue ([in] LPSTR pszKey, [out] UINT *piVal, [out] LPSTR *ppszVal);

    HRESULT SetValue ([in] LPSTR pszKey, [in]  UINT iVal, [in] LPSTR pszVal);
    HRESULT DeleteValue ([in] LPSTR pszKey);
    HRESULT IsExecutingScript([out] BOOL* pfRunScript);
    HRESULT ExecuteTestCommand(LPSTR szCommandLine);
    HRESULT SetVSLoggingInterface ([in] IVsTestLog *pVsTestLog);
    HRESULT GetTestData ([in] VSTDTYPE dwType, [in, out] GUID *pguidData, [in, out] DWORD *pdwData, [in, out] void **ppvData);

    // SetBreakTransitionComplete is called by the debugger, when the transition to 
    // break mode has been completed.  At this point, all windows have been properly
    // updated and the debugger is in break mode.
    HRESULT SetBreakTransitionComplete([in] BOOL bTransitionComplete);

}

cpp_quote("#define SID_SVsTshell IID_IVsTshell")

/*************************************************************************************
// end of internal interface IVsTshell
*************************************************************************************/

//----------------------------------------------------------------------------
// IVsPropertyPageFrame
//----------------------------------------------------------------------------
// Implemented by the Environment on the Property Page Frame Window.
// Use this if you want the property pages to show an initial page or dispid
// as active.  Otherwise, just let the shell handle cmdidPropertyPages
[
    uuid(uuid_IVsPropertyPageFrame),
    version(1.0),
    pointer_default(unique)
]
interface IVsPropertyPageFrame: IUnknown
{

    //If you call   ShowFrame, it will activate the property page that matches
    //the   clsid you pass in.
    HRESULT ShowFrame(CLSID clsidInitialPage);

    HRESULT HideFrame();    //call this if something fails (like update) so we won't keep trying
    //to show the same objects that have errors
    HRESULT Update();
    HRESULT CanShowPropertyPages([out, retval]BOOL *pbCanShow);

    //Call this instead of the normal   UI shell ReportError if the error came
    //from one of   the above routines.  This will only show the error if
    //the   error info is set, so components that are not errorinfo aware
    //who   put up their own errors for say an apply and then return E_FAIL,
    //won't have two error messages pop up.
    HRESULT ReportError(HRESULT hrErr);

    //If you call   ShowFrameDISPID, then we activate the corresponding page and property.   
    HRESULT ShowFrameDISPID(DISPID dispidToActivate);

    // This function only   works during the time that the frame is trying to apply the changes to each page.  
    // Calling this function will   result in the page frame querying on the selection context and updating its 
    // pages when   all the applies have succeded.  Callers of this function should be aware that should any of
    // the IPropertyPage::Apply's   fail, the set of pages will not be updated and thus they should ensure that
    // in   that case all of their current pages are crash-proof.
    HRESULT UpdateAfterApply();
}

cpp_quote("#define SID_SVsPropertyPageFrame IID_IVsPropertyPageFrame")


// copied from wingdi.h

cpp_quote("#if 0 // this is just so we can use LOGFONT in the idl")

typedef struct tagLOGFONTW_vsshell
{
    LONG      lfHeight;
    LONG      lfWidth;
    LONG      lfEscapement;
    LONG      lfOrientation;
    LONG      lfWeight;
    BYTE      lfItalic;
    BYTE      lfUnderline;
    BYTE      lfStrikeOut;
    BYTE      lfCharSet;
    BYTE      lfOutPrecision;
    BYTE      lfClipPrecision;
    BYTE      lfQuality;
    BYTE      lfPitchAndFamily;
    WCHAR     lfFaceName[32];
} LOGFONTW;

typedef DWORD_PTR HFONT;
typedef DWORD COLORREF;

cpp_quote("#endif")


enum __FONTCOLORFLAGS
{
    FCF_MUSTRESTART      = 0x00000001,
    FCF_ONLYTTFONTS      = 0x00000002,
    FCF_SAVEALL          = 0x00000004,          // save ALL items if any have changed (and "OK" is pressed, of course)
    FCF_ONLYNEWINSTANCES = 0x00000008,          // changes take effect only on new instances created after the changes are made
    FCF_AUTOFONT         = 0x00000010           // display "Automatic" font item (tracks system font) and use as default setting
};
typedef DWORD FONTCOLORFLAGS;


enum __FCITEMFLAGS
{
    FCIF_ISMARKER          = 0x00000001,
    FCIF_ALLOWFGCHANGE     = 0x00000002,
    FCIF_ALLOWBGCHANGE     = 0x00000004,
    FCIF_ALLOWBOLDCHANGE   = 0x00000008,
    FCIF_ALLOWCUSTOMCOLORS = 0x00000010,
    FCIF_PLAINTEXT         = 0x00000020     // "generic text" items track this item's color
};
typedef DWORD FCITEMFLAGS;


typedef struct _FontInfo
{
    BSTR bstrFaceName;
    WORD wPointSize;
    BYTE iCharSet;

    BOOL bFaceNameValid;
    BOOL bPointSizeValid;
    BOOL bCharSetValid;
} FontInfo;


// extra font flag values, useful only to the Fonts&Colors dialog
enum __FCFONTFLAGS
{
    FCFF_TRACK_PLAINTEXT_BOLD = 0x80000000, // track plaintext bold value
};
typedef DWORD FCFONTFLAGS;


// user-settable colorable item attributes
typedef struct _ColorableItemInfo
{
    COLORREF crForeground;
    COLORREF crBackground;
    DWORD    dwFontFlags;

    BOOL     bForegroundValid;
    BOOL     bBackgroundValid;
    BOOL     bFontFlagsValid;
} ColorableItemInfo;


typedef struct _AllColorableItemInfo
{
    ColorableItemInfo Info;
    BSTR              bstrName;
    BSTR              bstrLocalizedName;
    COLORREF          crAutoForeground;
    COLORREF          crAutoBackground;
    DWORD             dwMarkerVisualStyle;
//#ifndef INTEROPLIB
    LINESTYLE         eLineStyle;    
//#else
//    enum _LINESTYLE   eLineStyle;
//#endif
    FCITEMFLAGS       fFlags;
    BSTR              bstrDescription;

    BOOL              bNameValid;
    BOOL              bLocalizedNameValid;
    BOOL              bAutoForegroundValid;
    BOOL              bAutoBackgroundValid;
    BOOL              bMarkerVisualStyleValid;
    BOOL              bLineStyleValid;
    BOOL              bFlagsValid;
    BOOL              bDescriptionValid;
} AllColorableItemInfo;


// Values for IVsFontAndColorDefaults::GetPriority and
// IVsFontAndColorGroup::GetPriority.  These are actually the base values
// of ranges allocated to specific types of entries.
enum __FCPRIORITY
{
    FCP_EDITOR      = 0x0000,
    FCP_ENVIRONMENT = 0x0100,
    FCP_CLIENTS     = 0x1000
};
typedef USHORT FCPRIORITY;


//---------------------------------------------------------------------------
// IVsFontAndColorDefaults
//---------------------------------------------------------------------------
//  Allows a font/color category to specify its default settings for the
//  font/color dialog.  This is implemented by the cateogory and QI'd for by
//  the dialog.
[
    uuid(uuid_IVsFontAndColorDefaults),
    version(1.0),
    pointer_default(unique)
]
interface IVsFontAndColorDefaults : IUnknown
{
    //---------------------------------
    // general info

    HRESULT GetFlags(
        [out] FONTCOLORFLAGS *dwFlags);

    // Items with lower priority are ordered higher in the category list.
    HRESULT GetPriority(
        [out] FCPRIORITY *pPriority);

    // pbstrName SHOULD be localized.
    HRESULT GetCategoryName(
        [out] BSTR *pbstrName);

    // If this method indicates success and *pguidBase is not GUID_NULL on
    // return, the Fonts & Colors dialog will give the user an option to copy
    // the settings from the base category to the current category.
    HRESULT GetBaseCategory(
        [out] GUID *pguidBase);

    //---------------------------------
    // basic font and color info

    HRESULT GetFont(
        [out] FontInfo *pInfo);

    HRESULT GetItemCount(
        [out] LONG *pcItems);

    HRESULT GetItem(
        [in]  LONG                  iItem,
        [out] AllColorableItemInfo *pInfo);

    // szItem SHOULD NOT be localized.
    HRESULT GetItemByName(
        [in]  LPCOLESTR             szItem,
        [out] AllColorableItemInfo *pInfo);
}


//---------------------------------------------------------------------------
// IVsFontAndColorGroup
//---------------------------------------------------------------------------
//  Represents a group of font/color categories that are combined into a
//  single "super-category" whose contents are the union (not intersection)
//  of its component categories.
[
    uuid(uuid_IVsFontAndColorGroup),
    version(1.0),
    pointer_default(unique)
]
interface IVsFontAndColorGroup : IUnknown
{
    HRESULT GetCount(
        [out] long *pnCategories);

    // Items with lower priority are ordered higher in the category list.
    HRESULT GetPriority(
        [out] FCPRIORITY *pPriority);

    // pbstrName SHOULD be localized.
    HRESULT GetGroupName(
        [out] BSTR *pbstrName);

    HRESULT GetCategory(
        [in]  int   iCategory,
        [out] GUID *pguidCategory);
}


//---------------------------------------------------------------------------
// IVsFontAndColorEvents
//---------------------------------------------------------------------------
// For receiving font/color change notifications through the IConnectionPoint
// mechanism.
[
    uuid(uuid_IVsFontAndColorEvents),
    version(1.0),
    pointer_default(unique),
    local
]
interface IVsFontAndColorEvents : IUnknown
{
    // The b*Valid members of *pInfo indicate what font attributes are being
    // set.  Invalid attributes should be ignored.  pLOGFONT will be non-NULL
    // if and only if no attributes are marked invalid.  hFont may be NULL
    // in any case, but will definitely be NULL if any attributes are invalid.
    HRESULT OnFontChanged(
        [in] REFGUID         rguidCategory,
        [in] const FontInfo *pInfo,
        [in] const LOGFONTW *pLOGFONT,
        [in] HFONT           hFont);

    // The b*Valid members of *pInfo and pInfo->Info indicate what item
    // attributes are being set.  Invalid attributes should be ignored.
    // bstrItem may be NULL, and iItem may be -1, but at least one of the
    // two will be valid.  crLiteral* contain literal (non-palette-based)
    // RGB values.
    HRESULT OnItemChanged(
        [in] REFGUID                  rguidCategory,
        [in] LPCOLESTR                szItem,
        [in] LONG                     iItem,
        [in] const ColorableItemInfo *pInfo,
        [in] COLORREF                 crLiteralForeground,
        [in] COLORREF                 crLiteralBackground);

    HRESULT OnReset(
        [in] REFGUID rguidCategory);

    HRESULT OnResetToBaseCategory(
        [in] REFGUID rguidCategory);

    HRESULT OnApply();
};


//---------------------------------------------------------------------------
// IVsFontAndColorDefaultsProvider
//---------------------------------------------------------------------------
[
    uuid(uuid_IVsFontAndColorDefaultsProvider),
    version(1.0),
    pointer_default(unique)
]
interface IVsFontAndColorDefaultsProvider : IUnknown
{
    HRESULT GetObject(
        [in]  REFGUID    rguidCategory,
        [out] IUnknown **ppObj);
}


enum __FCSTORAGEFLAGS
{
    FCSF_READONLY         = 0x00000001,         // Open registry keys for reading only.
    FCSF_LOADDEFAULTS     = 0x00000002,         // Get settings from defaults provider if not saved in registry.
    FCSF_PROPAGATECHANGES = 0x00000004,         // Propagate changes to font&color events handler.
    FCSF_NOAUTOCOLORS     = 0x00000008          // Return real RGB values instead of COLORREF_AUTO
};
typedef DWORD FCSTORAGEFLAGS;


//---------------------------------------------------------------------------
// IVsFontAndColorStorage
//---------------------------------------------------------------------------
// Implemented by the Environment.
// Interface retrieved by 
//      pSP->QueryService(SID_SVsFontAndColorStorage, IID_IVsFontAndColorStorage, (void**)&pObj));
//  Allows font and color info to be stored and retrieved.  This is
//  implemented by the central storage mechanism and QI'd for by the font/
//  color categories. 
[
    uuid(uuid_IVsFontAndColorStorage),
    version(1.0),
    pointer_default(unique)
]
interface IVsFontAndColorStorage : IUnknown
{
    HRESULT OpenCategory(
        [in] REFGUID        rguidCategory,
        [in] FCSTORAGEFLAGS fFlags);

    HRESULT CloseCategory();

    HRESULT RemoveCategory(
        [in] REFGUID rguidCategory);

    HRESULT GetFont(
        [in, out] LOGFONTW *pLOGFONT,
        [in, out] FontInfo *pInfo);

    HRESULT GetItem(
        [in]      LPCOLESTR          szName,
        [in, out] ColorableItemInfo *pInfo);

    HRESULT SetFont(
        [in] FontInfo *pInfo);

    HRESULT SetItem(
        [in] LPCOLESTR          szName,
        [in] ColorableItemInfo *pInfo);
}
cpp_quote("#define SID_SVsFontAndColorStorage IID_IVsFontAndColorStorage")


//----------------------------------------------------------------------------
// IVsProjectStartupServices
//----------------------------------------------------------------------------
// Implemented by project objects.
// This is an optional interface that Project/VsHierarchies may choose to 
// implement. This interface allows a third party VsPackages to give a project 
// a service GUID that the project promises to persist in its project file
// and for which the project promises to QueryService for the next time the
// project loads. This allows a third party VsPackage to be delay loaded
// at the point that this project is loaded again. This allows the third
// party VsPackage to avoid using the "Preload=1" option but still be 
// guaranteed to be loaded when this project is loaded. The project will 
// only call QueryService(guidService, IID_IUnknown, &punk); it makes no 
// attempt to call a method on the service. The VsPackage upon being loaded
// can enumerate the loaded projects and perform appropriate operations 
// (e.g. hook up to project events). The IVsProjectStartupServices interface 
// can be retrieved from a project hierarchy in the following manner:
//  IVsHierarchy::GetProperty(VSITEMID_ROOT, VSHPROPID_StartupServices...);
[
    uuid(uuid_IVsProjectStartupServices),
    local,
    version(1.0),
    pointer_default(unique)
]
interface IVsProjectStartupServices : IUnknown
{
    HRESULT AddStartupService([in] REFGUID guidService);
    HRESULT RemoveStartupService([in]   REFGUID guidService);
    HRESULT GetStartupServiceEnum([out] IEnumProjectStartupServices **ppEnum);
}

//----------------------------------------------------------------------------
// IEnumProjectStartupServices
//----------------------------------------------------------------------------
[
    uuid(uuid_IEnumProjectStartupServices),
    local,
    version(1.0),
    pointer_default(unique)
]
interface IEnumProjectStartupServices : IUnknown
{
    HRESULT Next([in]   ULONG celt, [out, size_is(celt), length_is(*pceltFetched)] GUID *rgelt, [out] ULONG *pceltFetched);
    HRESULT Skip([in]   ULONG celt);
    HRESULT Reset(void);
    HRESULT Clone([out] IEnumProjectStartupServices **ppenum);
}


//----------------------------------------------------------------------------
// IVsPropertyPage
//----------------------------------------------------------------------------
// Implemented by projects on IPropertyPage objects.
// Used to show categorized property pages in the property frame.
[
    uuid(uuid_IVsPropertyPage),
    local,
    version(1.0),
    pointer_default(unique)
]
interface IVsPropertyPage : IUnknown
{
    //If your   page doesn't have a category (i.e. you want it to show up on the top level
    //of the treeview) either   just implement IPropertyPage, or return E_NOTIMPL
    //from this method.  Otherwise, the shell   will first call you with an iLevel
    //of 0.  You return the name of the category that   should be the closest direct
    //ancestor of   this page in the tree.  Then the shell will call with iLevel
    //of 1.  If you want your   page only indented one level, return S_FALSE.  
    //The   shell will keep going with iLevel increasing by 1 each time
    //until you return something other than S_OK or you hit the
    //shell's   internal limit of what it supports.
    //E_NOTIMPL and S_FALSE will stop   processing without showing an
    //error to the user.    Any other non-S_OK return value may or may not cause 
    //error information to be   shown the user.  
    //Currently the shell   only supports 2 levels of categories, like this:
    //  CatLevel1
    //  --CatLevel0
    //  ----PageName
    [propget]HRESULT CategoryTitle([in]UINT iLevel, [out,   retval]BSTR *pbstrCategory);
};

//----------------------------------------------------------------------------
// IVsPropertyPageNofity
//----------------------------------------------------------------------------
// Implemented by IPropertyPage objects displayed in the Property Page Frame window.
// This interface is optional and is implemented when a property page wants to know
// when its property page windows are actually visible (e.g. in order to do optimizations
// to reduce resouces consumed by hidden pages). OnShowPage(FALSE) is called on the
// page being deactivated before OnShowPage(TRUE) is called on the new page
// becoming visible.
// NOTE: OnShowPage method should not be confused with IPropertyPage::Activate/
// Deactivate which are called when the page object should be created and destroyed.
// For example, when a page is displayed, Activate is called to create the page. When 
// a different property page tab is activated, then OnShowPage(FALSE) is called on the 
// first page, but Deactivate is not called. Deactivate is only called when the property page
// objects are no longer being used at all (e.g. a selection change or the property page frame
// window is closed). If a property page is being shown for the first time, then OnShowPage(TRUE)
// is called after IPropertyPage::Activate is called.
[
    uuid(uuid_IVsPropertyPageNotify),
    local,
    version(1.0),
    pointer_default(unique)
]
interface IVsPropertyPageNotify : IUnknown
{
    HRESULT OnShowPage([in] BOOL fPageActivated);
};

//----------------------------------------------------------------------------
// IVsPerPropertyBrowsing
//----------------------------------------------------------------------------
// Implemented by IDispatch object passed to the Properties Window through 
// ISelectionContainer and ITrackSelection::OnSelectChange or 
// IVsTrackSelectionEx::OnSelectChangeEx.
// This enables an object to do control various things with the Properties Window
// including localizing the names of the properties (useful for design-time only properties).
[
    object,
    uuid(uuid_IVsPerPropertyBrowsing),
    pointer_default(unique)
]
interface IVsPerPropertyBrowsing : IUnknown
{
    // hides the property at the given dispid from the property browser
    // implmentors should can return E_NOTIMPL to show all properties that
    // are otherwise browsable.
    [id(1), helpstring("Allows a member to be hidden from browsing")]HRESULT HideProperty(DISPID dispid, [out,retval]BOOL* pfHide);

    // allows properties of type VT_DISPATCH to be viewed recusively.  Non-NULL VT_DISPATCH properties
    // will have the "+" expandable glyph next to them and can be expanded or collapsed by the user
    // Returning a non-S_OK return code or false for pfDisplay will suppress this feature
    [id(2), helpstring("Determines whether a IDispatch-typed property should show it's properties")]HRESULT DisplayChildProperties(DISPID dispid, [out,retval]BOOL* pfDisplay);

    // retrieves the localized name and description for a property.
    // returning a non-S_OK return code will display the default values
    // Implementors must handle case of one or both BSTR* in values being NULL;
    [id(3), helpstring("Allows the property name and documentation to be localized")]HRESULT GetLocalizedPropertyInfo(DISPID dispid, LCID localeID, [out]BSTR* pbstrLocalizedName, [out]BSTR* pbstrLocalizeDescription);

    // determines if the current value for a property is the default.  If it is not default,
    // the property will be shown as bold in the browser to indcate that it has been modified from the default.
    // Implmentors should return a non-S_OK return code or *fDefault = TRUE to display property value normally.
    [id(4), helpstring("Determines if the value for the current property is default")]HRESULT HasDefaultValue(DISPID dispid, [out, retval]BOOL* fDefault);

    // determines if a property should be made read only.  This only applies to properties that are writeable,
    // but returning TRUE for pfReadOnly will cause them to be displayed by the propety browser as read only.
    [id(5), helpstring("Deterines if a property should be marked read only")]HRESULT IsPropertyReadOnly(DISPID dispid, [out, retval]BOOL* fReadOnly);

    // returns the classname for this object.  The class name is the non-bolded text that appears in the 
    // property browser selection combo.  If this method returns a non-S_OK return code, the default
    // will be used.  The default is the name string from a call to ITypeInfo::GetDocumentation(MEMID_NIL, ...);
    [id(6), helpstring("Returns the class name for this object")]HRESULT GetClassName([out, retval]BSTR* pbstrClassName);

    // checks whether the given property can be reset to some default value.  If return value is non-S_OK or *pfCanReset is 
    // is FALSE, the value will not be able to be reset.
    [id(7), helpstring("Determines if a property can be reset")]HRESULT CanResetPropertyValue(DISPID dispid, [out, retval]BOOL* pfCanReset);

    // Resets the value of the given property.  This method will only be called of CanResetProperty returns S_OK and *pfCanReset == TRUE for the
    // given property.  If the return value is S_OK, the property's value will then be refreshed to the new default
    // values.
    [id(8), helpstring("Resets the given properties value to the default.")]HRESULT ResetPropertyValue(DISPID dispid);                                  
};



//-----------------------------------------------------------------------------
// IVsRegisterPriorityCommandTarget
//-----------------------------------------------------------------------------
// Implemented by the Environment.
// This interface should be used rarely because you can severly impact performance.
// This interface gives clients the ability to have an IOleCommandTarget
// that is called near the top of our command routing, after Addins have
// a shot at the commands.  This also enables other scenarios (e.g. Academic
// scenarios where a special academic VsPackage wants to dummy down the
// environment command structure to make it simpler by hiding a bunch of
// commands).
[
    uuid(uuid_IVsRegisterPriorityCommandTarget),
    local,
    version(1.0),
    pointer_default(unique)
]
interface IVsRegisterPriorityCommandTarget : IUnknown
{
    // The newly registered CommandTarget   will be added to the front of the list
    HRESULT RegisterPriorityCommandTarget([in] DWORD dwReserved,                // Must be zero
        [in] IOleCommandTarget *pCmdTrgt,
        [out,retval] VSCOOKIE *pdwCookie);

    // The CommandTarget will   be removed from the priority routing list.
    HRESULT UnregisterPriorityCommandTarget([in] VSCOOKIE   dwCookie);
};

cpp_quote("#define SID_SVsRegisterPriorityCommandTarget IID_IVsRegisterPriorityCommandTarget")

//-----------------------------------------------------------------------------
// IVsObjectSearch
//-----------------------------------------------------------------------------
// Implemented by the Environment on the Object Search feature.
enum __VSOBSEARCHFLAGS
{
    VSOSF_NONE            = 0x00000000,
    VSOSF_SHOWUI          = VSOSF_NONE, // Synonym for none
    VSOSF_NOSHOWUI        = 0x00000001, // Show Find Symbol Results Window
    VSOSF_EXPANDREFS      = 0x00000002, // Expand nodes in Find Symbol Results Window (applies only if VSOSF_NOSHOWUI not set)
    VSOSF_USECURRENTOPTS  = 0x00000004, // Use current Find Symbol options (as opposed to passed in ones)
};
typedef DWORD VSOBSEARCHFLAGS;

[
    uuid(uuid_IVsObjectSearch),
    local,
    version(1.0),
    pointer_default(unique)
]
interface IVsObjectSearch : IUnknown
{
    HRESULT Find([in]   VSOBSEARCHFLAGS flags, [in] const VSOBSEARCHCRITERIA *pobSrch, [out,retval] IVsObjectList **ppList);
};

cpp_quote("#define SID_SVsObjectSearch IID_IVsObjectSearch")


//-----------------------------------------------------------------------------
// IVsObjectSearchPane
//-----------------------------------------------------------------------------
// Implemented by the Environment. 
// Interface onto the ObjectSearchResults Pane
[
    uuid(uuid_IVsObjectSearchPane),
    local,
    version(1.0),
    pointer_default(unique)
]
interface IVsObjectSearchPane : IUnknown
{
    HRESULT SetResultsList([in] IVsLibrary *pLibrary,   [in] IVsObjectList *pList, [in] VSOBSEARCHFLAGS flags, [out]IVsObjectListOwner** ppListOwner);
};


//-----------------------------------------------------------------------------
// IVsGenerationProgress
//-----------------------------------------------------------------------------
// Implemented by project systems that support IVsSingleFileGenerator's.
// This interface allows the generator to communicate generation errors
// and generation progress to the caller.  
[
    uuid(uuid_IVsGeneratorProgress),
    local,
    version(1.0),
    pointer_default(unique)
]
interface IVsGeneratorProgress : IUnknown
{
    // Communicate errors
    HRESULT GeneratorError([in] BOOL fWarning,                  
        [in] DWORD  dwLevel,
        [in] BSTR bstrError,
        [in] DWORD  dwLine,
        [in] DWORD  dwColumn);

    // Report   progress to the caller.  nComplete and nTotal have
    // same meanings as in IVsStatusBar::Progress()
    HRESULT Progress([in]   ULONG nComplete,        // Current position
        [in]    ULONG nTotal);          // Max value
};


//-----------------------------------------------------------------------------
// IVsSingleFileGenerator
//-----------------------------------------------------------------------------
// Used by project systems that support IVsSingleFileGenerator's.
// This interfaces gives the ability to call a custom generator on a
// file.  This generator will transform the contents of that file into
// another file that could be added to the project, compiled, etc.
//
// All generators must implement this interface.  Such generators must be
// registered in the local registry under a specific project package.  They
// can be instantiated via the SLocalRegistry service.  
[
    uuid(uuid_IVsSingleFileGenerator),
    local,
    version(1.0),
    pointer_default(unique)
]
interface IVsSingleFileGenerator : IUnknown
{
    // Retrieve default properties for the generator
    [propget]   HRESULT DefaultExtension([out,retval] BSTR* pbstrDefaultExtension);

    // Generate the file
    HRESULT Generate([in]   LPCOLESTR wszInputFilePath,
        [in]    BSTR bstrInputFileContents,
        [in]    LPCOLESTR wszDefaultNamespace, 
        [out] BYTE**    rgbOutputFileContents,
        [out] ULONG*    pcbOutput,
        [in]    IVsGeneratorProgress* pGenerateProgress);
};                   

//-----------------------------------------------------------------------------
//  HRESULT FACILITY_ITF values used in these interfaces:
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  VS_E_BUSY is returned by interfaces to asynchronous behavior when the
//  object in question in already busy.  For example, starting a build while
//  a buildable project configuration object is in the process of cleaning,
//  building or checking for out of date-ness.
//-----------------------------------------------------------------------------

cpp_quote("#define VS_E_BUSY MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x200)")


//-----------------------------------------------------------------------------
//  VS_E_SPECIFYING_OUTPUT_UNSUPPORTED is returned by build interfaces that have
//  parameters for specifying an array of IVsOutput's but the implementation
//  can only apply the method to all outputs.  The parameter of IVsOutput** or
//  IVsOutput* [] must be NULL.
//-----------------------------------------------------------------------------

cpp_quote("#define VS_E_SPECIFYING_OUTPUT_UNSUPPORTED MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x201)")

//-----------------------------------------------------------------------------
// IVsCfg
//-----------------------------------------------------------------------------
// Implemented by a project system. 
// This is the root interface for a configuration object (e.g. "Debug", "Release").
[
    uuid(uuid_IVsCfg),
    version(1.0),
    pointer_default(unique)
]
interface IVsCfg : IUnknown
{
    //if you support platforms, then in addition to supporting IVsConfigProvider2
    //you should also return your config name like "Debug|Win32"
    HRESULT get_DisplayName([out] BSTR *pbstrDisplayName);
    HRESULT get_IsDebugOnly([out] BOOL *pfIsDebugOnly);
    HRESULT get_IsReleaseOnly([out] BOOL *pfIsReleaseOnly);
}

//-----------------------------------------------------------------------------
// IVsDebuggableProjectCfg
//-----------------------------------------------------------------------------
// Implemented by a project system that supports Debug Launch (F5 command).
// Projects that implement this interface are elligible to be a Startup Project.
// If a project configuration can be launched from the debugger, it must support the
// IVsDebuggableProjectCfg interface.  Unlike the IVsBuildableProjectCfg interface,
// this is unlikely to require a separate object, so it's just an optional interface
// on the project configuration object.
//
[
    uuid(uuid_IVsDebuggableProjectCfg),
    version(1.0),
    pointer_default(unique)
]
interface IVsDebuggableProjectCfg : IVsProjectCfg
{
    HRESULT DebugLaunch([in] VSDBGLAUNCHFLAGS grfLaunch);
    HRESULT QueryDebugLaunch([in] VSDBGLAUNCHFLAGS grfLaunch, [out] BOOL *pfCanLaunch);
}

//-----------------------------------------------------------------------------
// IVsBuildStatusCallback
//-----------------------------------------------------------------------------
// Implemented by the Environment.
// Used by a project system that supports Build operations.
[
    uuid(uuid_IVsBuildStatusCallback),
    version(1.0),
    pointer_default(unique)
]
interface IVsBuildStatusCallback : IUnknown
{
    HRESULT BuildBegin([in, out] BOOL *pfContinue);

    //  If the operation that is ending is a build or a clean, fSuccess indicates whether
    //  the build or clean completed successfully.  On an UpToDateCheck, fSuccess must
    //  should be passed as TRUE when the project configuration is up to date, and
    //  FALSE when the project configuration is not up to date.
    HRESULT BuildEnd([in] BOOL fSuccess);
    HRESULT Tick([in, out] BOOL *pfContinue);
}

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
const DWORD VS_BUILDABLEPROJECTCFGOPTS_REBUILD = 1;
const DWORD VS_BUILDABLEPROJECTCFGOPTS_BUILD_SELECTION_ONLY = 2;
const DWORD VS_BUILDABLEPROJECTCFGOPTS_BUILD_ACTIVE_DOCUMENT_ONLY = 4;
const DWORD VS_BUILDABLEPROJECTCFGOPTS_PRIVATE = 0xFFFF0000;    // flags private to a particular implementation

//-----------------------------------------------------------------------------
// IVsBuildableProjectCfg
//-----------------------------------------------------------------------------
// Implemented by a project system that supports Build operations.
// If a project configuration object implements this interface then the project
// is considered to be buildable. It will get a "Build" checkbox in the 
// Solution Configuration property page.
[
    uuid(uuid_IVsBuildableProjectCfg),
    version(1.0),
    pointer_default(unique)
]
interface IVsBuildableProjectCfg : IUnknown
{
    // Obsolete Method
    HRESULT get_ProjectCfg([out] IVsProjectCfg **ppIVsProjectCfg);

    HRESULT AdviseBuildStatusCallback([in] IVsBuildStatusCallback *pIVsBuildStatusCallback, [out] VSCOOKIE *pdwCookie);
    HRESULT UnadviseBuildStatusCallback([in] VSCOOKIE dwCookie);

    HRESULT StartBuild([in] IVsOutputWindowPane *pIVsOutputWindowPane, [in] DWORD dwOptions);
    HRESULT StartClean([in] IVsOutputWindowPane *pIVsOutputWindowPane, [in] DWORD dwOptions);
    HRESULT StartUpToDateCheck([in] IVsOutputWindowPane *pIVsOutputWindowPane, [in] DWORD dwOptions);
    HRESULT QueryStatus([out] BOOL *pfBuildDone);
    HRESULT Stop([in] BOOL fSync);

    // Obsolete method
    HRESULT Wait([in] DWORD dwMilliseconds, [in] BOOL fTickWhenMessageQNotEmpty);

    HRESULT QueryStartBuild([in] DWORD dwOptions, [out, optional] BOOL *pfSupported, [out, optional] BOOL *pfReady);
    HRESULT QueryStartClean([in] DWORD dwOptions, [out, optional] BOOL *pfSupported, [out, optional] BOOL *pfReady);
    HRESULT QueryStartUpToDateCheck([in] DWORD dwOptions, [out, optional] BOOL *pfSupported, [out, optional] BOOL *pfReady);
}

//-----------------------------------------------------------------------------
// IVsDeployStatusCallback
//-----------------------------------------------------------------------------
// Implemented by the Environment.
// Used by a project system that supports Deploying project outputs.
[
    uuid(uuid_IVsDeployStatusCallback),
    version(1.0),
    pointer_default(unique)
]
interface IVsDeployStatusCallback : IUnknown
{
    HRESULT OnStartDeploy([in,out]BOOL *pfContinue);
    HRESULT OnEndDeploy ([in]BOOL fSuccessful);
    HRESULT OnQueryContinueDeploy([in,out] BOOL *pfContinue);
};

//-----------------------------------------------------------------------------
// IVsDeployableProjectCfg
//-----------------------------------------------------------------------------
// Implemented by a project system that supports Deploying project outputs
// (not to be confused with a project that can EnumOutputs and thus can be
// deployed by a deployment project).
// If a project configuration object implements this interface then the project
// is considered to support deploying. It will get a "Deploy" checkbox in the 
// Solution Configuration property page.
[
    uuid(uuid_IVsDeployableProjectCfg),
    version(1.0),
    pointer_default(unique)
]
interface IVsDeployableProjectCfg : IUnknown
{
    HRESULT AdviseDeployStatusCallback([in] IVsDeployStatusCallback *pIVsDeployStatusCallback, [out] VSCOOKIE *pdwCookie);
    HRESULT UnadviseDeployStatusCallback([in] VSCOOKIE dwCookie);

    HRESULT StartDeploy([in] IVsOutputWindowPane *pIVsOutputWindowPane, [in] DWORD dwOptions);
    HRESULT QueryStatusDeploy([out] BOOL *pfDeployDone);
    HRESULT StopDeploy([in] BOOL fSync); // Call if Cancel button is pressed

    // Obsolete method
    HRESULT WaitDeploy([in] DWORD dwMilliseconds, [in] BOOL fTickWhenMessageQNotEmpty); 

    HRESULT QueryStartDeploy([in] DWORD dwOptions, [out, optional] BOOL *pfSupported, [out, optional] BOOL *pfReady);

    HRESULT Commit(DWORD dwReserved); // Call if all deployments succeeded
    HRESULT Rollback(DWORD dwReserved); // Call if any failed
}

//------------------------------------------------------------------
// IVsProjectCfg
//------------------------------------------------------------------
// Implemented by a project system. 
// This interface is implemented by configuration objects corresponding to
// the project object (e.g. "Debug", "Release"). It is not implemented by
// configuration objects corresponding to project items (if supported).
[
    uuid(uuid_IVsProjectCfg),
    version(1.0),
    pointer_default(unique)
]
interface IVsProjectCfg : IVsCfg
{
    // obsolete method
    HRESULT EnumOutputs([out] IVsEnumOutputs **ppIVsEnumOutputs);
    // obsolete method
    HRESULT OpenOutput([in] LPCOLESTR szOutputCanonicalName, [out] IVsOutput **ppIVsOutput);

    // obsolete method
    HRESULT get_ProjectCfgProvider([out] IVsProjectCfgProvider **ppIVsProjectCfgProvider);

    // This is a property rather than an alternate interface on the project configuration
    // object to enable project configurations to make the buildable project configuration
    // a separate object.
    HRESULT get_BuildableProjectCfg([out] IVsBuildableProjectCfg **ppIVsBuildableProjectCfg);

    //
    HRESULT get_CanonicalName([out] BSTR *pbstrCanonicalName);

    // obsolete method
    HRESULT get_Platform([out] GUID *pguidPlatform);
    // obsolete method
    HRESULT get_IsPackaged([out] BOOL *pfIsPackaged);

    // Obsolete method
    HRESULT get_IsSpecifyingOutputSupported([out] BOOL *pfIsSpecifyingOutputSupported);

    // Obsolete method
    HRESULT get_TargetCodePage([out] UINT *puiTargetCodePage);

    // Obsolete method
    HRESULT get_UpdateSequenceNumber([out] ULARGE_INTEGER *puliUSN);

    // The RootURL property is the root URL for the project outputs.  Essentially,
    // if an output's project-relative path is required, it's computed by removing
    // the RootURL from its DeploySourceURL.  As is the case for DeploySourceURL
    // values, the convention is that paths that are in the local filesystem
    // begin with the eight characters: "file:///".
    HRESULT get_RootURL([out] BSTR *pbstrRootURL);
}

//-----------------------------------------------------------------------------
// IVsProjectCfg2
//-----------------------------------------------------------------------------
// this derives from IVsProjectCfg, and thereby from IVsCfg.
// However, it should be noted that IVsCfg::get_IsDebugOnly() and 
// IVsCfg::get_RetailOnly() are mostly moot, since we're no longer limited to
// two configuration types.  Ergo, code which processes configurations should
// not make assumptions about the number of configurations, nor should it
// assume that a project which has only one configuration is necessarily debug
// or retail.
// The primary use of IVsProjectCfg2, beyond IVsProjectCfg usage, is to allow
// projects the freedom to group outputs.  However, the project must return
// the same number of groups for each configuration that it supports, even
// though the number of outputs contained within a group may vary from
// configuration to configuration.  The groups will also have the same
// identifier information (canonical name, display name, and group info) from
// configuration to configuration within a project.
[
    uuid(uuid_IVsProjectCfg2),
    version(1.0),
    pointer_default(unique)
]
interface IVsProjectCfg2 : IVsProjectCfg
{
    HRESULT get_CfgType([in] REFIID iidCfg, [out, iid_is(iidCfg)] void **ppCfg);

    HRESULT get_OutputGroups([in] ULONG celt,
        [in, out, size_is(celt)] IVsOutputGroup *rgpcfg[],
        [out, optional] ULONG *pcActual);

    HRESULT OpenOutputGroup([in] LPCOLESTR szCanonicalName,
        [out] IVsOutputGroup **ppIVsOutputGroup);

    // This method replaces the get_IsWebApplication() method from the now-obsolete
    // IVsDeployWebProject interface.
    HRESULT OutputsRequireAppRoot([out]BOOL *pfRequiresAppRoot);

    // This method is identical to the get_VirtualRoot method from the now-obsolete
    // IVsDeployWebProject interface.  It is required for debugging web projects.
    HRESULT get_VirtualRoot([out]BSTR *pbstrVRoot);

    // This method tells whether this is a private (per user as opposed to shared w/all team)
    // config.  In 7.0, we're not sure whether we'll support this, but we're looking
    // ahead and putting it in the interface.
    HRESULT get_IsPrivate([out]BOOL *pfPrivate);
};


//----------------------------------------------------------------------------
// IVsCfgProvider
//----------------------------------------------------------------------------
// Implemented by a project system. 
enum __VSCFGFLAGS
{
    CFGFLAG_CfgsAreNotBrowsable = 0x00000001,
    CFGFLAG_CfgsUseIndependentPages = 0x00000002,
};

typedef DWORD VSCFGFLAGS;

[
    uuid(uuid_IVsCfgProvider),
    version(1.0),
    pointer_default(unique)
]
interface IVsCfgProvider : IUnknown
{
    // Return   the per-configuration objects for this object.
    // If   celt is zero and pcActual is not NULL, the number of configuration objects
    //   is returned in *pcActual.
    // If   celt is not zero, rgpcfg must not be NULL, or E_POINTER is returned.
    //
    // An   extremely common pattern is something like (omitting error checks for readability):
    //
    // hr   = pIVsCfgProvider->GetCfgs(0, NULL, &cExpected, NULL);
    // prgpcfgs =   ::CoTaskMemAlloc(cExpected * sizeof(IVsCfg *));
    // hr   = pIVsCfgProvider->GetCfgs(cExpected, prgpcfgs, &cActual, NULL);
    //
    HRESULT GetCfgs([in] ULONG celt,
        [in, out,   size_is(celt)] IVsCfg *rgpcfg[],
        [out,   optional] ULONG *pcActual,
        [out,   optional] VSCFGFLAGS *prgfFlags);
}

//------------------------------------------------------------------
// IVsCfgProvider2
//------------------------------------------------------------------
// Implemented by a project system. 
// If you wish your object to support platforms or you wish to be able to
// edit (add, rename, delete) configurations from your object, you
// must support this interface in addition to IVsCfgProvider.
//----------------------------------------------------------------------------
// VSCFGPROPID
//----------------------------------------------------------------------------
// property ids for IVsCfgProvider2::GetCfgProviderProperty calls
enum __VSCFGPROPID
{
    VSCFGPROPID_LAST              = -16000,  // first value should be a unique among propids
    VSCFGPROPID_Reserved1                 = -16000,
    VSCFGPROPID_Reserved2                 = -16001,
    VSCFGPROPID_SupportsCfgAdd        = -16002,
    VSCFGPROPID_SupportsCfgDelete         = -16003,
    VSCFGPROPID_SupportsCfgRename         = -16004,
    VSCFGPROPID_SupportsPlatformAdd   = -16005,
    VSCFGPROPID_SupportsPlatformDelete  =   -16006,
    VSCFGPROPID_SupportsPrivateCfgs   = -16007,
    VSCFGPROPID_IntrinsicExtenderCATID  =   -16008,
    VSCFGPROPID_FIRST             = -16008,
};
typedef LONG VSCFGPROPID;

[
    uuid(uuid_IVsCfgProvider2),
    version(1.0)
]
interface IVsCfgProvider2 : IVsCfgProvider
{
    HRESULT GetCfgNames([in] ULONG celt, [in,   out, size_is(celt)] BSTR rgbstr[], 
        [out,   optional] ULONG *pcActual);
    HRESULT GetPlatformNames([in]   ULONG celt, [in, out, size_is(celt)] BSTR rgbstr[], 
        [out,   optional] ULONG *pcActual);
    HRESULT GetCfgOfName([in]   LPCOLESTR pszCfgName, [in] LPCOLESTR pszPlatformName, [out] IVsCfg **ppCfg);

    //NULL is   a valid parameter for pszCloneCfgName, in case the user wants to just
    //create a new one, without reference   to an old one.  Feel free to ignore fPrivate
    //for   now.
    HRESULT AddCfgsOfCfgName([in]   LPCOLESTR pszCfgName, [in] LPCOLESTR pszCloneCfgName, [in]BOOL fPrivate);
    HRESULT DeleteCfgsOfCfgName([in] LPCOLESTR pszCfgName);
    HRESULT RenameCfgsOfCfgName([in] LPCOLESTR pszOldName, [in]LPCOLESTR pszNewName);
    HRESULT AddCfgsOfPlatformName([in] LPCOLESTR pszPlatformName,   [in] LPCOLESTR pszClonePlatformName);
    HRESULT DeleteCfgsOfPlatformName([in]   LPCOLESTR pszPlatformName);

    HRESULT GetSupportedPlatformNames([in] ULONG celt, 
        [in, out, size_is(celt)] BSTR rgbstr[],
        [out, optional] ULONG *pcActual);

    HRESULT GetCfgProviderProperty([in] VSCFGPROPID propid, [out]   VARIANT *pvar);

    HRESULT AdviseCfgProviderEvents([in] IVsCfgProviderEvents   *pCPE, [out] VSCOOKIE *pdwCookie);
    HRESULT UnadviseCfgProviderEvents([in] VSCOOKIE dwCookie);
};

//----------------------------------------------------------------------------
// IVsCfgProviderEvents
//----------------------------------------------------------------------------
// Implemented by the Environment.
[
    uuid(uuid_IVsCfgProviderEvents),
    version(1.0),
    pointer_default(unique)
]
interface IVsCfgProviderEvents : IUnknown
{
    HRESULT OnCfgNameAdded([in] LPCOLESTR   pszCfgName);
    HRESULT OnCfgNameDeleted([in]   LPCOLESTR pszCfgName);
    // note: if the rename operation is implemented as a clone & delete fire the add/delete events instead of   this one.
    HRESULT OnCfgNameRenamed([in]   LPCOLESTR pszOldName, [in] LPCOLESTR lszNewName);
    HRESULT OnPlatformNameAdded([in] LPCOLESTR pszPlatformName);
    HRESULT OnPlatformNameDeleted([in] LPCOLESTR pszPlatformName);
};

//----------------------------------------------------------------------------
// IVsCfgProviderEventsHelper
//----------------------------------------------------------------------------
// Implemented by the Environment.
// Used by project system. 
[
    uuid(uuid_IVsCfgProviderEventsHelper),
    version(1.0)
]
interface IVsCfgProviderEventsHelper : IUnknown
{
    HRESULT AdviseCfgProviderEvents([in] IVsCfgProviderEvents   *pCPE, [out] VSCOOKIE *pdwCookie);
    HRESULT UnadviseCfgProviderEvents([in] VSCOOKIE dwCookie);
    HRESULT NotifyOnCfgNameAdded([in]   LPCOLESTR pszCfgName);
    HRESULT NotifyOnCfgNameDeleted([in] LPCOLESTR   pszCfgName);
    // note: if the rename operation is implemented as a clone & delete fire the add/delete events instead of   this one.
    HRESULT NotifyOnCfgNameRenamed([in] LPCOLESTR   pszOldName, [in] LPCOLESTR lszNewName);
    HRESULT NotifyOnPlatformNameAdded([in] LPCOLESTR pszPlatformName);
    HRESULT NotifyOnPlatformNameDeleted([in] LPCOLESTR pszPlatformName);
};

cpp_quote("DEFINE_GUID(CLSID_VsCfgProviderEventsHelper, 0x99913f1f, 0x1ee3, 0x11d1, 0x8a, 0x6e, 0x0, 0xc0, 0x4f, 0x68, 0x2e, 0x21);")


//------------------------------------------------------------------
// IVsProjectCfgProvider
//------------------------------------------------------------------
// Implemented by a project system. 
// This interface is attempted to be retrieved from a project IVsHierarchy in the following order:
//      1. call IVsGetCfgProvider::GetCfgProvider on the IVHierarchy's VSHPROPID_BrowseObject
//      2. QI IVHierarchy's VSHPROPID_BrowseObject directly
//      3. call IVsGetCfgProvider::GetCfgProvider on the IVHierarchy
//      4. QI the IVHierarchy directly
[
    uuid(uuid_IVsProjectCfgProvider),
    version(1.0),
    pointer_default(unique)
]
interface IVsProjectCfgProvider : IVsCfgProvider
{
    HRESULT OpenProjectCfg([in] LPCOLESTR szProjectCfgCanonicalName, [out] IVsProjectCfg **ppIVsProjectCfg);
    HRESULT get_UsesIndependentConfigurations([out] BOOL *pfUsesIndependentConfigurations);
}

cpp_quote("extern const __declspec(selectany) GUID GUID_VS_PLATFORM_WIN32_X86 = { /* 707d11a0-91ca-11d0-8a3e-00a0c91e2acd */")
cpp_quote("    0x707d11a0,")
cpp_quote("    0x91ca,")
cpp_quote("    0x11d0,")
cpp_quote("    {0x8a, 0x3e, 0x00, 0xa0, 0xc9, 0x1e, 0x2a, 0xcd}")
cpp_quote("  };")

//------------------------------------------------------------------
// IVsGetCfgProvider
//------------------------------------------------------------------
// Implemented by a project system. 
[
    uuid(uuid_IVsGetCfgProvider),
    version(1.0),
    pointer_default(unique)
]
interface IVsGetCfgProvider : IUnknown
{
    HRESULT GetCfgProvider([out] IVsCfgProvider** ppCfgProvider);
}

//-----------------------------------------------------------------------------
// IVsEnumOutputs
//-----------------------------------------------------------------------------
// Implemented by a project system that supports producing build outputs. 
// Used to enumerate outputs for deployment by a deployment project.
[
    uuid(uuid_IVsEnumOutputs),
    version(1.0),
    pointer_default(unique)
]
interface IVsEnumOutputs : IUnknown
{
    HRESULT Reset();
    HRESULT Next([in] ULONG cElements, [in, out, size_is(cElements)] IVsOutput *rgpIVsOutput[], [out, optional] ULONG *pcElementsFetched);
    HRESULT Skip([in] ULONG cElements);
    HRESULT Clone([out] IVsEnumOutputs **ppIVsEnumOutputs);
}

//-----------------------------------------------------------------------------
// IVsOutput
//-----------------------------------------------------------------------------
// Implemented by a project system that supports producing build outputs. 
[
    uuid(uuid_IVsOutput),
    version(1.0),
    pointer_default(unique)
]
interface IVsOutput : IUnknown
{
    HRESULT get_DisplayName([out] BSTR *pbstrDisplayName);
    HRESULT get_CanonicalName([out] BSTR *pbstrCanonicalName);

    // The DeploySourceURL is the web location of the item.  For items in the
    // local filesystem, the URL should begin with the eight characters:
    // "file:///".  Consumers of outputs may not be able to process URLs of
    // other forms, so it's very important for projects that are generating URLs
    // for local items to try to use this form of URL as much as possible.
    HRESULT get_DeploySourceURL([out] BSTR *pbstrDeploySourceURL);

    // obsolete method
    HRESULT get_Type([out] GUID *pguidType);
}


//-----------------------------------------------------------------------------
// IVsHierarchicalOutput
//-----------------------------------------------------------------------------
// OBSOLETE interface. 
[
    uuid(uuid_IVsHierarchicalOutput),
    version(1.0),
    pointer_default(unique)
]
interface IVsHierarchicalOutput : IVsOutput
{
    HRESULT EnumSubOutputs([out] IVsEnumOutputs **ppIVsEnumOutputs);
}

//-----------------------------------------------------------------------------
// IVsOutputGroup
//-----------------------------------------------------------------------------
// Implemented by a project system that supports producing build outputs. 
// This construct allows projects to group outputs
// according to usage.  For instance, a DLL might be grouped with
// its PDB.  As mentioned in the comments for IVsProjectCfg2, the project must return
// the same number of groups for each configuration that it supports, even
// though the number of outputs contained within a group may vary from
// configuration to configuration.  For example, the group "Matt's DLL"
// might include mattd.dll and mattd.pdb in debug configuration, but
// only include matt.dll in retail configuration. The groups will also have
// the same identifier information (canonical name, display name, and group
// info) from configuration to configuration within a project.  This allows
// deployment and packaging to continue to operate even if configurations
// change.  Groups may also have a "key output" -- this allows packaging
// shortcuts to point to something meaningful.  Any group might be empty
// in a given configuration, so no assumptions should be made about the size
// of a group beyond the occasional "no more than one" constraint.
//
// Note that if a project has an IVsOutput that it doesn't want to package/deploy,
// it is sufficient to not put that output in a group.  The output can still
// be enumerated normally via IVsProjectCfg::EnumOutputs, which returns all
// of a configuration's outputs regardless of grouping.

// Canonical group names:
// These names are Unicode, since typically they are passed as LPCOLESTR arguments
// to COM methods.  VS projects use these names for the canonical group names, so
// as to make them predictable -- i.e., project A can ask project B for its
// built outputs and have a reasonable expectation as to what it's getting.
// Display names, on the other hand, are not constrained.  Of course,
// third-party projects are free to use either our canonical names or their own names.

cpp_quote("#define VS_OUTPUTGROUP_CNAME_SourceFiles         L\"SourceFiles\"")
cpp_quote("#define VS_OUTPUTGROUP_CNAME_Built                   L\"Built\"")
cpp_quote("#define VS_OUTPUTGROUP_CNAME_ContentFiles            L\"ContentFiles\"")
cpp_quote("#define VS_OUTPUTGROUP_CNAME_LocalizedResourceDlls   L\"LocalizedResourceDlls\"")
cpp_quote("#define VS_OUTPUTGROUP_CNAME_Documentation           L\"Documentation\"")
cpp_quote("#define VS_OUTPUTGROUP_CNAME_Symbols         L\"Symbols\"")

[
    uuid(uuid_IVsOutputGroup),
    version(1.0),
    pointer_default(unique)
]
interface IVsOutputGroup : IUnknown
{
    // These return identical information regardless of cfg setting:
    HRESULT get_CanonicalName([out] BSTR *pbstrCanonicalName);
    HRESULT get_DisplayName([out] BSTR *pbstrDisplayName);

    // The results of these will vary based on the configuration:
    HRESULT get_KeyOutput([out] BSTR *pbstrCanonicalName);

    // Back pointer to project cfg:
    HRESULT get_ProjectCfg([out] IVsProjectCfg2 **ppIVsProjectCfg2);

    // The list of outputs.  There might be none!  Not all files go out
    // on every configuration, and a groups files might all be configuration
    // dependent!
    HRESULT get_Outputs([in] ULONG celt,
        [in, out, size_is(celt)] IVsOutput2 * rgpcfg[],
        [out, optional] ULONG *pcActual);

    HRESULT get_DeployDependencies([in] ULONG celt,
        [in,    out, size_is(celt)] IVsDeployDependency * rgpdpd[],
        [out, optional] ULONG *pcActual);

    HRESULT get_Description([out] BSTR *pbstrDescription);
};

//-----------------------------------------------------------------------------
// IVsOutput2
//-----------------------------------------------------------------------------
// Implemented by a project system that supports producing build outputs. 
// These are the actual files.  It derives from IVsOutput,
// and therefore supports exposing objects within outputs as in 6.0.
[
    uuid(uuid_IVsOutput2),
    version(1.0),
    pointer_default(unique)
]
interface IVsOutput2 : IVsOutput
{
    // get_RelativePath is useful for web-based project outputs from which the relative path
    // cannot automatically be calculated (because they're not currently local, and ergo
    // don't match up with the value of get_RootURL on the project cfg).  This is almost
    // identical to the same method in the now-obsolete IVsDeployWebProject interface.
    HRESULT get_RootRelativeURL([out] BSTR *pbstrRelativePath); 

    // This is a catch-all to handle coordination between third-party projects and their
    // deployment plugins.  The property and its variant type are known to both sides.
    HRESULT get_Property([in]LPCOLESTR szProperty,[out] VARIANT *pvar);
};

//-----------------------------------------------------------------------------
// IVsDeployDependency
//-----------------------------------------------------------------------------
// Implemented by a project system that supports producing build outputs. 
// These are dependencies of the IVsOutputGroup, required for deployment.
[
    uuid(uuid_IVsDeployDependency),
    version(1.0),
    pointer_default(unique)
]
interface IVsDeployDependency : IUnknown
{
    HRESULT get_DeployDependencyURL([out] BSTR *pbstrURL); // Location of dependency (local, UNC, or web)
};

//-----------------------------------------------------------------------------
// IVsProjectDeployDependency
//-----------------------------------------------------------------------------
// Implemented by a project system that supports producing build outputs. 
// These are dependencies which are built in VS7, and so we want a pointer back to their project
// for the purposes of debugging.
[
    uuid(uuid_IVsProjectDeployDependency),
    version(1.0),
    pointer_default(unique)
]
interface IVsProjectDeployDependency : IVsDeployDependency
{
    HRESULT get_ProjectInfo([out]IVsHierarchy **ppIVsHierarchy, [out]IVsProjectCfg **ppIVsProjectCfg); // Location of dependency (local, UNC, or web)
};

//-----------------------------------------------------------------------------
// IVsDependency
//-----------------------------------------------------------------------------
// Root interface for dependency objects.
cpp_quote("extern const __declspec(selectany) GUID GUID_VS_DEPTYPE_BUILD_PROJECT = { /* 707d11b6-91ca-11d0-8a3e-00a0c91e2acd */")
cpp_quote("    0x707d11b6,")
cpp_quote("    0x91ca,")
cpp_quote("    0x11d0,")
cpp_quote("    {0x8a, 0x3e, 0x00, 0xa0, 0xc9, 0x1e, 0x2a, 0xcd}")
cpp_quote("  };")


[
    uuid(uuid_IVsDependency),
    version(1.0),
    pointer_default(unique)
]
interface IVsDependency : IUnknown
{
    // Dependencies may be anonymous (not   having a canonical name), in which case
    // *pbstrCanonicalName must be set to   NULL.
    HRESULT get_CanonicalName([out] BSTR *pbstrCanonicalName);
    HRESULT get_Type([out] GUID *pguidType);
    HRESULT get_Description([out]   BSTR *pbstrDescription);
    HRESULT get_HelpContext([out]   DWORD *pdwHelpContext);
    HRESULT get_HelpFile([out] BSTR *pbstrHelpFile);
}


//-----------------------------------------------------------------------------
// IVsBuildDependency
//-----------------------------------------------------------------------------
// Implemented by a project system that supports producing build outputs. 
// The IVsBuildDependency interface is used by projects which wish to
// expose an inherent dependency in the global build order of projects.
//
// IVsBuildDependency dependencies must only be revealed by the
// project object (e.g. the same object that supports IVsProjectCfgProvider
// and IVsUIHierarchy).
//
// At some point we may permit them to be exposed by project configurations.
[
    uuid(uuid_IVsBuildDependency),
    version(1.0),
    pointer_default(unique)
]
interface IVsBuildDependency : IVsDependency
{
    // The MustUpdateBefore property must be TRUE if the project
    // must be updated before building this project.  If it is
    // FALSE, it is an indication that building this project will
    // cause the referred project to require building.
    HRESULT get_MustUpdateBefore([out] BOOL *pfMustUpdateBefore);

    // An IUnknown pointer for the project object to which this project
    // refers.
    HRESULT get_ReferredProject([out] IUnknown **ppIUnknownProject);
}


//-----------------------------------------------------------------------------
// IVsEnumDependencies
//-----------------------------------------------------------------------------
// Implemented by a project system that supports producing build outputs. 
[
    uuid(uuid_IVsEnumDependencies),
    version(1.0),
    pointer_default(unique)
]
interface IVsEnumDependencies : IUnknown
{
    HRESULT Reset();
    HRESULT Next([in] ULONG cElements, [in, out, size_is(cElements)] IVsDependency *rgpIVsDependency[], [out] ULONG *pcElementsFetched);
    HRESULT Skip([in] ULONG cElements);
    HRESULT Clone([out] IVsEnumDependencies **ppIVsEnumDependencies);
}

//-----------------------------------------------------------------------------
// IVsDependencyProvider
//-----------------------------------------------------------------------------
// Implemented by a project system that supports producing build outputs. 
// Interface is retrieved by QI from the project's IVsHierarchy.
[
    uuid(uuid_IVsDependencyProvider),
    version(1.0),
    pointer_default(unique)
]
interface IVsDependencyProvider : IUnknown
{
    HRESULT EnumDependencies([out] IVsEnumDependencies **ppIVsEnumDependencies);
    HRESULT OpenDependency([in] LPCOLESTR szDependencyCanonicalName, [out] IVsDependency **ppIVsDependency);
}

typedef enum __VSPROPERTYSTREAMPROPERTYTYPE
{
    VSPSPT_SIMPLE = 1,                  // simple property
    VSPSPT_PROPERTY_SECTION = 2,        // substream within the property stream
} VSPROPERTYSTREAMPROPERTYTYPE;

//-----------------------------------------------------------------------------
// IVsPropertyStreamIn
//-----------------------------------------------------------------------------
// Implemented by the Environment. 
// Used in conjunction with IVsStructuredFileIOHelper interface.
// Passed into IVsPersistPropertyStream::Load.
[
    uuid(uuid_IVsPropertyStreamIn),
    version(1.0),
    pointer_default(unique)
]
interface IVsPropertyStreamIn : IUnknown
{
    HRESULT Read(
        [in] ULONG cchPropertyName,
        [in, out, size_is(cchPropertyName)] OLECHAR szPropertyName[],
        [out] ULONG *pcchPropertyNameActual,
        [out] VSPROPERTYSTREAMPROPERTYTYPE *pvspspt,
        [out] VARIANT *pvarValue,
        [in] IErrorLog *pIErrorLog);
    HRESULT SkipToEnd();
}

//-----------------------------------------------------------------------------
// IVsPropertyFileIn
//-----------------------------------------------------------------------------
// Implemented by the Environment. 
// Used in conjunction with IVsStructuredFileIOHelper interface.
[
    uuid(uuid_IVsPropertyFileIn),
    version(1.0),
    pointer_default(unique)
]
interface IVsPropertyFileIn : IVsPropertyStreamIn
{
    HRESULT Close();
}

//-----------------------------------------------------------------------------
// IVsPropertyStreamOut
//-----------------------------------------------------------------------------
// Implemented by the Environment. 
// Used in conjunction with IVsStructuredFileIOHelper interface.
// Passed into IVsPersistPropertyStream::Save.
[
    uuid(uuid_IVsPropertyStreamOut),
    version(1.0),
    pointer_default(unique)
]
interface IVsPropertyStreamOut : IUnknown
{
    HRESULT Write(
        [in] LPCOLESTR szPropertyName,
        [in] VARIANT varValue,
        [in, optional] LPCOLESTR szLineComment);

    HRESULT WriteSzAsBSTR(
        [in] LPCOLESTR szPropertyName,
        [in] LPCOLESTR szValue,
        [in, optional] LPCOLESTR szLineComment);

    HRESULT BeginPropertySection(
        [in] LPCOLESTR szName,
        [in] LPCOLESTR szLineComment,
        [out] IVsPropertyStreamOut **ppIVsPropertyStreamOut,
        [out] VSCOOKIE *pdwCookie);
    HRESULT EndPropertySection([in] VSCOOKIE dwCookie);

    HRESULT Flush(); // Must be called before continuing an outer property stream
}

//-----------------------------------------------------------------------------
// IVsPropertyFileOut
//-----------------------------------------------------------------------------
// Implemented by the Environment. 
// Used in conjunction with IVsStructuredFileIOHelper interface.
[
    uuid(uuid_IVsPropertyFileOut),
    version(1.0),
    pointer_default(unique)
]
interface IVsPropertyFileOut : IVsPropertyStreamOut
{
    HRESULT Close();
}


//-----------------------------------------------------------------------------
// IVsStructuredFileIOHelper
//-----------------------------------------------------------------------------
// Implemented by the Environment.
// The IVsStructuredFileIOHelper interface is provided to load tokens found
// in persisted files that are to be loaded with localized strings.  For example,
// the VSEE IVsStructuredFileIO implementation looks for property values of
// the form "#nnnn" (where nnnn is a series of decimal digits) and will request
// string ID nnnn to be loaded via IVsStructuredFileIOHelper::LoadLocalizedString().
[
    uuid(uuid_IVsStructuredFileIOHelper),
    version(1.0),
    pointer_default(unique)
]
interface IVsStructuredFileIOHelper : IUnknown
{
    HRESULT LoadLocalizedString(ULONG ulStringID, BSTR *pbstr);
}


//-----------------------------------------------------------------------------
// IVsStructuredFileIO
//-----------------------------------------------------------------------------
// Implemented by the Environment.
// The IVsStructuredFileIO interface is designed to provide a common way to
// do multi-format saves, and includes some rudimentary support for working
// with IPersistFileFormat.  The IPersistFileFormat support (the nFormatIndex
// and the GetFormatList() method) is oriented towards a single semantic file
// type (VB project file, VC project file etc.) which can be saved in any of
// a number of on-disk formats such as UTF-8, Unicode or MBCS.
[
    uuid(uuid_IVsStructuredFileIO),
    version(1.0),
    pointer_default(unique)
]
interface IVsStructuredFileIO : IUnknown
{
    HRESULT CreateNew(
        [in] LPCOLESTR szFileName,
        [in] ULONG nFormatIndex,
        [in] DWORD dwShareMode,
        [in] DWORD dwCreationDisposition,
        [in] DWORD dwFlagsAndAttributes,
        [in] IVsStructuredFileIOHelper *pIVsStructuredFileIOHelper,
        [in] LPCOLESTR szFormatVersion,
        [in] LPCOLESTR szDescription,
        [out] IVsPropertyFileOut **ppIVsPropertyFileOut);

    HRESULT OpenExisting(
        [in] LPCOLESTR szFileName,
        [in] DWORD dwShareMode,
        [in] DWORD dwCreationDisposition,
        [in] DWORD dwFlagsAndAttributes,
        [in] IVsStructuredFileIOHelper *pIVsStructuredFileIOHelper,
        [out] ULONG *pnFormatIndex,
        [out] IVsPropertyFileIn **ppIVsPropertyFileIn,
        [out, optional] BSTR *pbstrFormatVersion);

    HRESULT GetFormatList(
        [in] LPCOLESTR szEntityName, // e.g. L"VB Project File", or "VC Project File"
        [in] LPCOLESTR szFileTypes,  // semicolon separated list of file extensions (e.g. "abc;xyz")
        [out] LPOLESTR *ppszFormatList);

    HRESULT GetFormatInfo(
        [in] ULONG nFormatIndex,
        [out, optional] UINT *puiCodePage);

    HRESULT FindFormatIndex(
        [in] UINT uiCodePage,
        [out, optional] ULONG *pnFormatIndex);
}

cpp_quote("#define SID_SVsStructuredFileIO IID_IVsStructuredFileIO")

//-----------------------------------------------------------------------------
// IVsHTMLConverter
//-----------------------------------------------------------------------------
// Implemented by the Environment. 
// Used by the debugger.
[
    uuid(uuid_IVsHTMLConverter),
    version(1.0)
]
interface IVsHTMLConverter : IUnknown
{
    HRESULT get_DefaultURLEncodingCodePage([out]UINT *pulCodePage);
    HRESULT ConvertToEntities(
        [in] LPCOLESTR szToConvert, 
        [in] ULONG cchBuffSize,
        [in, out,   size_is(cchBuffSize)] OLECHAR szBuffer[],
        [out]   ULONG *pcchBuffSizeActual);
    HRESULT ConvertFromEntities(
        [in] LPCOLESTR szToConvert, 
        [in] ULONG cchBuffSize,
        [in, out,   size_is(cchBuffSize)] OLECHAR szBuffer[],
        [out]   ULONG *pcchBuffSizeActual);
    HRESULT ConvertToURLEncoding(
        [in] UINT   uCodePage,
        [in] LPCOLESTR szToConvert, 
        [in] ULONG cchBuffSize,
        [in, out,   size_is(cchBuffSize)] OLECHAR szBuffer[],
        [out]   ULONG *pcchBuffSizeActual);
    HRESULT ConvertFromURLEncoding(
        [in] UINT   uCodePage,
        [in] LPCOLESTR szToConvert, 
        [in] ULONG cchBuffSize,
        [in, out,   size_is(cchBuffSize)] OLECHAR szBuffer[],
        [out]   ULONG *pcchBuffSizeActual);
}
cpp_quote("#define SID_SVsHTMLConverter IID_IVsHTMLConverter")

// Used by VB:
cpp_quote("#ifndef __ENUMVSDEPLOYSERVICEENUMS")
cpp_quote("#define __ENUMVSDEPLOYSERVICEENUMS")
enum __VSDPLSVCSINPROJECT
{
    // One or more must be specified, based on what the project contains:
    VSDPLSVCSINPROJECT_WEB = 0x00000001,
    VSDPLSVCSINPROJECT_SERVER = 0x00000002,
    VSDPLSVCSINPROJECT_MTS = 0x00000004
};
typedef DWORD VSDPLSVCSINPROJECT;
cpp_quote("#endif")

//-----------------------------------------------------------------------------
// IVsUpdateSolutionEvents[2]
//-----------------------------------------------------------------------------
// Implemented by clients curious to know of build events.
[
    uuid(uuid_IVsUpdateSolutionEvents),
    version(1.0),
    pointer_default(unique)
]
interface IVsUpdateSolutionEvents : IUnknown
{
    // UpdateSolution_Begin informs listener's that an update   actions(s) may be about to begin.
    // This is sent BEFORE any dependency   checking or UI prompts.
    // A component can set *pbCancel to TRUE to cancel the update   actions.
    // If   this event is sent the UpdateSolution_Done event should be expected whether or not it is canceled.
    HRESULT UpdateSolution_Begin([in,   out] BOOL *pfCancelUpdate);

    // fSucceeded   is TRUE if no update actions failed
    // fModified is TRUE if any update action   succeeded
    // fCancelCommand   is TRUE if update actions was canceled
    HRESULT UpdateSolution_Done([in] BOOL   fSucceeded, [in] BOOL fModified, [in] BOOL fCancelCommand);

    // UpdateSolution_StartUpdate   is sent just prior to the first update action begins
    // it   is the last chance to cancel the update
    HRESULT UpdateSolution_StartUpdate( [in, out]   BOOL *pfCancelUpdate );

    // Inform   that update actions is being cancelled.
    HRESULT UpdateSolution_Cancel();

    // The OnActiveProjectCfgChange()   event is fired after the active project configuration for
    // a project in the solution has been   changed.  If NULL
    // is   passed for pIVsHierarchy, sinks for this event have to assume that
    // every project in the solution may have   changed, even if there is only one project
    // active   in the solution.
    HRESULT OnActiveProjectCfgChange([in]   IVsHierarchy *pIVsHierarchy);
}

[
    uuid(uuid_IVsUpdateSolutionEvents2),
    version(1.0),
    pointer_default(unique)
]
interface IVsUpdateSolutionEvents2 : IVsUpdateSolutionEvents
{
    HRESULT UpdateProjectCfg_Begin([in] IVsHierarchy *pHierProj,
        [in] IVsCfg *pCfgProj,
        [in] IVsCfg *pCfgSln,
        [in] DWORD  dwAction,
        [in, out] BOOL  *pfCancel);
    HRESULT UpdateProjectCfg_Done([in] IVsHierarchy *pHierProj,
        [in] IVsCfg *pCfgProj,
        [in] IVsCfg *pCfgSln,
        [in] DWORD dwAction,
        [in] BOOL fSuccess,
        [in] BOOL fCancel);
}

//-----------------------------------------------------------------------------
// IVsSolutionBuildManager[2]
//-----------------------------------------------------------------------------
// Implemented by the Environment.
// The SolutionBuildManager coordinates all Build, Deploy, and Debug Launch operations. 
typedef enum __VSSOLNBUILDQUERYRESULTS
{
    VSSBQR_OUTOFDATE_QUERY_YES          = 0x0000,
    VSSBQR_OUTOFDATE_QUERY_NO               = 0x0001,
    VSSBQR_OUTOFDATE_QUERY_CANCEL           = 0x0002,

    VSSBQR_SAVEBEFOREBUILD_QUERY_YES        = 0x0000,
    VSSBQR_SAVEBEFOREBUILD_QUERY_NO     = 0x0004,
    VSSBQR_SAVEBEFOREBUILD_QUERY_CANCEL = 0x0008,

    VSSBQR_CONTDEPLOYONERROR_QUERY_YES  = 0x0000,
    VSSBQR_CONTDEPLOYONERROR_QUERY_NO       = 0x0010,

    VSSBQR_CONTLAUNCHONERROR_QUERY_YES  = 0x0000,
    VSSBQR_CONTLAUNCHONERROR_QUERY_NO       = 0x0020,
} VSSOLNBUILDQUERYRESULTS;

typedef enum __VSSOLNBUILDUPDATEFLAGS
{
    // The first set is UI supression   flags; if they are set the default answer is automatically chosen.
    SBF_SUPPRESS_NONE           = 0x00000000,
    SBF_SUPPRESS_OUTOFDATE_QUERY            = 0x00000001,       // Take default answer for out of date query 
    SBF_SUPPRESS_SAVEBEFOREBUILD_QUERY  = 0x00000002,       // Take default answer for save before build query 
    SBF_SUPPRESS_CONTDEPLOYONERROR_QUERY    = 0x00000004,       // Take default answer for continue deploy query 
    SBF_SUPPRESS_CONTLAUNCHONERROR_QUERY    = 0x00000008,       // Take default answer for continue launch query 
    SBF_SUPPRESS_MASK                       = 0x000000FF,

    // This set of flags is used to control which   operations the solution update manager will
    // perform as   part of its operation.  
    SBF_OPERATION_NONE          = 0x00000000,       // No build operations are to be performed
    SBF_OPERATION_BUILD         = 0x00010000,       // Perform build (may be ORed with other flags)
    SBF_OPERATION_DEPLOY            = 0x00020000,       // Deploy solution (may be ORed with other flags)
    SBF_OPERATION_LAUNCH            = 0x00040000,       // Launch the application without the debugger involved
    SBF_OPERATION_LAUNCHDEBUG       = 0x00080000,       // Launch the application for debugging
    SBF_OPERATION_CLEAN         = 0x00100000,       // Remove built objects
    SBF_OPERATION_SELECTION     = 0x00200000,       // Operate on the current shell selection context
    SBF_OPERATION_FORCE_UPDATE      = 0x00400000,       // Force a rebuild on the project, even if it is not out of
    // date; for SBF_OPERATION_BUILD, projects will recompile
    // results even if they are not out of date; for
    // SBF_OPERATION_DEPLOY, the content will be re-copied to the
    // deployment target even if it is known not to be out of
    // date at the target.
    SBF_OPERATION_MASK                  = 0xFFFF0000,
} VSSOLNBUILDUPDATEFLAGS;

cpp_quote("#define SID_SVsSolutionBuildManager IID_IVsSolutionBuildManager")

[
    uuid(uuid_IVsSolutionBuildManager),
    version(1.0),
    pointer_default(unique)
]
interface IVsSolutionBuildManager : IUnknown
{
    HRESULT DebugLaunch([in] VSDBGLAUNCHFLAGS   grfLaunch);
    HRESULT StartSimpleUpdateSolutionConfiguration(
        [in] DWORD dwFlags, /* SUPPRESS_NOTEXISTS_QUERY | SUPPRESS_OUTOFDATE_QUERY */
        [in] DWORD dwDefQueryResults, /* NOTEXISTS_QUERY_YES,_NO, _CANCEL */
        [in] BOOL fSuppressUI);

    HRESULT AdviseUpdateSolutionEvents([in] IVsUpdateSolutionEvents *pIVsUpdateSolutionEvents, [out] VSCOOKIE   *pdwCookie);
    HRESULT UnadviseUpdateSolutionEvents([in]   VSCOOKIE dwCookie);

    // UpdateSolutionConfigurationIsActive checks   for any generic deploy/build/clean action in progress.
    HRESULT UpdateSolutionConfigurationIsActive([out]   BOOL *pfIsActive);

    // CanCancelUpdateSolutionConfiguration can be used to enable/disable   Cancel menu item.  
    HRESULT CanCancelUpdateSolutionConfiguration([out] BOOL *pfCanCancel);

    HRESULT CancelUpdateSolutionConfiguration();

    HRESULT QueryDebugLaunch([in]   VSDBGLAUNCHFLAGS grfLaunch, [out] BOOL *pfCanLaunch);
    HRESULT QueryBuildManagerBusy([out] BOOL *pfBuildManagerBusy);

    // The FindActiveProjectCfg()   method determines the project configuration which
    // is   currently active. 
    HRESULT FindActiveProjectCfg([in,   unique] IVsHierarchy *pvReserved1,   // must be NULL
        [in,    unique] LPCOLESTR pvReserved2,   // must be NULL
        [in,    unique] IVsHierarchy *pIVsHierarchy_RequestedProject,
        [out, optional] IVsProjectCfg **ppIVsProjectCfg_Active);

    // Obsolete method
    HRESULT get_IsDebug([out]   BOOL *pfIsDebug);
    // Obsolete method
    HRESULT put_IsDebug([in] BOOL   fIsDebug);

    // Obsolete method
    HRESULT get_CodePage([out] UINT *puiCodePage);
    // Obsolete method
    HRESULT put_CodePage([in]   UINT uiCodePage);

    // This is a variant of the update command which allows someone to build/clean/deploy/Launch
    // a single project configuration   
    HRESULT StartSimpleUpdateProjectConfiguration(
        [in] IVsHierarchy *pIVsHierarchyToBuild,            // Project to build
        [in] IVsHierarchy *pIVsHierarchyDependent,          // optional dependent project in the dependency graph
        [in] LPCOLESTR pszDependentConfigurationCanonicalName, // optional dependent project configuration canonical name
        [in] DWORD dwFlags, /* SUPPRESS_NOTEXISTS_QUERY | SUPPRESS_OUTOFDATE_QUERY */
        [in] DWORD dwDefQueryResults, /* NOTEXISTS_QUERY_YES,_NO, _CANCEL */
        [in] BOOL fSuppressUI
        );

    HRESULT get_StartupProject([out] IVsHierarchy   **ppHierarchy);
    HRESULT set_StartupProject([in] IVsHierarchy *pHierarchy);

    // returns a list   of projects that the given hier depends on. 
    // Also see the IVsSolutionBuildManager::CalculateProjectDependencies   for more info
    HRESULT GetProjectDependencies([in] IVsHierarchy *pHier, 
        [in] ULONG  celt,
        [in, out, size_is(celt)] IVsHierarchy *rgpHier[],
        [out, optional] ULONG *pcActual);
}

[
    uuid(uuid_IVsSolutionBuildManager2),
    version(1.0),
    pointer_default(unique)
]
interface IVsSolutionBuildManager2 : IVsSolutionBuildManager
{
    // builds/cleans/deploys a list of projects
    HRESULT StartUpdateProjectConfigurations([in]   UINT  cProjs,
        [in,    size_is(cProjs)] IVsHierarchy *rgpHierProjs[],          // Projects to build
        [in]    DWORD dwFlags,                                                  // VSSOLNBUILDUPDATEFLAGS
        [in]    BOOL fSuppressUI);
    // Call this to force   project dependencies to be recalculated. This should be called prior to calling
    // GetProjectDependencies   if you are unsure if the dependencies are up to date at the point of the call.
    // Also, call   this method after you have changed the project dependencies provided by your project's
    // IVsDependencyProvider
    HRESULT CalculateProjectDependencies();

    // This method can be   used to check if one project is dependent on another project.
    // *pfIsDependentOn is TRUE if pHier depends on pHierDependentOn
    // Note: same   caveats about calling CalculateProjectDependencies apply  
    HRESULT QueryProjectDependency([in] IVsHierarchy *pHier, [in]   IVsHierarchy *pHierDependentOn, [out] BOOL *pfIsDependentOn);

    // If   a project implements it's own build/run mechanism to support a more granular level than the entire project, it can call this method
    // to   ensure that the buildable/runnable components are saved before it starts building/running. This method respects the user setting
    // given by the VSSPROPID_PreBuildRunPreview shell property &   will prompt or save or dont save accordingly. Also documents registered 
    // with RDT_CanBuildFromMemory will not be saved.
    HRESULT SaveDocumentsBeforeBuild([in]   IVsHierarchy *pHier, [in] VSITEMID itemid, [in] VSCOOKIE docCookie);

    //
    // Use this method to   have total control of a build. 
    // Only specified   projects & cfgs will be built
    // i.e. dependent   projects will not be built.
    // 
    // the Clean/Build/Deploy   flags all default to 0 if unspecified 
    //
    HRESULT StartUpdateSpecificProjectConfigurations([in]   UINT cProjs,                                // count of projects
        [in,    size_is(cProjs)] IVsHierarchy *rgpHier[],   // projects to build
        [in,    size_is(cProjs)] IVsCfg *rgpCfg[],      // specific cfgs to build. Will use active projcfg if NULL. cfg must be
        // a cfg in the corresponding project in rgpHier.
        [in,    size_is(cProjs)] DWORD rgdwCleanFlags[],    // dwOptions param to IVsBuildableProjectCfg::StartBuild. Can be NULL
        [in,    size_is(cProjs)] DWORD rgdwBuildFlags[],    // dwOptions param to IVsBuildableProjectCfg::StartBuild. Can be NULL
        [in,    size_is(cProjs)] DWORD rgdwDeployFlags[],       // dwOptions param to IVsDeployableCfg::StartDeploy. Can be NULL
        [in]    DWORD dwFlags,                              // SBF_* flags
        [in]    BOOL fSuppressUI);  
}

//---------------------------------------------------------------------------
// IVsAppCommandLine
//---------------------------------------------------------------------------
// Implemented by the Environment.
// Allow packages to query which switches (or options) were passed on the application commandline
// A package can register under the HKLM/.../AppCommandLine key a sub key that is a new commandline
// switch. The following can be specified as values on this sub key:
//    DemandLoad  REG_DWORD  0 | 1 -- if 1, then auto load package if switch is present
//    Package     REG_SZ     GUID of package to be demand loaded
//    HelpString  REG_SZ     #<string resid> -- localized help string for "/?"
//    Arguments   REG_SZ     [optional] "*" indicates that remainder of command line is 
//                           ignored and treated as the value of this switch.
[
    uuid(C7F21561-D58A-11d2-BF4A-0080C728D9A0),
    version(1.0)
]
interface IVsAppCommandLine: IUnknown
{
    HRESULT GetOption([in] LPCOLESTR pszOptionName, [out]   BOOL* pfPresent, [out, retval] BSTR* pbstrOptionValue);
}

cpp_quote("#define SID_SVsAppCommandLine IID_IVsAppCommandLine")

//-----------------------------------------------------------------------------
// IVsLibraryReferenceManager
//-----------------------------------------------------------------------------
// Implemented by the Environment on the .NET (COM+) LibraryManager.
// Used by project systems that have references to .NET (COM+) Assemblies to provide
// browse information for Object Browser.
[
    uuid(uuid_IVsLibraryReferenceManager)
]
interface IVsLibraryReferenceManager : IUnknown
{
    // Called   by the project when adding a reference to component identified by its path
    HRESULT AddComponentReference([in] LPCOLESTR wszPath,   [in] IUnknown* pVsLibrary);

    // Called   by the project when removing a reference to component identified by its path
    HRESULT RemoveComponentReference([in]   LPCOLESTR wszPath, [in] IUnknown* pVsLibrary);

    // Called   by the project referencing a componenet identified by it path when it is 
    // brought into scope   i.e. when it is checked in scoping dialog
    HRESULT IncrementCheckCount([in] LPCOLESTR wszPath, [in] IUnknown* pVsLibrary);

    // Called   by the project referencing a componenet identified by it path when it is 
    // taken out of scope   i.e. when it is unchecked in scoping dialog
    HRESULT DecrementCheckCount([in] LPCOLESTR wszPath, [in] IUnknown* pVsLibrary);

    // Takes in VSOBJECTINFO*   which identifies a object and returns an Index to a returned VsObjectList
    // corresponding the object i.e. the object is in   the VsObjectList at the position specified by Index.
    // The class name   should be unqualified eg for System.String the passed in vsObjectInfo should have:
    // something like   the following:

    // vsObjInfo.pguidLib   = NULL
    // vsObjInfo.pszLibName =   "C:\VS\vsbuilt\debug\bin\i386\complus\mscorlib.dll"
    // vsObjInfo.pszNspcName = L"System";
    // vsObjInfo.pszClassName   = L"String";

    // Note that at present pguidLib is ignored since   the obtaining the IVsLibraryReferenceManager interface pointer through 
    // the service is   specific to the library.
    HRESULT GetListIndex([in]   VSOBJECTINFO *pobjInfo, [out] IVsObjectList** ppList, [out] ULONG *pIndex);
}

cpp_quote("#define SID_SVsComplusLibrary IID_IVsLibraryReferenceManager")

//---------------------------------------------------------------------------
// IVsBatchUpdate
//---------------------------------------------------------------------------
// Any editor view or buffer that needs to process updates in a batch delayed manor can
// implement this interface. Example: The VS text buffer will implement this interface and
// any compiler or build system which requires the buffer be up to date will QI the buffer
// for this interface and call FlushPendingUpdates. The text buffer will then QI all of
// it's registered independent views for this interface and FW this request to them
[
    uuid(uuid_IVsBatchUpdate),
    version(1.0)
]
interface IVsBatchUpdate: IUnknown
{
    HRESULT FlushPendingUpdates(DWORD   dwReserved);
}

//---------------------------------------------------------------------------
// VSTRANSACCELFLAGS
//---------------------------------------------------------------------------
// Flags for IVsFilterKeys::TranslateAccelerator
enum __VSTRANSACCELFLAGS
{
    VSTAF_Default            = 0x00000000,
    VSTAF_NoFireCommand  = 0x00000001
};
typedef DWORD VSTRANSACCELFLAGS;

//---------------------------------------------------------------------------
// IVsFilterKeys
//---------------------------------------------------------------------------
// Interface for clients to perform advanced keyboard message translation
[
    uuid(uuid_IVsFilterKeys),
    version(1.0),
    pointer_default(unique)
]
interface IVsFilterKeys: IUnknown
{
    // Called   to determine what command the specified Windows message will be
    // translated   into given the current set of active keybinding scopes,
    // and optionally   to fire the cmd.  If the msg did/will translate to a
    // command, this method returns S_OK and fills the in/out   params with the
    // commands guid/id pair.    If the msg did/will not translate to a command,
    // this method returns S_FALSE, and sets the in/out params to   zeros.
    HRESULT TranslateAccelerator([in]   LPMSG pMsg, [in] VSTRANSACCELFLAGS dwFlags, [out] GUID *pguidCmd, [out] DWORD *pdwCmd);
}

cpp_quote("#define SID_SVsFilterKeys IID_IVsFilterKeys")

//*********************************************************************************
//*********************************************************************************
// OBSOLETE OBSOLETE OBSOLETE OBSOLETE OBSOLETE OBSOLETE OBSOLETE OBSOLETE OBSOLETE
// OBSOLETE OBSOLETE OBSOLETE OBSOLETE OBSOLETE OBSOLETE OBSOLETE OBSOLETE OBSOLETE
//
// This section contains obsolete interfaces. These interfaces may or may not have
// implementations.
//
// OBSOLETE OBSOLETE OBSOLETE OBSOLETE OBSOLETE OBSOLETE OBSOLETE OBSOLETE OBSOLETE
// OBSOLETE OBSOLETE OBSOLETE OBSOLETE OBSOLETE OBSOLETE OBSOLETE OBSOLETE OBSOLETE
//*********************************************************************************
//*********************************************************************************

// obsolete/renamed constants
cpp_quote("#define VSPROPID_ExtraSolutionPropertyPages VSPROPID_SolutionPropertyPages")
cpp_quote("#define VSCFGPROPID_SupportsCfgEditing      1")
cpp_quote("#define VSCFGPROPID_SupportsPlatformEditing 2")
cpp_quote("#define RIEF_OPENASMISCFILE 0")

// OBSOLETE - no implementation
[
    uuid(uuid_IVsSolutionSecurityOptions),
    version(1.0),
    pointer_default(unique)
]
interface IVsSolutionSecurityOptions : IUnknown
{
    // These are readable   ONLY!
    HRESULT get_SignCabinets([out]BOOL *pfSignCabinets);
    HRESULT get_UseTestCertificate([out]BOOL *pfUseTestCertificate);
    HRESULT get_UseCertificateFile([out]BOOL *pfUseCertificateFile);
    HRESULT get_CertificateFile([out]BSTR   *pbstrCertificateFile);
    HRESULT get_PrivateKeyFile([out]BSTR *pbstrPrivateKeyFile);
    HRESULT get_TimestampServerURL([out]BSTR *pbstrTimestampServerURL);
}

//-----------------------------------------------------------------------------
// IVsLangSpecificSyntax
//-----------------------------------------------------------------------------
// OBSOLETE interface.
[
    uuid(uuid_IVsLangSpecificSyntax)
]
interface IVsLangSpecificSyntax : IUnknown
{
    HRESULT GetText([in] VSOBJECTINFO   *pobjInfo, [in] VSTREETEXTOPTIONS tto, [out] const WCHAR **ppszText);
    HRESULT FillDescription([in] VSOBJECTINFO   *pobjInfo, [in] IVsObjectBrowserDescription2 *pobDesc);
    HRESULT GetSyntaxGuid([out] const   GUID *pguid);
}


//-----------------------------------------------------------------------------
// IVsProjectSpecialFiles
// Allow to query the project for special files and optionally create them.
//-----------------------------------------------------------------------------
enum __PSFFILEID
{
    // !!!! NOTE !!!!   THIS MUST BE THE SAME AS THE FIRST PROP DEFINED
    PSFFILEID_LAST                = -1000,

    PSFFILEID_AppConfig           = -1000,
    PSFFILEID_Licenses            = -1001,

    // !!!! NOTE !!!!   THIS MUST BE THE SAME AS THE LAST PROP DEFINED
    PSFFILEID_FIRST               = -1001
};
typedef LONG PSFFILEID;

enum __PSFFLAGS
{
    PSFF_CreateIfNotExist   = 0x00000001,
    PSFF_FullPath   = 0x00000002
};
typedef DWORD PSFFLAGS;

[
    uuid(uuid_IVsProjectSpecialFiles)
]
interface IVsProjectSpecialFiles: IUnknown
{
    HRESULT GetFile([in] PSFFILEID fileID, 
        [in] PSFFLAGS   grfFlags,
        [out]   VSITEMID* pitemid,
        [out]   BSTR* pbstrFilename);
}

cpp_quote("extern const __declspec(selectany) GUID GUID_VS_OTYPE_PACKAGE = { /* 707d11bb-91ca-11d0-8a3e-00a0c91e2acd */")
cpp_quote("    0x707d11bb,")
cpp_quote("    0x91ca,")
cpp_quote("    0x11d0,")
cpp_quote("    {0x8a, 0x3e, 0x00, 0xa0, 0xc9, 0x1e, 0x2a, 0xcd}")
cpp_quote("  };")

cpp_quote("extern const __declspec(selectany) GUID GUID_VS_OTYPE_ACTIVEX = { /* CCB25051-4FE3-11d1-A1F9-0000F8026F55 */")
cpp_quote("    0xccb25051,")
cpp_quote("    0x4fe3,")
cpp_quote("    0x11d1,")
cpp_quote("    { 0xa1, 0xf9, 0x0, 0x0, 0xf8, 0x2, 0x6f, 0x55 }")
cpp_quote("  };")

//----------------------------------------------------------------------------
// interface IVsComReferenceDlgEvents [OBSOLETE]
//----------------------------------------------------------------------------
// Callback events that are fired when the user is interacting with the COM Reference dialog.
//
// OBSOLETE - no implementation (see IVsComponentSelectorDlg)
[
    uuid(uuid_IVsComReferenceDlgEvents),
    version(1.0),
    pointer_default(unique)
]
interface IVsComReferenceDlgEvents : IUnknown
{
    // anything other than S_OK will prevent the check/uncheck from taking place.
    HRESULT OnQueryChecked([in] PCOMREFERENCEINFO pItem);
    HRESULT OnQueryUnchecked([in] PCOMREFERENCEINFO pItem);
    // this will contain a list of all typelibs that are not in the local registry.
    // VB won't use this, but VID may want to as developers share a project across the
    // web.  Note that the rgItems list here is "live", so callees can modify its values.
    HRESULT OnWarnMissingTypelibs([in] UINT cCnt, [in, size_is(cCnt)] PCOMREFERENCEINFO *rgpItems);
};

//----------------------------------------------------------------------------
// ShowReferencesDialog can show both non-visual and visual (control) typelibs.
//  Use these flags to decide which ones to show.  They may be OR'd together.
//----------------------------------------------------------------------------
// OBSOLETE constants
typedef enum
{
    REFSHOW_fLibraries  =   0x01,
    REFSHOW_fControls     = 0x02,
    REFSHOW_fNoPriority =   0x04
} _REFSHOWFLAGS;
typedef DWORD REFSHOWFLAGS;

//----------------------------------------------------------------------------
// interface IVsComReferenceDlg [OBSOLETE]
//----------------------------------------------------------------------------
// Implemented by the Environment. This interface provides the COM "Add References"
// dialog.  Access this through ILocalRegistry::CreateInstance(CLSID_VsComReferenceDlg,...).
//
// OBSOLETE - no implementation (see IVsComponentSelectorDlg)
[
    uuid(uuid_IVsComReferenceDlg),
    version(1.0),
    pointer_default(unique)
]
interface IVsComReferenceDlg : IUnknown
{
    HRESULT AddReferences([in] UINT cRefs, [in] PCOMREFERENCEINFO rgNewRefs);
    HRESULT SetCheckedReferences([in] UINT cRefs, [in] PCOMREFERENCE rgRefs, [in] UINT cLockedRefs);
    HRESULT AdviseReferenceEvents([in] IVsComReferenceDlgEvents *pEvents, [out] VSCOOKIE *pdwCookie);
    HRESULT UnadviseReferenceEvents([in] VSCOOKIE dwCookie);
    HRESULT ShowReferencesDialog([in] REFSHOWFLAGS dwReserved, [in] LPOLESTR pszReserved);
    HRESULT EnumReferences([out] IEnumComReferences **ppenum);
    HRESULT EnumCheckedReferences([out] IEnumComReferences **ppenum);
    HRESULT EnumRemovedReferences([out] IEnumComReferences **ppenum);
    HRESULT GetReferenceInfo([in] REFGUID guidTypelib, [in] WORD wVerMajor, [in] WORD wVerMinor, [out] PCOMREFERENCEINFO *ppRefInfo);
    HRESULT FreeReferenceInfo([in] PCOMREFERENCEINFO pRefInfo);
    HRESULT GetPropertyPage( [out] DWORD_PTR *phPage, [in] LPCOLESTR   pszReserved);
    // Call this before getting a property page or showing the dialog. 
    // This allows you to tailor the display information to your needs.
    // If pszHelpFile is non-NULL, the property page / dialog will use the
    // provided help file and topic ID when the help button is pressed.
    // pszTitles is a list of strings, each NULL terminated.  The final
    // string should be terminated in a double NULL.  This allows you to
    // replace the names of certain pieces of the dialog UI:
    // First string - replaces main dialog title.
    // Second string  - replaces listview caption.
    // pszTitles can be NULL to use the defaults, and only needs to contain
    // the string replacements that you need.  (For example, a single string
    // with a double NULL would replace only the caption).
    HRESULT SetDisplayInfo([in] REFSHOWFLAGS dwShow, [in] LPOLESTR pszHelpFile, [in] DWORD dwHelpContextId, [in] LPOLESTR pszTitles);
};

cpp_quote("#define CLSID_VsComReferenceDlg IID_IVsComReferenceDlg")

