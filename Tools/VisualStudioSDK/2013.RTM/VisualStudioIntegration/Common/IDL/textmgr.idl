////////////////////////////////////////////////////////////////////////////////
// TEXTMGR.IDL
//
// Interfaces for text buffer/view management
//
// NOTE: please read the text editor architecture document for more information 
// about many of these interfaces.
//
////////////////////////////////////////////////////////////////////////////////

// imports (UNDONE:  Is there a better way to get IOleCommandTarget in?)
#ifndef INTEROPLIB

import "docobj.idl";
import "context.idl";

#else

#define IVsUserContextUpdate IUnknown
#define IVsUserContext IUnknown

#endif

#include "shared.idh"
#include "indentstyle.idh"

#include "textmgruuids.h"

/****************************************************************************
  ********    IMPORTANT!!   *********

All guids for interfaces and co-creatable objects in this file should be defined
in textmgruuids.h

****************************************************************************/


interface IVsTextBuffer;
interface IVsTextLines;
interface IVsTextStream;
interface IVsTextLayer;
interface IVsLayerModule;
interface IVsTextMarker;
interface IVsTextLineMarker;
interface IVsTextStreamMarker;
interface IVsTextLayerMarker;
interface IVsTextMarkerClient;
interface IVsTextMarkerType;
interface IVsEnumStreamMarkers;
interface IVsEnumLineMarkers;
interface IVsEnumLayerMarkers;
interface IVsEnumTextBuffers;
interface IVsEnumTextSpans;
interface IVsTextScanner;
interface IVsTextBufferEvents;
interface IVsTextBufferDataEvents;
interface IVsTextLinesEvents;
interface IVsTextStreamEvents;
interface IVsColorizer;
interface IVsColorableItem;
interface IVsProvideColorableItems;
interface IVsTextColorState;
interface IVsCompletionSet;
interface IVsTipWindow;
interface IVsTextView;
interface IVsTextViewEvents;
interface IVsTextViewFilter;
interface IVsViewRangeClient;
interface IVsTextManager;
interface IVsTextManagerEvents;
interface IVsTextSelectionAction;
interface IVsEnumTextViews;
interface IVsAction;
interface IVsCodeWindow;
interface IVsCodeWindowManager;
interface IVsSplitPane;
interface IVsSplitter;
interface IVsSplitRoot;
interface IVsLanguageInfo;
interface IVsLanguageDebugInfo;
interface IVsCompoundAction;
interface IVsCompoundActionEvents;
interface IVsMethodData;
interface IVsTextTipData;
interface IVsUserData;
interface IVsLastChangeTimeProvider;
interface IVsShortcutManager;
interface IVsDropdownBar;
interface IVsButtonBar;
interface IVsHiddenTextSession;
interface IVsTextMacroHelper;
interface IVsLanguageBlock;
interface IVsTextImage;             // simple lines-of-text abstraction
interface IVsTextImageEvents;       // change events for modifications on IVsTextImage
interface IVsEnumGUID;
interface IVsTextEditorPropertyContainer;
interface IVsTextEditorPropertyCategoryContainer;
interface IVsMergeableUIItem;
interface IVsLanguageTextOps;
interface IVsLanguageClipboardOps;
interface IVsCodeWindowEvents;
interface IVsFileBackup;
interface IVsEditorGoBackLocations;
interface IVsEnumIndependentViews;
interface IVsChangeClusterEvents;
interface IVsUndoUnit;
interface IVsUndoTrackingEvents;
interface IVsUndoRedoClusterWithCommitEvents;

#ifndef INTEROPLIB
[
    uuid(uuid_lib_TextManagerInternal),
    version(1.0)
]
library TextManagerInternal
{
#endif
    importlib("stdole32.tlb");
//    importlib("vsshell.tlb");

/*
	Error codes

	These are HRESULT values that interfaces in this IDL can return.
*/

// some general definitions
#define FACILITY_ITF                     4  // from winerror.h

#define BUFFER_FACILITY (FACILITY_ITF)
#define BUFFER_ERROR(x) (0x80000000 /* failure bit */ | (BUFFER_FACILITY << 16) /* facility bits */ | (x) /* plus the error code */)

enum TextBufferErrors
{
	// BUFFER_E_READONLY: the buffer has been marked as read-only
	BUFFER_E_READONLY			= BUFFER_ERROR(0x1001),

	// BUFFER_E_READONLY_REGION: a region has been marked as read-only
	BUFFER_E_READONLY_REGION	= BUFFER_ERROR(0x1002),

	// BUFFER_E_TIMEOUT: timed out waiting for access
	BUFFER_E_TIMEOUT			= BUFFER_ERROR(0x1003),

	// BUFFER_E_LOCKED: the buffer was locked for writing
	BUFFER_E_LOCKED				= BUFFER_ERROR(0x1004),

	// BUFFER_E_SCC_READONLY: the file backing the buffer is under source code control and checked in
	BUFFER_E_SCC_READONLY	    = BUFFER_ERROR(0x1005),

	// BUFFER_E_DEST_TOO_SMALL: the memory block passed in was too small
	BUFFER_E_DEST_TOO_SMALL		= BUFFER_ERROR(0x1006),

	// MARKER_E_INVALIDATED: you're trying to manipulate an invalid marker
	MARKER_E_INVALIDATED		= BUFFER_ERROR(0x1007),

	// MARKER_E_BUFFERDESTROYED: you're trying to manipulate a markers whose buffer has been destroyed
	MARKER_E_BUFFERDESTROYED	= BUFFER_ERROR(0x1008)


};

// some general definitions
#define VIEW_FACILITY (FACILITY_ITF)
#define VIEW_ERROR(x) (0x80000000 /* failure bit */ | (VIEW_FACILITY << 16) /* facility bits */ | (x) /* plus the error code */)

enum TextViewErrors
{
	// VIEW_E_NO_BOOKMARKS: there are no bookmarks to navigate to or delete
	VIEW_E_NO_BOOKMARKS			= VIEW_ERROR(0x2001),

	// VIEW_E_NO_DEBUGGER: there's no debugger available to handle the requested command
	VIEW_E_NO_DEBUGGER			= VIEW_ERROR(0x2002),

	// VIEW_E_USERREADONLY: this file cannot be modified in the editor
	VIEW_E_USERREADONLY			= VIEW_ERROR(0x2004),

	/*
		VIEW_E_LOCATION_HIDDEN: the location you referenced (moving selection to, scrolling into view, etc.) is not
			presently visible in this view.  Can happen during restricted view, outlining, etc.
	*/
	VIEW_E_LOCATION_HIDDEN		= VIEW_ERROR(0x2005)
};


// undo errors
#define LINKEDUNDO_FACILITY (FACILITY_ITF)
#define LINKEDUNDO_ERROR(x) (0x80000000 /* failure bit */ | (LINKEDUNDO_FACILITY << 16) /* facility bits */ | (x) /* plus the error code */)

enum LinkedUndoErrors
{
    /*
        LinkedUNDO_E_INTERVENING_ACTION: a parent action failed due to another action not being at the top of the stack.
        This will be returned from our IOleUndoManager implementation when an undo is attempted but fails.
    */
    LINKEDUNDO_E_INTERVENING_ACTION           = LINKEDUNDO_ERROR(0x3001),
};

#define UNDO_FACILITY (FACILITY_ITF)
#define UNDO_ERROR(x) (0x80000000 /* failure bit */ | (UNDO_FACILITY << 16) /* facility bits */ | (x) /* plus the error code */)

enum UndoErrors
{
    /*
        LinkedUNDO_E_INTERVENING_ACTION: a parent action failed due to another action not being at the top of the stack.
        This will be returned from our IOleUndoManager implementation when an undo is attempted but fails.
    */
    UNDO_E_CLIENTABORT           = UNDO_ERROR(0x4001),
};

#define TIP_FACILITY (FACILITY_ITF)
#define TIP_SUCCESS(x) ((TIP_FACILITY << 16) /* facility bits */ | (x) /* plus the error code */)
enum TipSuccesses
{
	TIP_S_ONLYIFNOMARKER		=TIP_SUCCESS(0x4001)
};

////////////////////////////////////////////////////////////////////////////
// Editor command table
////////////////////////////////////////////////////////////////////////////
cpp_quote("#include <stdidcmd.h>")
cpp_quote("#include <vsshlids.h>")


    ////////////////////////////////////////////////////////////////////////////
    // IVsCompoundAction interface
    // Exposed by objects that allow the creation of compound actions.
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsCompoundAction)
    ]
    interface IVsCompoundAction : IUnknown
    {
        HRESULT     OpenCompoundAction([in] const WCHAR *pszDescription);
        HRESULT     AbortCompoundAction(void);
        HRESULT     CloseCompoundAction(void);
        HRESULT     FlushEditActions(void);

    }
    ////////////////////////////////////////////////////////////////////////////
    // IVsCompoundViewChange interface
    // Exposed by objects that allow the creation of compound view actions.
    // This should be QI'd for off of the buffer.  It does not create an undo 
    // aciton and is specifically for grouping together actions that will make
    // multiple changes to the view, such as multiple caret moves and selection
    // changes.
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsCompoundViewChange)
    ]
    interface IVsCompoundViewChange : IUnknown
    {
        HRESULT     OpenCompoundViewChange(void);
        HRESULT     CloseCompoundViewChange(void);
    }

/*
	WARNING: IVsCompoundActionEvents may be going away now that 
      we'll have a different line event model.
*/
    ////////////////////////////////////////////////////////////////////////////
    // IVsCompoundActionEvents
    //
    // OnBeforeAction is fired before an action takes place. This allows clients
    // to prepare for a transaction by caching information or creating objects 
    // that live only during a transaction.
    //
    // ActionAborted allows clients to discard their cache when a compound action
    // is aborted.
    //
    // The "wrapped", or "interior" events that arise from a compound action are 
    // other event sets.
    //
    // To reduce the number of events fired, there is no terminating event.
    // Implementers should pass a flag in the final event or fire their own 
    // terminating event.
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsCompoundActionEvents)
    ]
    interface IVsCompoundActionEvents : IUnknown
    {
#ifdef PROXYSTUB_BUILD
        HRESULT OnBeforeAction(void);
        HRESULT OnAbortAction(void);
#else
        void OnBeforeAction(void);
        void OnAbortAction(void);
        //void OnAfterAction(void);  // NOT IMPLEMENTED TO REDUCE EVENT TRAFFIC
#endif
    }


    ////////////////////////////////////////////////////////////////////////////
    // IVsAction interface
    //
    // Actions placed in the undo history of a text buffer expose this
    // interface.
    ////////////////////////////////////////////////////////////////////////////
    [
        object,
        uuid(uuid_IVsAction),
        helpstring("IVsAction Interface"),
        pointer_default(unique)
    ]
    interface IVsAction : IUnknown
    {
        HRESULT     CanMerge ([in] IVsAction *pAction);
        HRESULT     Merge    ([in] IVsAction *pAction);
    };

/*
    User preference management structures/enums
    ===========================================

    These structures are used to communicate user preferences between the text manager, views, and
    language services.  View settings will follow the text manager's settings unless a specific set of
    forced settings has been specified when IVsTextView::Initialize is called.
*/
    enum { MAX_FILE_TYPE = 24 };
    enum { MAX_EDITOR_TAB_SIZE = 60 };

    typedef struct _LANGPREFERENCES
    {
		CHAR			szFileType[MAX_FILE_TYPE];	// file type: "HTML"

		// Things some language services don't support
		unsigned		fShowCompletion;	// set statement completion through UI?
		unsigned		fShowSmartIndent;	// set smart indent option through UI?

        // advanced statement builder setting
		unsigned		fHideAdvancedAutoListMembers; // hide advanced members (irrelevant if !fAutoListMembers)

        // tab settings
        unsigned        uTabSize;           // limit of MAX_EDITOR_TAB_SIZE
        unsigned        uIndentSize;        // limit of MAX_EDITOR_TAB_SIZE
        unsigned		fInsertTabs;        // insert tab chars or just spaces?

		// indent settings
		vsIndentStyle	IndentStyle;		// none/block/smart

        // statement builder settings
		unsigned        fAutoListMembers;   // bring up a proposed list of members on the fly?
        unsigned        fAutoListParams;    // bring up a proposed list of params on the fly?

		// selection settings
        unsigned		fVirtualSpace;      // virtual space navigation/selection?

		// display settings
		unsigned        fWordWrap       ; // Word wrap
		unsigned		fTwoWayTreeview	; // show tree view?
		unsigned		fHotURLs		; // Single click URL navigation?
		unsigned		fDropdownBar	; // Should language services support the dropdown/nav bar?
		unsigned		fLineNumbers    ; // Show line numbers in the selection margin?

		GUID			guidLang;			// language service
    } LANGPREFERENCES;

	// GUID for default language/file type - {8239BEC4-EE87-11d0-8C98-00C04FC2AB22}
	cpp_quote("DEFINE_GUID(DEFAULT_FILE_TYPE, 0x8239bec4, 0xee87, 0x11d0, 0x8c, 0x98, 0x0, 0xc0, 0x4f, 0xc2, 0xab, 0x22);")
	// GUID for ALL - {2149A66E-F261-11d0-8C9C-00C04FC2AB22}
	cpp_quote("DEFINE_GUID(ALL_FILE_TYPES, 0x2149a66e, 0xf261, 0x11d0, 0x8c, 0x9c, 0x0, 0xc0, 0x4f, 0xc2, 0xab, 0x22);")

    typedef struct _VIEWPREFERENCES
    {
        // settings for text views
		unsigned		fVisibleWhitespace;         // show spaces/tabs etc?
        unsigned		fSelectionMargin;           // display selection margin?
		unsigned		fAutoDelimiterHighlight;    // allow automatic delimiter highlighting?
		unsigned		fGoToAnchorAfterEscape;     // go to anchor after escape?
		unsigned		fDragDropEditing;           // drag/drop editing?
		unsigned		fUndoCaretMovements;        // include caret movements and text selections in undo list?
		unsigned		fOvertype;                  // overtype/insert? - NOT persisted
        unsigned		fDragDropMove;              // whether we allow drag/drop moves
		unsigned		fWidgetMargin;              // show widget margin?
    } VIEWPREFERENCES;

    // Note that the issue of the frame providing scrollbars for views is totally different from the issue of
    // whether a view itself should provide a scrollbar; a view itself providing a scrollbar is handled via
    // flags to IVsTextViewInitialize and cannot ever change after that.  What's being dealt with here is the
    // issue of the MDI child frame providing scrollbars to views in editor windows, which CAN be customized
    // by the user.

    typedef struct _FRAMEPREFERENCES
    {
        // settings for the frame (MDI child)
        unsigned		fHorzScrollbar;             // should frame display horz scrollbar for views
        unsigned		fVertScrollbar;             // should frame display vert scrollbar for views?
    } FRAMEPREFERENCES;


    // preferences for color tables, which are used by anyone interested in painting text or markers
    typedef struct _FONTCOLORPREFERENCES
    {
        /*
            If pguidColorService is NULL, it means that the caller doesn't have any color information to provide.
            If *pguidColorService is DEFAULT_FILE_TYPE, it represents the base color table build with the stock
            colorable item provider.
            Note that pguidColorService is always set to either NULL or to point to a valid GUID by the allocator
            of the FONTCOLORPREFERENCES struct.
        */
#ifdef PROXYSTUB_BUILD
        // This struct is used as [out] param by some methods, so it can not have const members.
              GUID		*pguidColorService; // the CLSID of an IVsProvideColorableItems implementor
#else
        const GUID		*pguidColorService; // the CLSID of an IVsProvideColorableItems implementor
#endif

        /*
            pColorTable is a COM pointer to the color table for the colorable item provider indicated by *pguidColorService.
            Note that this object will be created as a result of this call if it hadn't been created already.
            This pointer is guaranteed to be valid if the FONTCOLORPREFERENCES struct is an in param to a function, but
            naturally if you want to hold onto it beyond that you must AddRef (and later Release) it.
        */
        IUnknown        *pColorTable;

        /*
            hViewFont represents the fonts that are to be used by text views.
        */
#ifdef PROXYSTUB_BUILD
		LONG_PTR		hRegularViewFont;
		LONG_PTR		hBoldViewFont;
#else
		HFONT			hRegularViewFont;
		HFONT			hBoldViewFont;
#endif

        /*
            When IVsTextManagerEvents::OnUserPreferencesChanged is fired, the recipient of the event should check
            these values.  The recipient should only react to the change event if its own category GUIDs match
            those of the FONTCOLORPREFERENCES struct.
        */
#ifdef PROXYSTUB_BUILD
              GUID      *pguidFontCategory;
              GUID      *pguidColorCategory;
#else
        const GUID      *pguidFontCategory;
        const GUID      *pguidColorCategory;
#endif

    } FONTCOLORPREFERENCES;

    /*
        Start of new editor option property section
    */

    /*
        Editor options ID values:
    */

    typedef enum __VSEDITPROPID
    {
        // boundary member
        VSEDITPROPID_LAST                                 = -0x00000001,

        // composite meta-property that sets an entire class of properties
        VSEDITPROPID_ViewComposite_AllCodeWindowDefaults  = -0x00010001,   // BOOL   must be TRUE; inits settings to code window defaults

        // These are special properties that apply to a given view instance.

        // These control whether the view tracks changes to Tools.Option / Environment / Text Editor
//        VSEDITPROPID_ViewGeneral_DetachCommandToggledBehaviors = -0x00011001,   // BOOL   do setting toggle commands only affect current view?

        // Other specific view behaviors
//        VSEDITPROPID_ViewGeneral_OutliningEnabled         = -0x00012001,   // BOOL   are the outlining commands enabled?
//        VSEDITPROPID_ViewGeneral_MacroRecordingEnabled    = -0x00012002,   // BOOL   is macro recording from this view enabled?
//        VSEDITPROPID_ViewGeneral_GoBackSourcingEnabled    = -0x00012003,   // BOOL   does this view drop go back markers?
		VSEDITPROPID_ViewGeneral_FontCategory               = -0x00012005,   // BSTR   category from which to load font info
		VSEDITPROPID_ViewGeneral_ColorCategory              = -0x00012006,   // BSTR   category from which to load color info

        // These are properties for view behaviors that normally apply to all views.
        VSEDITPROPID_ViewGlobalOpt_VisibleWhitespace      = -0x00020001,   // BOOL   show spaces/tabs etc?
        VSEDITPROPID_ViewGlobalOpt_Overtype               = -0x00020002,   // BOOL   overtype/insert? - NOT persisted
        VSEDITPROPID_ViewGlobalOpt_SelectionMargin        = -0x00020003,   // BOOL   display selection margin?
//        VSEDITPROPID_ViewGlobalOpt_ToAnchorAfterEsc       = -0x00020004,   // BOOL   go to anchor after escape?
//        VSEDITPROPID_ViewGlobalOpt_DragDropEditing        = -0x00020005,   // BOOL   allow any drag/drop editing?
//        VSEDITPROPID_ViewGlobalOpt_DragDropMove           = -0x00020006,   // BOOL   whether we allow drag/drop moves (as opposed to just copies)
//        VSEDITPROPID_ViewGlobalOpt_UndoCaretMoves         = -0x00020007,   // BOOL   include caret movements and text selections in undo list?
//        VSEDITPROPID_ViewGlobalOpt_WidgetMargin           = -0x00020008,   // BOOL   show widget margin?
//        VSEDITPROPID_ViewGlobalOpt_CaretToStartAfterPaste = -0x00020009,   // BOOL   whether caret goes to end after paste (support probably going away soon!)
        VSEDITPROPID_ViewGlobalOpt_AutoScrollCaretOnTextEntry = -0x00020010,  //BOOL    wether the caret scrolls or not based on the last line of the buffer

        // These are properties for view behaviors that normally apply per language.
        VSEDITPROPID_ViewLangOpt_WordWrap              = -0x00030001,   // BOOL   word wrap on?
//        VSEDITPROPID_ViewLangOpt_TabSize               = -0x00030002,   // I4     width (in spaces) of a tab character
//        VSEDITPROPID_ViewLangOpt_IndentSize            = -0x00030003,   // I4     width (in spaces) of an indent level
//        VSEDITPROPID_ViewLangOpt_InsertTabs            = -0x00030004,   // BOOL   whether to insert tabs (vs. keeping spaces)
//        VSEDITPROPID_ViewLangOpt_IndentStyle           = -0x00030005,   // BOOL   none/block/smart; see vsIndentStyle
        VSEDITPROPID_ViewLangOpt_VirtualSpace          = -0x00030006,   // BOOL   virtual space navigation/selection?
//        VSEDITPROPID_ViewLangOpt_HotUrls               = -0x00030007,   // BOOL   Single click URL navigation?
//        VSEDITPROPID_ViewLangOpt_LineNumbers           = -0x00030008,   // BOOL   line #'s visible in the view?
        VSEDITPROPID_ViewLangOpt_RawTextDisplay        = -0x00030009,   // BOOL   text is displayed in raw mode: no bidi layout, shaping, or combining

        // These are properties that relate to font and color information for a particular category.
//        VSEDITPROPID_ViewPaintOpt_ColorTable           = -0x00040001,   // UNK    QI for IVsColorTable (private iface for text editor)
//        VSEDITPROPID_ViewPaintOpt_PlainFontHandle      = -0x00040002,   // I4|BYREF    plVal holds the HFONT of regular view font
//        VSEDITPROPID_ViewPaintOpt_BoldFontHandle       = -0x00040003,   // I4|BYREF    plVal holds the HFONT of bold view font

        // These are properties for behaviors that apply to all editor MDI frame windows (code windows).
//        VSEDITPROPID_FrameOpt_HorzScrollbar            = -0x00050001,   // BOOL   should frame display horz scrollbar for views?
//        VSEDITPROPID_FrameOpt_VertScrollbar            = -0x00050002,   // BOOL   should frame display vert scrollbar for views?
        VSEDITPROPID_FrameOpt_SuppressResizeWidget       = -0x00050003,   // BOOL   should frame have a resize widget?
 

        // These are properties that describe other info about language services
//        VSEDITPROPID_ProgLang_LocalizedLangName        = -0x00060001,   // BSTR   the localized name of the language type
//        VSEDITPROPID_ProgLang_NonLocalizedLangName     = -0x00060002,   // BSTR   the non-localized canonical name of the language type
        VSEDITPROPID_ProgLang_DebuggerLanguages        = -0x00060003,   // UNK    QI for IVsEnumGUID for the associated debugger languages
//        VSEDITPROPID_ProgLang_ShowCompletionInOpt      = -0x00060004,   // BOOL   whether the statement completion chkbox will be enabled in Tools.Options
//        VSEDITPROPID_ProgLang_ShowSmartIndentInOpt     = -0x00060005,   // BOOL   whether the statement completion chkbox will be enabled in Tools.Options
        VSEDITPROPID_ProgLang_SuppressMultipleCodeWindows = -0x00060006,   // BOOL   whether the Window.NewWindow command should be disabled
        VSEDITPROPID_ProgLang_SupportCF_HTML           = -0x00060008,   // BOOL   whether the language service supports the CF_HTML clipboard format
        // boundary member
        VSEDITPROPID_FIRST                          = -0x7FFFFFFF

    } VSEDITPROPID;


	[
		uuid(uuid_IVsTextEditorPropertyCategoryContainer)
	]
	interface IVsTextEditorPropertyCategoryContainer : IUnknown
	{
        HRESULT GetPropertyCategory([in] REFGUID rguidCategory, [out] IVsTextEditorPropertyContainer **ppProp);
    };

	[
		uuid(uuid_IVsTextEditorPropertyContainer)
	]
	interface IVsTextEditorPropertyContainer : IUnknown
	{
        HRESULT GetProperty     ([in] VSEDITPROPID idProp, [out] VARIANT *pvar);
        HRESULT SetProperty     ([in] VSEDITPROPID idProp, [in]  VARIANT  var);
        HRESULT RemoveProperty  ([in] VSEDITPROPID idProp);
    };

    // known editor property categories

    // GUID for current view properties {89B22A38-2BC3-4816-A629-D3186DE786DA}
//    cpp_quote("DEFINE_GUID(GUID_EditPropCategory_View_CurrentValues, 0x89b22a38, 0x2bc3, 0x4816, 0xa6, 0x29, 0xd3, 0x18, 0x6d, 0xe7, 0x86, 0xda);")

    // GUID for view properties that override everything -- Tools.Options *and* user commands {D1756E7C-B7FD-49a8-B48E-87B14A55655A}
    cpp_quote("DEFINE_GUID(GUID_EditPropCategory_View_MasterSettings, 0xd1756e7c, 0xb7fd, 0x49a8, 0xb4, 0x8e, 0x87, 0xb1, 0x4a, 0x55, 0x65, 0x5a);")

    // GUID for text manager global properties {6BFB60A2-48D8-424e-81A2-040ACA0B1F68}
    cpp_quote("DEFINE_GUID(GUID_EditPropCategory_TextMgr_Global, 0x6bfb60a2, 0x48d8, 0x424e, 0x81, 0xa2, 0x4, 0xa, 0xca, 0xb, 0x1f, 0x68);")



    /*
        End of new editor option property section
    */



    /////////////////////////////////////////////////////////////////////////
    // TextSelMode enum
    /////////////////////////////////////////////////////////////////////////
    typedef enum _TextSelMode
    {
        SM_STREAM,
        SM_BOX
    } TextSelMode;

    /////////////////////////////////////////////////////////////////////////
    // TextViewInitFlags enum
    /////////////////////////////////////////////////////////////////////////
    typedef enum _TextViewInitFlags
    {
        // note that these can exist in combinations and so are generally bitwise disjoint

        VIF_DEFAULT             = 0x00000000,   // no view-owned scrollbars, and no forced settings

        // For the scrolling flags we simply use the WS_ values for efficiency.
        // Note that this setting is different from the MDI child scrollbars used by the text editor.
        VIF_HSCROLL             = 0x00100000,    // WS_HSCROLL; indicates that the view should have a horizontal scrollbar
        VIF_VSCROLL             = 0x00200000,   // WS_VSCROLL; indicates that the view should have a vertical scrollbar

		VIF_UPDATE_STATUS_BAR	= 0x00400000,	// tells view to update status bar

        // If you wish to force a certain setting upon a view, regardless of the user's editor preference settings,
        // use these flags along with a VIEWPREFERENCES* into IVsTextView::Initialize() to force a given setting.
        VIF_SET_WIDGET_MARGIN       = 0x00000001,   // use the widget margin setting from the VIEWPREFERENCES struct
        VIF_SET_SELECTION_MARGIN    = 0x00000002,   // use the selection margin setting from the VIEWPREFERENCES struct
        VIF_SET_VIRTUAL_SPACE       = 0x00000004,   // use the virtual space setting from the VIEWPREFERENCES struct
        VIF_SET_INDENT_MODE         = 0x00000008,   // use the autoindent suppression setting from the VIEWPREFERENCES struct
        VIF_SET_STREAM_SEL_MODE		= 0x00000010,   // OBSOLETE
        VIF_SET_VISIBLE_WHITESPACE  = 0x00000020,   // use visible whitespace setting
        VIF_SET_OVERTYPE            = 0x00000040,   // use overtype mode setting
        VIF_SET_DRAGDROPMOVE        = 0x00000080,   // use dd move setting
        VIF_SET_HOTURLS		        = 0x00000100	// use the Hot URLs setting
    } TextViewInitFlags;


    /////////////////////////////////////////////////////////////////////////
    // INITVIEW - this is passed to IVsTextView::Initialize()
    /////////////////////////////////////////////////////////////////////////
	typedef struct _INITVIEW
	{
		unsigned		fVirtualSpace;
		unsigned		fStreamSelMode;//OBSOLETE:ignored by core editor - needed until HTMED's view clone goes away
		unsigned		fOvertype;
		unsigned		fVisibleWhitespace;
		unsigned		fWidgetMargin;
		unsigned		fSelectionMargin;
		unsigned		fDragDropMove;
		unsigned		fHotURLs;
		vsIndentStyle	IndentStyle;
	} INITVIEW;

    ////////////////////////////////////////////////////////////////////////////
    // CompletionStatusFlags enum
    ////////////////////////////////////////////////////////////////////////////
    typedef enum _CompletionStatusFlags
    {
        // UCS_* flags are passed to IVsTextView::UpdateCompletionStatus
        UCS_NAMESCHANGED        = 0x0001,       // Names or name count has changed
        UCS_EXTENTCHANGED       = 0x0002,       // Extent changed
        UCS_FLAGSCHANGED        = 0x0004,       // Flags have changed...
		UCS_COMPLETEWORD		= 0x0008,		// Attempt word completion

        // CSF_* flags are returned from IVsCompletionSet::GetFlags
        CSF_CUSTOMMATCHING      = 0x0004,       // Use ICompletionSet::GetBestMatch() to manage selection
        CSF_CUSTOMCOMMIT        = 0x0008,       // Use ICompletionSet::OnCommit() to commit completions
        CSF_HAVEDESCRIPTIONS    = 0x0010,       // ICompletionSet::GetDescriptionText will provide text for at least some of the entries
        CSF_INITIALEXTENTKNOWN  = 0x0020,       // Use ICompletionSet::GetInitialExtent to determine initial word extent
        CSF_NOCASEMATCHING      = 0x0040,       // Don't apply case sensitive matching
        CSF_NOCASEUNIQUENESS    = 0x0080,       // Don't apply case as well as character matching to determine uniqueness (for word completion)

        // GBM_* flags are returned from IVsCompletionSet::GetBestMatch
        GBM_SELECT              = 0x0001,       // The returned index should be selected
        GBM_UNIQUE              = 0x0002        // The returned index is the only appropriate match

    } UpdateCompletionFlags;

    /////////////////////////////////////////////////////////////////////////
    // IVsCompletionSet interface
    /////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsCompletionSet)
    ]
    interface IVsCompletionSet : IUnknown
    {
        // Flags indicating specific behaviors of this completion set (CSF_* above)
#ifdef PROXYSTUB_BUILD
        HRESULT    GetFlags (void);
#else
        DWORD       GetFlags (void);
#endif

        // Get the number of available completions (assert > 1?)
#ifdef PROXYSTUB_BUILD
        // Note that it is safe to return a HRESULT because, according with WinNT.h HRESULT is a typedef for long
        HRESULT     GetCount(void);
#else
        long        GetCount(void);
#endif

        // Get the text of a completion, as it is to be displayed in the list.
        // The pointer returned should be maintained by the completion set
        // object, and remain valid until final release, or until updated
        // through IVsTextView::UpdateCompletionStatus
#ifdef PROXYSTUB_BUILD
        // The MIDL compiler dosn't allow an out parameter to be const.
        HRESULT     GetDisplayText ([in] long iIndex, [out] WCHAR **ppszText, [out, optional] long *piGlyph);
#else
        HRESULT     GetDisplayText ([in] long iIndex, [out] const WCHAR **ppszText, [out, optional] long *piGlyph);
#endif

        // Get the list of images (glyphs) supported by this completion set.
        // UNDONE:  Define HIMAGELIST so we don't have to cast...
        HRESULT     GetImageList ([out] HANDLE *phImages);

        // Return text describing the indicated item
        HRESULT     GetDescriptionText ([in] long iIndex, [out] BSTR *pbstrDescription);

        // Get the initial extent of the word to be completed.  *piEndCol
        // should an index on the line *piLine
        HRESULT     GetInitialExtent ([out] long *piLine, [out] long *piStartCol, [out] long *piEndCol);

        // Determine the index of the closest matching completion, given
        // what has been typed so far.  Note that this is only called if
        // CSF_CUSTOMMATCHING is set in this completion set's flags.  If
        // *pdwFlags is set to contain one of the GBM_* flags
        // The default matching in the view uses case sensitive comparison.
        HRESULT     GetBestMatch ([in] const WCHAR *pszSoFar, [in] long iLength, [out] long *piIndex, [out] DWORD *pdwFlags);

        // Commit a completion. This is only called if the completion set's flags
        // include CSF_CUSTOMCOMMIT. If a word should be completed, return S_OK
        // with *pszCompleteWord set to the completion text. By default this is the
        // text returned by GetDisplayText. Normally a word should be completed
        // when fSelected is TRUE and cCommit is a commit character. Return S_FALSE 
        // if the word shouldn't be completed. The default behaviour is to set 
        // *pstrCompleteWord to pszSoFar.

        HRESULT     OnCommit ([in] const WCHAR *pszSoFar, [in] long iIndex, [in] BOOL fSelected, [in] WCHAR cCommit, [out] BSTR *pbstrCompleteWord);

        // Called by the view when the completion set is no longer needed.
        // Note that if a language filter wants to force a dismiss of a completion
        // set, it calls IVsTextView::UpdateCompletionStatus with pCompSet == NULL;
        // if the view has a completion set pointer cached, it calls Dismiss()
        // on it and then releases it (and also removes the UI, etc).
#ifdef PROXYSTUB_BUILD
        HRESULT     Dismiss (void);
#else
        void        Dismiss (void);
#endif
    };

    /////////////////////////////////////////////////////////////////////////
    // TipWindowFlags enum
    /////////////////////////////////////////////////////////////////////////
    typedef enum _TipWindowFlags
    {
        UTW_CONTEXTCHANGED      = 0x0001,       // Context stream is different
        UTW_CONTENTCHANGED      = 0x0002,       // Data displayed in window has changed (size will be re-queried)
        UTW_DISMISS             = 0x0004,       // Tip window should be dismissed
    } TipWindowFlags;

    ////////////////////////////////////////////////////////////////////////////
    // TipPosPreference enum
    ////////////////////////////////////////////////////////////////////////////
    typedef enum _TipPosPreference
    {
        TPP_ABOVE,
        TPP_BELOW,
        TPP_LEFT,
        TPP_RIGHT,
        TPP_DOCKED      // Current NYI -- defaults to TPP_ABOVE
    } TipPosPreference;

    ////////////////////////////////////////////////////////////////////////////
    // TIPSIZEDATA structure
    ////////////////////////////////////////////////////////////////////////////
    typedef struct _tipsizedata
    {
        SIZE                size;
        TipPosPreference    dwPosition; // NOTE: this field is ignored in VS99
    } TIPSIZEDATA;

    ////////////////////////////////////////////////////////////////////////////
    // IVsTipWindow interface
    ////////////////////////////////////////////////////////////////////////////
    [
#ifdef PROXYSTUB_BUILD
        // MIDL2269
        local,
#endif
        uuid(uuid_IVsTipWindow)
    ]
    interface IVsTipWindow : IUnknown
    {
        // Return the context stream (the position and length of text in the
        // buffer that should not be obscured by the tip window, but to which
        // the content of the tip is related).
        HRESULT     GetContextStream ([out] long *piPos, [out] long *piLength);

        // Get the size preferences for this tip window.  Note that implementations
        // should be written to handle cases where the size preference they
        // return here are not what they are given for real estate in which to
        // display content.  (i.e., it may not be possible to provide the
        // tip window in the requested size).  prcCtxBounds represents the bounding
        // rectangle of the tip's context should the implementation be interested.
        // (This rectangle is provided in screen coordinates).
        HRESULT     GetSizePreferences ([out] const RECT *prcCtxBounds, [out] TIPSIZEDATA *pSizeData);

        // Paint the tip window.
        HRESULT     Paint ([in] HDC hdc, [in] const RECT *prc);

        // The window is being dismissed by the view.
        void        Dismiss (void);

        // Event handler for the tip window
        LRESULT     WndProc ([in] HWND hwnd, [in] UINT iMsg, [in] WPARAM wParam, [in] LPARAM lParam);
    };

    /////////////////////////////////////////////////////////////////////////
    // IVsMethodTipWindow interface
    /////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsMethodTipWindow)
    ]
    interface IVsMethodTipWindow : IVsTipWindow
    {
        HRESULT     SetMethodData ([in] IVsMethodData *pMethodData);
    };

    /////////////////////////////////////////////////////////////////////////
    // IVsTextTipWindow interface
    /////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsTextTipWindow)
    ]
    interface IVsTextTipWindow : IVsTipWindow
    {
        HRESULT     SetTextTipData([in] IVsTextTipData *pMethodData);
    };

    /////////////////////////////////////////////////////////////////////////
    // MethodTextType enum
    /////////////////////////////////////////////////////////////////////////
    typedef enum _MethodTextType
    {
        // Note that GetMethodText can return NULL for any of these types except NAME.
        // Any that it does not will be displayed.  Format is as follows:
        //  [TYPEPREFIX] [NAME] ( <parms> ) [TYPEPOSTFIX]
        //       [DESCRIPTION]
        MTT_TYPEPREFIX,             // return type if prefixed, ala C++ ("long foo()")
        MTT_TYPEPOSTFIX,            // return type if postfixed, ala Basic ("foo() as long") (text must include "as" keyword)
        MTT_NAME,                   // Method name
        MTT_DESCRIPTION,            // Description of method (gets its own line)
		MTT_OPENBRACKET,			// Open bracket delimiter.  default is paren
		MTT_CLOSEBRACKET,			// Close bracket delimiter.  default is paren
        MTT_DELIMITER               // Parameter delimiter.  default is ", ".  You must specify the space if you want one
    } MethodTextType;

    /////////////////////////////////////////////////////////////////////////
    // ParameterTextType enum
    /////////////////////////////////////////////////////////////////////////
    typedef enum _ParameterTextType
    {
        // Note that GetParameterText can return NULL for any except DECLARATION, and NAME if DESCRIPTION is non-NULL.
        PTT_DECLARATION,            // full decl as it appears in signature (i.e. "long x", or "x as long")
        PTT_NAME,                   // parameter name only (i.e. "x")
        PTT_DESCRIPTION             // description (gets its own line, and is prefixed with NAME: (bolded))
    } ParameterTextType;

    /////////////////////////////////////////////////////////////////////////
    // IVsMethodData interface
    /////////////////////////////////////////////////////////////////////////
    [
#ifdef PROXYSTUB_BUILD
        // MIDL2269
        local,
#endif
        uuid(uuid_IVsMethodData)
    ]
    interface IVsMethodData : IUnknown
    {
        long            GetOverloadCount (void);
        const WCHAR *   GetMethodText ([in] long iMethod, [in] MethodTextType type);
        long            GetParameterCount ([in] long iMethod);
        const WCHAR *   GetParameterText ([in] long iMethod, [in] long iParm, [in] ParameterTextType type);
        long            GetCurrentParameter ([in] long iMethod);
        HRESULT         GetContextStream ([out] long *piPos, [out] long *piLength);
        void            OnDismiss (void);
        long            GetCurMethod (void);
        void            UpdateView (void);
        long            NextMethod (void);
        long            PrevMethod (void);
    };

    /////////////////////////////////////////////////////////////////////////
    // IVsTextTipData interface
    /////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsTextTipData)
    ]
    interface IVsTextTipData : IUnknown
    {
        HRESULT         GetTipText ([out, custom(uuid_IVsTextTipData, "optional")] BSTR *pbstrText, [out] BOOL *pfGetFontInfo);

        // NOTE: *pdwFontAttr will already have been memset-ed to zeroes, so you can set only the indices that are not normal
        HRESULT         GetTipFontInfo (
            [in] long cChars, 
            [out, size_is(cChars)] ULONG *pdwFontAttr);
        HRESULT         GetContextStream ([out] long *piPos, [out] long *piLength);
#ifdef PROXYSTUB_BUILD
        HRESULT         OnDismiss (void);
        HRESULT         UpdateView (void);
#else
        void            OnDismiss (void);
        void            UpdateView (void);
#endif
    };

    /////////////////////////////////////////////////////////////////////////
    // IVsTextView interface
    //
    // Represents an editor window.
    /////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsTextView)
    ]
    interface IVsTextView : IUnknown
    {
		/*
			WARNING: this interface is not thread-safe.  You should not call anything on this
			interface from anything but the main UI thread.

			If you need to perform any operations on the view from a different thread, you may
			either:
				1) use IVsThreadSafeTextView
				2) call IVsTextView::GetWindowHandle and use ::PostMessage to post messages to the main thread
		*/

        // Initialize creates the view and lets clients specify one or more TextViewInitFlags options from above
        HRESULT     Initialize ([in] IVsTextLines *pBuffer, [in] HWND hwndParent,
				[in] DWORD InitFlags, [in] const INITVIEW *pInitView); // TextViewInitFlags values OR'ed together
        // Close -- this unregisters this view with the view manager
        HRESULT     CloseView (void);

        // Caret (insertion point) management.  GetCaretPos will return the coordinates
        // of the end point of a selection if there is one.  piLine and/or piColumn can
        // be null if only one or the other is needed.
        HRESULT     GetCaretPos ([out] long *piLine, [out] ViewCol *piColumn);
        HRESULT     SetCaretPos ([in] long iLine, [in] ViewCol iColumn);

        // like GetSelection, but returns a TextSpan with buffer coordinates; returns S_FALSE if there's no selection
        HRESULT     GetSelectionSpan ([out] TextSpan *pSpan);

        // Selection management.  As with GetCaretPos, any of GetSelection's parameters can
        // be NULL if they are not desired.  GetSelection will return S_FALSE if there is
        // currently no selection.
        HRESULT     GetSelection ([out] long *piAnchorLine, [out] ViewCol *piAnchorCol, [out] long *piEndLine, [out] ViewCol *piEndCol);
        HRESULT     SetSelection ([in] long iAnchorLine, [in] ViewCol iAnchorCol, [in] long iEndLine, [in] ViewCol iEndCol);
#ifdef PROXYSTUB_BUILD
        HRESULT     GetSelectionMode (void);
#else
        TextSelMode GetSelectionMode (void);
#endif
        HRESULT     SetSelectionMode ([in] TextSelMode iSelMode);
        HRESULT     ClearSelection ([in] BOOL fMoveToAnchor);

        // Place the specified lines of text in the center of the view
        HRESULT     CenterLines ([in] long iTopLine, [in] long iCount);

        // Return a copy of the selected text
        HRESULT     GetSelectedText ([out] BSTR * pbstrText);

        // Same, in IDataObject form
        HRESULT     GetSelectionDataObject ([out] IDataObject **ppIDataObject);

        // Get a specified stream of text
        HRESULT     GetTextStream ([in] long iTopLine, [in] ViewCol iTopCol, [in] long iBottomLine, [in] ViewCol iBottomCol, [out] BSTR * pbstrText);

        // Text buffer access
        HRESULT     GetBuffer ([out] IVsTextLines **ppBuffer);
        HRESULT     SetBuffer ([in] IVsTextLines *pBuffer);

        // Get window handle for this view
#ifdef PROXYSTUB_BUILD
        // NOTE: We need to change this return value in order to let the MIDL compiler compile this file, anyway it is possible
        //       that this will not work on 64bit builds: HWND==HANDLE==void*, but HRESULT==long
        HRESULT     GetWindowHandle (void);
#else
        HWND        GetWindowHandle (void);
#endif

        // Scrolling control
        HRESULT     GetScrollInfo ([in] long iBar, [out] long *piMinUnit, [out] long *piMaxUnit, [out] long *piVisibleUnits, [out] long *piFirstVisibleUnit);
        HRESULT     SetScrollPosition ([in] long iBar, [in] long iFirstVisibleUnit);

        // Command Target chaining
        HRESULT     AddCommandFilter ([in] IOleCommandTarget *pNewCmdTarg, [out] IOleCommandTarget **ppNextCmdTarg);
        HRESULT     RemoveCommandFilter ([in] IOleCommandTarget *pCmdTarg);

        // Word completion control
        HRESULT     UpdateCompletionStatus ([in] IVsCompletionSet *pCompSet, [in] DWORD dwFlags);

        // Tip window control
        HRESULT     UpdateTipWindow ([in] IVsTipWindow *pTipWindow, [in] DWORD dwFlags);

        // Word extent
        HRESULT     GetWordExtent ([in] long iLine, [in] CharIndex iCol, [in] DWORD dwFlags, [out] TextSpan *pSpan);

        // Reduces view's range of visible / editable lines to a subset of the buffer's
        HRESULT     RestrictViewRange ([in] long iMinLine, [in] long iMaxLine, [in] IVsViewRangeClient *pClient);

        // Editing function(s)
        HRESULT     ReplaceTextOnLine ([in] long iLine, [in] CharIndex iStartCol, [in] long iCharsToReplace, [in] const WCHAR *pszNewText, [in] long iNewLen);

        // Line-Col to/from Position conversion.  Note that GetNearestPosition will
        // account for virtual space, and provide the position of the EOL marker
        // on the given line if the column is in virtual space (or at the end)
        HRESULT     GetLineAndColumn ([in] long iPos, [out] long *piLine, [out] CharIndex *piIndex);
        HRESULT     GetNearestPosition ([in] long iLine, [in] ViewCol iCol, [out] long *piPos, [out] long *piVirtualSpaces);

        // Used to force the view to update its frame window caption for things like
        // [Read only] files.
        HRESULT     UpdateViewFrameCaption();

        // Place the specified column of text in the center of the view
        // NOTE: this is ill-defined in the case of word wrap!!
        HRESULT     CenterColumns ([in] long iLine, [in] ViewCol iLeftCol, [in] long iColCount);

        // Will make sure text is in view both vertically & horizontally.
        HRESULT     EnsureSpanVisible([in] TextSpan span);

        // This method will put the caret in a position suitable for editing a function.  If there is text on
        // the line, the caret will go to the first non-whitespace text.  Otherwise, it will create cIndentLevels
        // of whitespace per the current language settings and put the caret there.  No centering is done.
        HRESULT     PositionCaretForEditing(
                                [in] long iLine,
                                [in] long cIndentLevels);

        // Client pixel coordinates of the specified line and column
        HRESULT     GetPointOfLineColumn ([in] long iLine, [in] ViewCol iCol, [out, retval] POINT * ppt);

        // Pixel height of a line
        HRESULT     GetLineHeight ([out, retval] long * piLineHeight);

        HRESULT     HighlightMatchingBrace([in] DWORD dwFlags, [in] ULONG cSpans, [in, size_is(cSpans)] TextSpan *rgBaseSpans); 

        // To send explicit focus to the window.  Reglar send focus messages post a GimmeFocus message.  This directly sends it.
        HRESULT     SendExplicitFocus();

        // Sets the top line in the view to the base line
        HRESULT     SetTopLine([in] long iBaseLine);
    };

    /////////////////////////////////////////////////////////////////////////
    // IVsThreadSafeTextView interface
    //
    // This is a thread-safe subset of IVsTextView.  All these methods do is
	// post messages to the main thread, which then calls the regular handlers.
    /////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsThreadSafeTextView)
    ]
    interface IVsThreadSafeTextView : IUnknown
    {
        HRESULT ThreadSafeSetCaretPos ([in] long iLine, [in] ViewCol iColumn);
	}

    typedef enum _GetSelectedAtomFlags
    {
        gsaDefault = 0      // matches an atom when the selection is 1) empty & to the left of it, or 2) exactly selecting it
    } GetSelectedAtomFlags;


    typedef enum _SELECTIONSTATEFLAGS
    {
        ssfDefault = 0,
        ssfColumn = 1
    } SELECTIONSTATEFLAGS;

    /*
        SELECTIONSTATE

        This struct represents the state of a selection such that it can be restored to a particular
        state.
    */
    typedef struct _SELECTIONSTATE
    {
        ViewCol iAnchorCol;       // WARNING: this is a ViewCol, NOT a CharIndex!  It may be past the end of the physical line.
        long    iAnchorLine;
        ViewCol iActiveCol;       // WARNING: this is a ViewCol, NOT a CharIndex!  It may be past the end of the physical line.
        long    iActiveLine;
        DWORD   dwFlags;          // ORing of SELECTIONSTATEFLAGS enum
        DWORD   dwReserved;       // unused for now
    } SELECTIONSTATE;


    typedef enum _RelativeSelectionStateFlags
    {
        RSS_DEFAULT                 = 0x0,         // coords relative to the top view layer
        RSS_TOP_LAYER               = 0x0,        // coords relative to the top view layer
        RSS_BUFFER                  = 0x1,         // coords relative to the buffer
        RSS_RELATIVE_LAYER          = 0x2,        // coords relative to the layer * specified in pReference

		RSS_TRACKSEL				= 0x010,
        // flags for SetRelativeSelection
        RSS_SET_WITHOUT_SCROLLING   = 0x1000,  // tells the view to not scroll to force the selection to be visible
        RSS_SET_TO_NEAREST_LOCAL    = 0x2000,  // for RSS_BUFFER or RSS_RELATIVE_LAYER, tells the view to put the caret at the nearest local position

        // old flags for compatibility
        rssDefault          = RSS_DEFAULT,
        rssTopLayer         = RSS_TOP_LAYER,
        rssBuffer           = RSS_BUFFER,
        rssRelativeLayer    = RSS_RELATIVE_LAYER,
		rssTrackSel			= RSS_TRACKSEL

    } RelativeSelectionStateFlags;


    /*
        IVsLayeredTextView interface

        This is another interface exposed by text views.  Its purpose is to help interact with
        non-buffer layer modules in the view.  By default it methods operate on the top view layer.
    */
    [
        uuid(uuid_IVsLayeredTextView)
    ]
    interface IVsLayeredTextView : IUnknown
    {
        /*
            GetSelectedAtom tells a client when the selection is "at" an atomic object, "at" being
            defined by dwFlags.  An atomic object is a special object inserted into the regular
            text stream, such as a hidden text banner.  The returned IUnknown is a pointer to the
            object that corresponds to the atom; QI it for whatever custom interface might be of
            interest.

            Return values:
                S_OK: found it
                S_FALSE: didn't find it
        */
        HRESULT GetSelectedAtom(
            [in] DWORD dwFlags, // ORing of GetSelectedAtomFlags values
            [out] IUnknown **ppunkAtom);

        /*
            Get/SetRelativeSelectionState get and set the selection relative to a specified layer.

            S_OK is the only success code.  Anything else indicates a serious failure.
        */
        HRESULT GetRelativeSelectionState(
            [in] DWORD dwFlags,                 // ORing of RelativeSelectionStateFlags values
            [in] IVsTextLayer *pReferenceLayer, // must be NULL unless rssRelativeLayer is specified
            [out] SELECTIONSTATE *pSelState);   // caller-allocated

        HRESULT SetRelativeSelectionState(
            [in] DWORD dwFlags,                 // ORing of RelativeSelectionStateFlags values
            [in] IVsTextLayer *pReferenceLayer, // must be NULL unless rssRelativeLayer is specified
            [in] SELECTIONSTATE *pSelState);    // caller-allocated

        HRESULT GetTopmostLayer([out] IVsTextLayer **ppLayer); // the view's top-level layer representation
    }

    ////////////////////////////////////////////////////////////////////////////
    // WORDEXTFLAGS enum
    ////////////////////////////////////////////////////////////////////////////
    typedef enum _wordextflags
    {
        WORDEXT_MOVETYPE_MASK = 0x0003,
        WORDEXT_CURRENT = 0x0000,       // Finds word/token containing iPos (if any) (default)
        WORDEXT_PREVIOUS = 0x0001,      // Finds nearest word/token whose last character is < iPos
        WORDEXT_NEXT = 0x0002,          // Finds nearest word/token whose 1st character is > iPos
        WORDEXT_NEAREST = 0x0003,       // Finds word/token nearest to iPos

        /*
            A few words about WORDEXT_FINDWORD vs. WORDEXT_FINDTOKEN.

            Here's the way WORD extent is intended to be used, and the way the editor interprets
            them for it's operations. If these semantics are implemented as described, we get the
            nicest double click, word select, ctrl+drag behaviors.

            For programming languages:
            "WORD" is
              keyword 
              | identifier
              | number

            "TOKEN" is
              WORD 
              | operator                    e.g.  ++, --, ->, %, |=, ==
              | delimiter                    e.g.  ", /, //, star+slash, slash+start
              | run of whitespace


            In other words:
            
            WORDEXT_FINDWORD means that you would send back something that corresponds to a keyword,
            number, or identifier.  So for "a[1]", the "a" or the "1" would be valid runs for it to
            return, but not anything else (such as the whole expression).

            WORDEXT_FINDTOKEN means that you would find anything that matches WORDEXT_FINDWORD, *or*
            you would find operators, delimiters, or runs of whitespace.  So for "a[1]", any single
            char of the string could match, but not any larger chunk of it.  Note that "token" as
            used here has nothing to do with what might be considered a language token in the sense
            of compiler terminology.  (Perhaps an unfortunate choice of names.)
        */
        WORDEXT_FINDWORD = 0x0000,           // Finds words only (default)
        WORDEXT_FINDTOKEN = 0x0004,          // Finds words and tokens
        WORDEXT_FINDEXPRESSION = 0x0008,     // Find simple expressions, like *pFoo

    } WORDEXTFLAGS;

    ////////////////////////////////////////////////////////////////////////////
    // IVsTextViewFilter interface
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsTextViewFilter)
    ]
    interface IVsTextViewFilter : IUnknown
    {
        // Word extent calculation
        HRESULT     GetWordExtent (
			[in] long       iLine,
			[in] CharIndex  iIndex,
			[in] DWORD      dwFlags,
			[out] TextSpan * pSpan);

        // Data-tip support.  piPos and piLength are in/out -- they indicate the selected characters
		// on the way in, and indicate the bounding context of the tip on the way out.
        HRESULT     GetDataTipText (
			[in, out] TextSpan * pSpan,
			[out] BSTR * pbstrText);

		HRESULT		GetPairExtents([in] long iLine, [in] CharIndex iIndex, [out] TextSpan * pSpan);
	}

    ////////////////////////////////////////////////////////////////////////////
    // LanguageContextHint enum
    //
    // Used as a param for IVsLanguageContextProvider.
    //
    ////////////////////////////////////////////////////////////////////////////
    typedef enum _LanguageContextHint
    {
        LCH_DEFAULT     = 0x00000000, // typical idle-time update; should be as fast as possible
        LCH_F1_HELP     = 0x00000001  // means that the context will be used for F1 handling; OK to take longer
    } LanguageContextHint;

    ////////////////////////////////////////////////////////////////////////////
    // IVsLanguageContextProvider interface
    //
    // Optional interface that the language service can expose.  This lets the
    // view "pull" data from the language service at an appropriate time.
    //
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsLanguageContextProvider)
    ]
    interface IVsLanguageContextProvider : IUnknown
    {
        /*
        ProvideContext return values: 
            - S_OK: the implementor has added whatever context should be added
            - any other success code: forbidden (caller will assert)
            - any failure code: means the implementor is "passing" on this opportunity to provide context and the text editor will fall back to other mechanisms
        */
        HRESULT UpdateLanguageContext(
            DWORD dwHint,           // ORing of LanguageContextHint enum values
            IVsTextLines *pBuffer,  // buffer in question
            TextSpan *ptsSelection, // relevant range of text
            IVsUserContext *pUC     // context to update
        );
    };

    ////////////////////////////////////////////////////////////////////////////
    // IVsTextMarkerContextProvider interface
    //
    // Optional interface that a text marker client can expose.  This lets the
    // view "pull" data from the marker client at an appropriate time.  Note that
    // an implementor is responsible for both adding and removing its contribution
    // at an appropriate time.
    //
    // Note also that text marker contributions are strictly a supplement to other
    // context contribution mechanisms.  Regardless of whether this fn ends up
    // adding context, the view's other mechanisms for gathering context will still
    // apply.
    //
    // If a marker has the MV_CONTEXT_CONTRIBUTION_FOR_BODY style set, its client
    // will be QI'd for this.
    //
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsTextMarkerContextProvider)
    ]
    interface IVsTextMarkerContextProvider : IUnknown
    {
        /*
            When UpdateContextForMarker() is called, the client should add relevant context to the IVsUserContext *.

            Return values: 
            - S_OK: the implementor has added whatever context should be added, and the editor will call
                RemoveLastContext at the next context update time
            - any other success code: forbidden (caller will assert)
            - any failure code: means the implementor is "passing" on this opportunity to provide context and the
                text editor will fall back to other mechanisms; RemoveLastContext will not be called
        */
        HRESULT UpdateContextForMarker(
            DWORD dwReserved,       // should be 0
            IVsUserContext *pUC     // context to update
        );

	//There is no longer any need to implement this method  V7-124350
        HRESULT RemoveLastContext(
            DWORD dwReserved,   // should be 0
            IVsUserContext *pUC);     // context to update
    };

    /////////////////////////////////////////////////////////////////////////
    // TextViewAction enum
    /////////////////////////////////////////////////////////////////////////
    typedef enum _TextViewAction
    {
        TVA_SETCARETPOS,           // Caret (insertion point) management
        TVA_CENTERLINES            // Place the specified lines of text in the center of the view
    } TextViewAction;

    /////////////////////////////////////////////////////////////////////////////////
    // IVsViewRangeClient interface
    /////////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsViewRangeClient)
    ]
    interface IVsViewRangeClient : IUnknown
    {
        HRESULT AdjustViewRange([in] IVsTextView *pView, [in] TextViewAction action, [in] long iLine, [in] long iCount);
    };


    ////////////////////////////////////////////////////////////////////////////
    // IVsTextViewEvents interface
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsTextViewEvents)
    ]
    interface IVsTextViewEvents : IUnknown
    {
#ifdef PROXYSTUB_BUILD
        HRESULT OnSetFocus ([in] IVsTextView *pView);
        HRESULT OnKillFocus ([in] IVsTextView *pView);
        HRESULT OnSetBuffer ([in] IVsTextView *pView, [in] IVsTextLines *pBuffer);
        HRESULT OnChangeScrollInfo ([in] IVsTextView *pView, [in] long iBar, [in] long iMinUnit, [in] long iMaxUnits, [in] long iVisibleUnits, [in] long iFirstVisibleUnit);
        HRESULT OnChangeCaretLine([in] IVsTextView *pView, [in] long iNewLine, [in] long iOldLine);
#else
        void OnSetFocus ([in] IVsTextView *pView);
        void OnKillFocus ([in] IVsTextView *pView);
        void OnSetBuffer ([in] IVsTextView *pView, [in] IVsTextLines *pBuffer);
        void OnChangeScrollInfo ([in] IVsTextView *pView, [in] long iBar, [in] long iMinUnit, [in] long iMaxUnits, [in] long iVisibleUnits, [in] long iFirstVisibleUnit);

        /*
            New code should not use OnChangeCaretLine.  If anything, you should use our new line commit
            events, IVsPreliminaryTextChangeCommitEvents and IVsFinalTextChangeCommitEvents.
        */
        void OnChangeCaretLine([in] IVsTextView *pView, [in] long iNewLine, [in] long iOldLine);
#endif
    };


    ////////////////////////////////////////////////////////////////////////////
    // IVsTextManager interface
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsTextManager)
    ]
    interface IVsTextManager : IUnknown
    {
        // Register a view
        HRESULT     RegisterView ([in] IVsTextView *pView, [in] IVsTextBuffer *pBuffer);

        // Unregister a view
        HRESULT     UnregisterView ([in] IVsTextView *pView);

        // Enumerate views.  Pass NULL for pBuffer to get all views.
        HRESULT     EnumViews ([in] IVsTextBuffer *pBuffer, [out] IVsEnumTextViews **ppEnum);

        // Create an IAction object that remembers/sets selection in a view on
        // a given buffer
        HRESULT     CreateSelectionAction ([in] IVsTextBuffer *pBuffer, [out] IVsTextSelectionAction **ppAction);

        // Given a file name, determine the registered language service that
        // understands it (if one exists)
        HRESULT     MapFilenameToLanguageSID ([in] const WCHAR *pszFileName, [out] GUID *pguidLangSID);

        // Marker registration

		// Used to obtain the marker ID of a registered marker type.  The marker ID can then be used with IVsTextLines::CreateLineMarker() or IVsTextStream::CreateStreamMarker().
        HRESULT     GetRegisteredMarkerTypeID([in] const GUID *pguidMarker, [out] long *piMarkerTypeID);
        HRESULT     GetMarkerTypeInterface ([in] long iMarkerTypeID, [out] IVsTextMarkerType **ppMarkerType);
        HRESULT     GetMarkerTypeCount ([out] long *piMarkerTypeCount);

        // Get the currently active (or last active) text view.  Pass NULL for pBuffer
        // to get the [last] active view on any buffer.
        HRESULT     GetActiveView ([in] BOOL fMustHaveFocus, [in] IVsTextBuffer *pBuffer, [out] IVsTextView **ppView);

        // Gets user preferences for things like tab usage, indent size, widget margin presence, etc.

        // For the LANGPREFERENCES member, specify the language in question by setting 
        // pLangPrefs->guidLang to the language SID.
        HRESULT     GetUserPreferences ([out]     VIEWPREFERENCES      * pViewPrefs,  // struct is caller-allocated
                                        [out]     FRAMEPREFERENCES     * pFramePrefs, // struct is caller-allocated
                                        [in, out] LANGPREFERENCES      * pLangPrefs,  // struct is caller-allocated
                                        [in, out] FONTCOLORPREFERENCES * pColorPrefs);
        HRESULT     SetUserPreferences ([in] const VIEWPREFERENCES       * pViewPrefs,
                                        [in] const FRAMEPREFERENCES      * pFramePrefs,
                                        [in] const LANGPREFERENCES       * pLangPrefs,
                                        [in] const FONTCOLORPREFERENCES  * pColorPrefs);

		HRESULT		SetFileChangeAdvise([in] const WCHAR *pszFileName, [in] BOOL fStart);
		HRESULT		SuspendFileChangeAdvise([in] const WCHAR *pszFileName, [in] BOOL fSuspend);

        HRESULT     NavigateToPosition( [in] IVsTextBuffer * pBuffer,
                                        [in] REFGUID guidDocViewType, 
                                        [in] long iPos,
                                        [in] long iLen);
        HRESULT     NavigateToLineAndColumn([in] IVsTextBuffer* pBuffer, [in] REFGUID guidDocViewType, 
                                            [in] long iStartRow, [in] CharIndex iStartIndex, 
                                            [in] long iEndRow,   [in] CharIndex iEndIndex);

        // OBSOLETE: use GetBufferSccStatus2 instead
        // returns S_OK if the buffer is under SCC, and S_FALSE if not.  If it is, *pbNonEditable
        // will reflect whether the file is checked in or not.
        HRESULT     GetBufferSccStatus([in] IVsUserData *pBufData, [out] BOOL *pbNonEditable);

        // Buffer Registration -- all buffers must register/unregister with the
        // text mgr service in order to get things like change notifications, etc.
        // NOTE ALSO that in order to avoid circular reference problems, UnregisterBuffer
        // should be called from the buffer's implementation of IVsPersistDocData::Close(),
        // which is called from the running document table.
        HRESULT     RegisterBuffer ([in] IVsTextBuffer *pBuffer);
        HRESULT     UnregisterBuffer ([in] IVsTextBuffer *pBuffer);

        // Buffer enumeration (NOTE:  Currently NYI...)
        HRESULT     EnumBuffers ([out] IVsEnumTextBuffers **ppEnum);

        // Gets/Set per-language preferences - ONLY WORKS DURING TOOLS.OPTIONS dialog lifetime
        HRESULT     GetPerLanguagePreferences ([out] LANGPREFERENCES *pLangPrefs);
        HRESULT     SetPerLanguagePreferences ([in] const LANGPREFERENCES *pLangPrefs);

        // OBSOLETE: use AttemptToCheckOutBufferFromScc2 instead
        // try to check out a file from SCC
        HRESULT     AttemptToCheckOutBufferFromScc([in] IVsUserData *pBufData, [out] BOOL *pfCheckoutSucceeded);

        HRESULT     GetShortcutManager([out]IVsShortcutManager **ppShortcutMgr);

        // Register a 'view' from some source other then the core editor.
        HRESULT     RegisterIndependentView ([in] IUnknown *pUnk, [in] IVsTextBuffer *pBuffer);

        // Unregister an externally created 'view'
        HRESULT     UnregisterIndependentView ([in] IUnknown *pUnk, [in] IVsTextBuffer *pBuffer);

        // Ignore the next file change (has a 4-second timeout)
        HRESULT     IgnoreNextFileChange([in] IVsTextBuffer *pBuffer);

        // Increases/decreases the ignore count for file change
        HRESULT     AdjustFileChangeIgnoreCount([in] IVsTextBuffer *pBuffer, [in] BOOL fIgnore);

        // These two methods are the preferred means for interacting with SCC.
        // GetBufferSccStatus2 determines whether a file is under SCC
        HRESULT     GetBufferSccStatus2(
            [in] const WCHAR *pszFileName, // filename
            [out] BOOL *pbNonEditable,       // whether the file is unmodifiable (e.g. it's under SCC & checked in)
            [out] int *piStatusFlags);     // may be NULL; returns add'l status flags; this is the VSQueryEditResult returned from IVsQueryEditQuerySave::QueryEditFiles

        // AttemptToCheckOutBufferFromScc2 tries to check a file out of SCC
        HRESULT     AttemptToCheckOutBufferFromScc2(
            [in] const WCHAR *pszFileName, // filename
            [out] BOOL *pfCheckoutSucceeded, // whether the checkout succeeded
            [out] int *piStatusFlags);     // may be NULL; add'l status flags; this is the VSQueryEditResult returned from IVsQueryEditQuerySave::QueryEditFiles


        HRESULT     EnumLanguageServices([out] IVsEnumGUID **ppEnum); // enumerates the registered language service ID's

        // Enumerates ndependent views.  Pass NULL for pBuffer to get all views.
        HRESULT     EnumIndependentViews ([in] IVsTextBuffer *pBuffer, [out] IVsEnumIndependentViews **ppEnum);
    };

    ////////////////////////////////////////////////////////////////////////////
    // IVsShortcutManager interface
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsShortcutManager)
    ]
    interface IVsShortcutManager : IUnknown
    {
		HRESULT CreateItem([in]long iShortcutLine, [in]IVsTextLines* pBuffer, [in]LPCOLESTR pszBufMoniker);
		HRESULT RemoveItem([in]IVsTextLineMarker *pMarker);
		HRESULT WriteUserOptions([in]IStream *pOptionsStream);
		HRESULT ReadUserOptions([in]IStream *pOptionsStream);
    };

    ////////////////////////////////////////////////////////////////////////////
    // IVsEnumTextBuffers interface
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsEnumTextBuffers)
    ]
    interface IVsEnumTextBuffers : IUnknown
    {
        HRESULT     Next (ULONG celt, [out, size_is(celt), length_is(*pceltFetched)] IVsTextBuffer **rgelt, ULONG *pceltFetched);
        HRESULT     Skip (ULONG celt);
        HRESULT     Reset ();
        HRESULT     Clone (IVsEnumTextBuffers **ppenum);
    };

    ////////////////////////////////////////////////////////////////////////////
    // IVsTextManagerEvents interface
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsTextManagerEvents)
    ]
    interface IVsTextManagerEvents : IUnknown
    {
#ifdef PROXYSTUB_BUILD
        // Fired when a new marker type is registered
        HRESULT     OnRegisterMarkerType ([in] long iMarkerType);

        // Fired when views are [un]registered
        HRESULT     OnRegisterView ([in] IVsTextView *pView);
        HRESULT     OnUnregisterView ([in] IVsTextView *pView);

        // Fired when the user's global preferences have changed
        HRESULT     OnUserPreferencesChanged([in] const VIEWPREFERENCES  * pViewPrefs,
                                             [in] const FRAMEPREFERENCES * pFramePrefs,
                                             [in] const LANGPREFERENCES  * pLangPrefs,
                                             [in] const FONTCOLORPREFERENCES * pColorPrefs);
#else
        // Fired when a new marker type is registered
        void        OnRegisterMarkerType ([in] long iMarkerType);

        // Fired when views are [un]registered
        void        OnRegisterView ([in] IVsTextView *pView);
        void        OnUnregisterView ([in] IVsTextView *pView);

        // Fired when the user's global preferences have changed
        void        OnUserPreferencesChanged([in] const VIEWPREFERENCES  * pViewPrefs,
                                             [in] const FRAMEPREFERENCES * pFramePrefs,
                                             [in] const LANGPREFERENCES  * pLangPrefs,
                                             [in] const FONTCOLORPREFERENCES * pColorPrefs);
#endif
    };

    ////////////////////////////////////////////////////////////////////////////
    // IVsTextSelectionAction interface
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsTextSelectionAction)
    ]
    interface IVsTextSelectionAction : IUnknown
    {
        // Set the selection state for this action.  The next call to
        // IAction::Undo or IAction::Redo on this will set the selection state
        // to that given in the view on this action's buffer that has focus,
        // if there is one.
        HRESULT GetOrigin([out] SELECTIONSTATE *pSelState);
        HRESULT GetDestination([out] SELECTIONSTATE *pSelState);

        // Retrieve selection data
        HRESULT SetOrigin([in] SELECTIONSTATE *pSelState);
        HRESULT SetDestination([in] SELECTIONSTATE *pSelState);
    };

    ////////////////////////////////////////////////////////////////////////////
    // IVsEnumTextViews interface
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsEnumTextViews)
    ]
    interface IVsEnumTextViews : IUnknown
    {
        HRESULT     Next (ULONG celt, [out, size_is(celt), length_is(*pceltFetched)] IVsTextView **rgelt, ULONG *pceltFetched);
        HRESULT     Reset ();
		HRESULT     GetCount (ULONG *pCount);
    };

    ////////////////////////////////////////////////////////////////////////////
    // IVsEnumIndependentViews interface
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsEnumIndependentViews)
    ]
    interface IVsEnumIndependentViews : IUnknown
    {
        HRESULT     Next (ULONG celt, [out, size_is(celt), length_is(*pceltFetched)] IUnknown **rgelt, [out] ULONG *pceltFetched);
        HRESULT     Reset ();
		HRESULT     GetCount (ULONG *pCount);
    };

    ////////////////////////////////////////////////////////////////////////////
    // COLORINDEX enum
    ////////////////////////////////////////////////////////////////////////////
    typedef enum _COLORINDEX
    {
        CI_USERTEXT_FG = 0,
        CI_USERTEXT_BK,

        // beginning of fixed color range
        CI_FIRSTFIXEDCOLOR,
        CI_BLACK = CI_FIRSTFIXEDCOLOR,
        CI_WHITE,
        CI_MAROON,
        CI_DARKGREEN,   // was CI_14
        CI_BROWN,
        CI_DARKBLUE,    // was CI_13
        CI_PURPLE,      // was CI_15
        CI_AQUAMARINE,  // was CI_16
        CI_LIGHTGRAY,
        CI_DARKGRAY,
        CI_RED,
        CI_GREEN,
        CI_YELLOW,
        CI_BLUE,
        CI_MAGENTA,
        CI_CYAN,
        CI_LASTFIXEDCOLOR = CI_CYAN,
        // end of fixed color range

        // more system color placeholders
        CI_SYSSEL_FG,           // foreground for selected text
        CI_SYSSEL_BK,           // background for selected text
        CI_SYSINACTSEL_FG,      // foreground for inactive selection
        CI_SYSINACTSEL_BK,      // background for inactive selection
        CI_SYSWIDGETMGN_BK,     // background for widget margin
        CI_SYSPLAINTEXT_FG,     // foreground for plain text
        CI_SYSPLAINTEXT_BK,     // background for plain text

        CI_PALETTESIZE,
        CI_FORBIDCUSTOMIZATION,

        // these two are obsolete, and provided for compatibility; please don't use
        CI_SYSTEXT_FG = CI_USERTEXT_FG,
        CI_SYSTEXT_BK = CI_USERTEXT_BK,

    } COLORINDEX;

    ////////////////////////////////////////////////////////////////////////////
    // LINESTYLE enum
    ////////////////////////////////////////////////////////////////////////////
    typedef enum _LINESTYLE
    {
        LI_NONE         = 0,    // no line at all
        LI_SOLID        = 1,    // solid - only valid for MV_BORDER markers
        LI_SQUIGGLY     = 2,    // squiggly - only valid for MV_LINE markers
        LI_HATCH        = 3,    // hatch pattern - only valid for MV_BORDER markers
        LI_DOTTED       = 4     // 50% gray dither (dotted when 1 pixel) - only valid for MV_BORDER markers
    } LINESTYLE;

    ////////////////////////////////////////////////////////////////////////////
    // GLYPHDRAWFLAGS
    ////////////////////////////////////////////////////////////////////////////
    typedef enum _GLYPHDRAWFLAGS
    {
        GDF_DEFAULT     = 0x00000000, // single-line glyph
        GDF_MULTILINE   = 0x00000001, // multi-line glyph
        GDF_TOPEDGE     = 0x00000002, // client should draw special top line
        GDF_BOTTOMEDGE  = 0x00000004  // client should draw special bottom line
    } GLYPHDRAWFLAGS;

    ////////////////////////////////////////////////////////////////////////////
    // MARKERVISUAL enum
    ////////////////////////////////////////////////////////////////////////////
    typedef enum _MARKERVISUAL
    {
        MV_GLYPH                    = 0x00000001, // can show a glyph in the widget margin
        MV_COLOR_ALWAYS             = 0x00000002, // always does body text coloring
        MV_COLOR_LINE_IF_NO_MARGIN  = 0x00000004, // does body text coloring if there's no widget margin
        MV_LINE                     = 0x00000008, // means the marker is ONLY a line adornment & doesn't otherwise affect coloring; implies a squiggly for v7; unrelated to MB_LINESPAN
        MV_TIP_FOR_BODY             = 0x00000010, // whether a tip should be shown for the body of the marker text
        MV_TIP_FOR_GLYPH            = 0x00000020, // whether a tip should be shown the widget margin
        MV_SEL_MARGIN_GLYPH         = 0x00000040, // like MV_GLYPH but indicates that the glyph lives in the selection margin, not the normal widget margin

        /*
             MV_FORCE_INVISIBLE forces the marker to be invisible; if you need to toggle a marker between being visible & invisible,
             this is faster than using IVsTextMarker::SetType().
        */
        MV_FORCE_INVISIBLE          = 0x00000080,

        /*
            MV_BORDER indicates that a box is drawn around the marked text.
        */
        MV_BORDER                   = 0x00000100,

        /*
            MV_GLYPH_HOVER_CURSOR indicates that the client wants a callback (via their client interface) to set
            the mouse cursor when the user hovers the mouse over the glyph.
        */
        MV_GLYPH_HOVER_CURSOR       = 0x00000200,

        /*
            MV_DRAGGABLE_GLYPH indicates that a glyph can be dragged in a drag/drop operation.
        */
        MV_DRAGGABLE_GLYPH          = 0x00000400,

        // MV_MULTILINE_GLYPH indicates that a glyph spans multiple lines.
        MV_MULTILINE_GLYPH          = 0x00000800,

        // MV_CONTEXT_CONTRIBUTION_FOR_BODY indicates that the body of a marker wants to contribute context,
        // and thus its client can be queried for IVsUserContextUpdate.
        MV_CONTEXT_CONTRIBUTION_FOR_BODY = 0x00001000,

        // MV_COLOR_SPAN_IF_ZERO_LENGTH indicates that a marker should paint as a solid bar if the textspan is zerolength.  This shouldn't be used for
        // markers such as squigglies since it will only be this solid bar
        MV_COLOR_SPAN_IF_ZERO_LENGTH    = 0x00002000

    } MARKERVISUAL;

    ////////////////////////////////////////////////////////////////////////////
    // FONTFLAGS enum
    ////////////////////////////////////////////////////////////////////////////
    typedef enum _FONTFLAGS
    {
        FF_DEFAULT          = 0x00000000, // plain text
        FF_BOLD             = 0x00000001, // bold
        FF_STRIKETHROUGH    = 0x00000002  // strikethrough
    } FONTFLAGS;

    /*
        MARKERBEHAVIORFLAGS enum

        Flags returned by the IVsTextMarkerType::GetBehaviorFlags & IVsTextMarker::GetBehavior methods.
    */
    typedef enum _markerbehaviorflags
    {
        MB_DEFAULT              = 0x00000000,   // default stream behavior
        MB_LINESPAN				= 0x00000001,   // a marker that always adjusts itself to span a line at a time
		MB_LEFTEDGE_LEFTTRACK   = 0x00000002,
		MB_RIGHTEDGE_RIGHTTRACK = 0x00000004,
        MB_MULTILINESPAN        = 0x00000008,

        /*
            MB_TRACK_ON_RELOAD forces a marker to track every edit as a replace, ignoring any reload semantics.
            In other words, IVsTextLines::ReloadLines() will have the same effect as IVsTextLines::ReplaceLines()
            for markers with this style set.  Do not use this unless you have markers that need to guarantee that
            they're tracking in response to OnChangeLineText() events.  (You should not specify this style unless
            you're doing something special and have contacted the VS text editor team about it.)
        */
        MB_TRACK_EDIT_ON_RELOAD = 0x00000100
    } MARKERBEHAVIORFLAGS;


    // colorable items that we provide in the stock provider
    typedef enum _DEFAULTITEMS
    {
        COLITEM_TEXT = 0,           // Default
        COLITEM_KEYWORD,            // Keyword
        COLITEM_COMMENT,            // Comment
        COLITEM_IDENTIFIER,         // Identifier
        COLITEM_STRING,             // String
        COLITEM_NUMBER,              // Number
		DEFAULT_ITEM_COUNT			// Must be last enum!!!  Put any other value before this one
    } DEFAULTITEMS;

    /*
        Here are the colors that should by default be associated with the DEFAULTITEMS indices:
        COLITEM_KEYWORD:        Foreground: CI_BLUE         Background: CI_USERTEXT_BK;     Font flags: FF_BOLD
        COLITEM_COMMENT:        Foreground: CI_DARKGREEN    Background: CI_USERTEXT_BK,     Font flags: 0
        COLITEM_IDENTIFIER:     Foreground: CI_USERTEXT_FG  Background: CI_USERTEXT_BK,     Font flags: 0
        COLITEM_STRING:         Foreground: CI_USERTEXT_FG  Background: CI_USERTEXT_BK,     Font flags: 0
        COLITEM_NUMBER:         Foreground: CI_USERTEXT_FG  Background: CI_USERTEXT_BK,     Font flags: 0
    */

    ////////////////////////////////////////////////////////////////////////////
    // IVsColorableItem interface
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsColorableItem)
    ]
    interface IVsColorableItem : IUnknown
    {
        // Default foreground/background colors for this item
        HRESULT     GetDefaultColors ([out] COLORINDEX *piForeground, [out] COLORINDEX *piBackground);

        // Default font flags for this item
        HRESULT     GetDefaultFontFlags ([out] DWORD *pdwFontFlags); // see FONTFLAGS enum

        // Name of this item.  Display name is used in UI for customization of
        // colors, as well as comparison in inter-language merging of
        // colorable items.
        HRESULT     GetDisplayName ([out] BSTR * pbstrName); // string SHOULD be localized
    };

    ////////////////////////////////////////////////////////////////////////////
    // IVsMergeableUIItem interface
	//
	// This interface must be implemented by implementors of IVsPackageDefinedTextMarkerType,
	// and may be implemented (that is, it would be nice but is not absolutely required)
	// by implementors of IVsColorableItem.
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsMergeableUIItem)
    ]
    interface IVsMergeableUIItem : IUnknown
    {
        // Non-localized item name, used for comparison in inter-language
		// merging of items.
        HRESULT GetCanonicalName ([out] BSTR *pbstrNonLocalizeName);

        // Localized item name, used for display in UI.
        // NOTE: for package-defined marker types, we also get the localized
		// name via a string resource put into the registry key for this
        // external marker.  See architecture document for details.
        HRESULT GetDisplayName ([out] BSTR *pbstrDisplayName);

        // Merging priority; used to resolve conflicts.  The higher the #, the more preferred it is.
        // Guidelines:
        //     - If this is a Microsoft product, pri should be 0x1000 or greater.
        //     - If yours is the primary package to be defining the marker, use 0x2000 or greater.
        //     - If you are not doing any localization, your priority should be negative.
        HRESULT GetMergingPriority ([out] long *piMergingPriority);

		// Item description.  NOTE: this may be unused for VS7, so don't bother implementing it yet.
		// Just return E_NOTIMPL for now.
		HRESULT GetDescription ([out] BSTR *pbstrDesc);
    };

    ////////////////////////////////////////////////////////////////////////////
    // IVsProvideColorableItems interface
    //
    // NOTE: please read the text editor architecture document in the spectool
    //       and be sure that you understand the section on defining your own
    //       colorable items before you attempt to implement this interface!!!
    //
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsProvideColorableItems)
    ]
    interface IVsProvideColorableItems : IUnknown
    {
        // Number of colorable items
        HRESULT     GetItemCount ([out] int *piCount);

        // Iteration of colorable items; iIndex can range from 1 to GetItemCount()
        // We will never call for iIndex 0, since that means normal text.  You should not
        // return anything comparable to "normal text" from this interface.  See the
        // text editor architecture document if you have questions about this.
        // WARNING: this means that this is a ONE-based, not a zero-based interface!!!
        HRESULT     GetColorableItem ([in] int iIndex, [out] IVsColorableItem **ppItem);
    };

    typedef enum _COLORIZER_ATTRIBUTE
    {
      COLOR_INDEX_MASK    = 0x000000ff,
      COLOR_MARKER_MASK   = 0x00003f00,
      LINE_MARKER_MASK    = 0x000fc000,
      PRIVATE_CLIENT_MASK = 0x00f00000, // Reserved for editor client use
      HUMAN_TEXT_ATTR     = 0x01000000, // Text to be treated as natural human-language text
      SEPARATOR_AFTER_ATTR= 0x02000000, // Indicates that a visual line separator should follow the char's line.
      PRIVATE_EDITOR_MASK = 0xfc000000  // Top 6 bits reserved for editor internal use
    } COLORIZER_ATTRIBUTE;
    
    ////////////////////////////////////////////////////////////////////////////
    // IVsColorizer interface
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsColorizer)
    ]
    interface IVsColorizer : IUnknown
    {
        // If this colorizer requires per-line state maintenance, this method
        // should set pfFlag to TRUE, otherwise it should be set to FALSE.  If
        // state maintenance is not required, and editing performance will likely
        // be better.
        HRESULT     GetStateMaintenanceFlag ([out] BOOL *pfFlag);

        // Start state.  Called only if the colorizer needs state maintenance.
        // Indicates the state in which colorization of the first line of the
        // buffer should start
        HRESULT     GetStartState ([out] long *piStartState);

        // Colorize the given text.  For each character in the line of text
        // given, a matching index into the colorizer's syntax item array (+1) should
        // be placed in the color index array provided.  The colorizer should
        // start in the state provided, and return its current state (which will
        // be stored and provided as the start state when the following line is
        // colorized).  The index array given is gauranteed to be ONE ELEMENT
        // longer than the number of characters in the line.  This element is
        // used to determine the (background) color of the space to the right of
        // the last character on the line.
        //
        // Color indexes are 1-BASED -- use 0 to specify default text color.
        // pText is NOT null-terminated.  iLength is the length of the line
        // MINUS the end-of-line marker (CR, LF, CRLF pair, or 0 (EOF)), which
        // will be present.
        //
        // A colorizer should mark text to be treated as human natural-language
        // text with the HUMAN_TEXT_ATTR bit. This bit should be set for 
        // the contents of comments and strings, excluding delimiters.
        // This is used to obtain the correct layout of bidirectional text.
        // This may be used to identify when to apply natural-language rules
        // instead of programming-language rules (e.g. spell checking, word
        // boundaries).
#ifdef PROXYSTUB_BUILD
        // According with WinNT.h, HRESULT and long are the same type
        HRESULT     ColorizeLine([in] long iLine,
                                 [in] long iLength,
                                 [in] const WCHAR *pszText,
                                 [in] long iState,
                                 [out] ULONG * pAttributes);
#else
        long        ColorizeLine([in] long iLine,
                                 [in] long iLength,
                                 [in] const WCHAR *pszText,
                                 [in] long iState,
                                 [out] ULONG * pAttributes);
#endif

        // Determine the end-of-line state for the line given.  This method is
        // essentially the same as ColorizeLine, except that the line color data
        // is not required by the editor.  This method is an optimization for
        // cases when the start state for a line is needed but lines above are
        // not being displayed.  If state maintenance is not required by this
        // colorizer, this method will not be called.  Implementations should
        // be as fast as possible to keep peak editor performance.
#ifdef PROXYSTUB_BUILD
        // According with WinNT.h, HRESULT and long are the same type
        HRESULT     GetStateAtEndOfLine ([in] long iLine,
                                         [in] long iLength,
                                         [in] const WCHAR *pText,
                                         [in] long iState);
#else
        long        GetStateAtEndOfLine ([in] long iLine,
                                         [in] long iLength,
                                         [in] const WCHAR *pText,
                                         [in] long iState);
#endif

        // The buffer will call this before Release()ing the colorizer so that
        // it can Release() any references it holds on the buffer, thereby
        // breaking the circular reference chain.
#ifdef PROXYSTUB_BUILD
        HRESULT     CloseColorizer(void);
#else
        void        CloseColorizer(void);
#endif
    };

    /*//////////////////////////////////////////////////////////////////////////
    // IVsEnumGUID interface
    //
    // This is in the form of a standard COM enumerator interface.  See MSDN for docs
    // on how the standard enumerator interface works.
    //
    //////////////////////////////////////////////////////////////////////////*/
    [
        uuid(uuid_IVsEnumGUID)
    ]
    interface IVsEnumGUID : IUnknown
    {
        // caller must allocate memory for the GUID's
        HRESULT     Next ([in] ULONG celt, [out, size_is(celt), length_is(*pceltFetched)] GUID *rgelt, [out] ULONG *pceltFetched);
        HRESULT     Skip ([in] ULONG celt);
        HRESULT     Reset (void);
        HRESULT     Clone ([out] IVsEnumGUID **ppenum);
        HRESULT     GetCount ([out] ULONG *pceltCount);
    };


    ////////////////////////////////////////////////////////////////////////////
    // IVsLanguageInfo interface
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsLanguageInfo)
    ]
    interface IVsLanguageInfo : IUnknown
    {
        // Name of language (i.e. "Visual Basic", "C++", "HTML", etc..)
		// as a LOCALIZED string.
        HRESULT     GetLanguageName ([out] BSTR *bstrName);

        // File extensions belonging to this language.  If multiple, separate
        // with semicolons (i.e., ".html", ".c;.cpp;.cxx;.h;.hpp;.hxx", etc...)
        HRESULT     GetFileExtensions ([out] BSTR * pbstrExtensions);

        // Colorizer provision.  This can return an interface on the language
        // info object itself, or farm out new objects (if, for instance, the
        // colorizers for this language need state information on a per-file
        // basis)
        HRESULT     GetColorizer ([in] IVsTextLines *pBuffer, [out] IVsColorizer **ppColorizer);

        // Provide language with opportunity to add "adornments" to a code window
        HRESULT     GetCodeWindowManager ([in] IVsCodeWindow *pCodeWin, [out] IVsCodeWindowManager **ppCodeWinMgr);
    };

    ////////////////////////////////////////////////////////////////////////////
    // IVsLanguageInfo IVsUserData GUIDs
    // QueryService language SID, IVsUserData iid
    ////////////////////////////////////////////////////////////////////////////

    //--------------------------------------------------------------------------
    // GUID_VsLang_Support_CF_HTML  VT_BOOL  {27E97702-589E-11d2-8233-0080C747D9A0}
    //
    // The default behavior for most languages is TRUE
    //
    // TRUE  = Recognize CF_HTML and allow pasting/dropping the text of the HTML fragment.
    // FALSE = Don't recognize CF_HTML (HTML editor wants this).
    //
    cpp_quote("extern const __declspec(selectany) GUID GUID_VsLang_Support_CF_HTML = { 0x27e97702, 0x589e, 0x11d2, { 0x82, 0x33, 0x0, 0x80, 0xc7, 0x47, 0xd9, 0xa0 } };")

    ////////////////////////////////////////////////////////////////////////////
    //  IVsLanguageBlock
    //  Optional service of language service.
    //  Provided the same way as IVsLanguageInfo.
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsLanguageBlock)
    ]
    interface IVsLanguageBlock : IUnknown
    {
        //
        // GetCurrentBlock
        //
        // From the current position, return a textspan for the interesting
        // enclosing or nearby block of text and a short description of the 
        // block.
        //
        // Called from the view to populate the Find dialog's
        //     "Search only: <current procedure>" 
        // option where <current procedure> is the pbstrDescription text.
        //
        // The description should be short due to limited space on the Find
        // dialog.
        //
        // pfBlockAvailable must be set to TRUE when a block is available,
        // and FALSE when the position is outside any blocks.
        //
        // ptsBlockSpan may be NULL.
        // pbstrDescription may be NULL.
        //
        HRESULT GetCurrentBlock (
            [in]  IVsTextLines *    pTextLines,
            [in]  LONG              iCurrentLine,
            [in]  LONG              iCurrentChar,
            [out] TextSpan *        ptsBlockSpan,
            [out] BSTR *            pbstrDescription,
            [out, retval] BOOL *    pfBlockAvailable
            );
    }
    
    ////////////////////////////////////////////////////////////////////////////
    // IVsEnumBSTR interface
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsEnumBSTR)
    ]
    interface IVsEnumBSTR : IUnknown
    {
        HRESULT     Next ([in] ULONG celt, [out, size_is(celt), length_is(*pceltFetched)] BSTR *rgelt, [out] ULONG *pceltFetched);
        HRESULT     Skip ([in] ULONG celt);
        HRESULT     Reset (void);
        HRESULT     Clone ([out] IVsEnumBSTR **ppenum);
        HRESULT     GetCount ([out] ULONG *pceltCount);
    };

    ////////////////////////////////////////////////////////////////////////////
    // RESOLVENAMEFLAGS
    ////////////////////////////////////////////////////////////////////////////
    typedef enum _resolvenameflags
    {
        RNF_BREAKPOINT  = 0x0001,       // Resolve names for breakpoint
    } RESOLVENAMEFLAGS;

    ////////////////////////////////////////////////////////////////////////////
    // IVsDebugName interface
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsDebugName)
    ]
    interface IVsDebugName : IUnknown
    {
        HRESULT     GetName ([out] BSTR *pbstrName);
        HRESULT     GetLocation ([out] BSTR *pbstrMkDoc, [out] TextSpan *pspanLocation);
    }

    ////////////////////////////////////////////////////////////////////////////
    // IVsEnumDebugName interface
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsEnumDebugName)
    ]
    interface IVsEnumDebugName : IUnknown
    {
        HRESULT     Next ([in] ULONG celt, [out, size_is(celt), length_is(*pceltFetched)] IVsDebugName **rgelt, [out] ULONG *pceltFetched);
        HRESULT     Skip ([in] ULONG celt);
        HRESULT     Reset ();
        HRESULT     Clone ([out] IVsEnumDebugName **ppenum);
        HRESULT     GetCount ([out] ULONG *pceltCount);
    }

    ////////////////////////////////////////////////////////////////////////////
    // IVsLanguageDebugInfo interface
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsLanguageDebugInfo)
    ]
    interface IVsLanguageDebugInfo : IUnknown
    {
        // Generate "proximity" expressions, i.e., expressions surrounding the
        // given position in the given file that might spark the user's interest.
        HRESULT     GetProximityExpressions ([in]   IVsTextBuffer *pBuffer,
                                             [in]   long iLine,
                                             [in]   long iCol,
                                             [in]   long cLines,
                                             [out]  IVsEnumBSTR **ppEnum);

        // Validate the given position as a place to set a breakpoint.  If the
        // location is valid, and pCodeSpan is non-NULL, the span is filled in
        // with the extent of the statement at which execution would stop.  If
        // the position is known to not contain code, this will return S_FALSE.
        // If this function fails, the breakpoint is set, pending validation
        // during debug session startup.
        HRESULT     ValidateBreakpointLocation ([in]    IVsTextBuffer *pBuffer,
                                                [in]    long iLine,
                                                [in]    long iCol,
                                                [out]   TextSpan *pCodeSpan);

        // Generate a name for the given location in the given file. Represents
        // the "innermost named entity" in the source.  If non-NULL,
        // piLineOffset is filled with the offset from the first line
        // of the named entity.  Returns S_FALSE if the position doesn't fall
        // within anything interesting.
        HRESULT     GetNameOfLocation ([in]     IVsTextBuffer *pBuffer,
                                       [in]     long iLine,
                                       [in]     long iCol,
                                       [out]    BSTR *pbstrName,
                                       [out]    long *piLineOffset);

        // UNDONE:  Obsolete method; remove
        HRESULT     GetLocationOfName ([in]     LPCOLESTR pszName,
                                       [out]    BSTR *pbstrMkDoc,
                                       [out]    TextSpan *pspanLocation);

        // Disambiguate the given name, providing non-ambiguous names for all
        // entities that "match" the name.  The flags given is one of the RNF_*
        // flags above
        HRESULT     ResolveName ([in]   LPCOLESTR pszName,
                                 [in]   DWORD dwFlags,
                                 [out]  IVsEnumDebugName **ppNames);

        // Return the corresponding debugger back-end "language ID".  Note that
        // this is NOT the "engine ID", which should be obtained by the current
        // project or somewhere else that knows how the sources for this language
        // are being built.
        HRESULT     GetLanguageID ([in]     IVsTextBuffer *pBuffer,
                                   [in]     long iLine,
                                   [in]     long iCol,
                                   [out]    GUID *pguidLanguageID);

        // Return whether the location contains code that is mapped to another
        // document, for example client-side script code
        // Returns S_OK if the location contains mapped code, S_FALSE if not, or an error code
        HRESULT     IsMappedLocation ([in]     IVsTextBuffer *pBuffer,
                                      [in]     long iLine,
                                      [in]     long iCol);
    };

    ////////////////////////////////////////////////////////////////////////////
    // MARKERTYPE enum
    //
    // These represent the pre-registered set of markers.
    //
    ////////////////////////////////////////////////////////////////////////////
    typedef enum _markertype
    {                                                                           //  Priority
        MARKER_INVISIBLE = 0,             // Invisible marker                     100 (WARNING: internal editor team use ONLY!!!)
        MARKER_READONLY,                  // Read-only                            0  // lower pri for performance reasons
        MARKER_SHORTCUT,                  // Task list shortcut                   199
        MARKER_BOOKMARK,                  // Generic bookmark/tag                 200

        MARKER_COMPILE_ERROR,             // Compile error                        600
        MARKER_CODESENSE_ERROR,           // CodeSense error                      700
        MARKER_OTHER_ERROR,               // 3rd Party tool error                 750


        MARKER_REGION_COLLAPSED,          // A collapsible region is collapsed    801
        MARKER_REGION_EXPANDED,           // A collapsible region is expanded     800

        MARKER_LIST_LOCATION,             // Current location from result list

        DEF_MARKER_COUNT, // this should be at the end to define the number of markers

        MARKER_IDENTERROR = MARKER_COMPILE_ERROR,	// OBSOLETE!
        MARKER_SYNTAXERROR = MARKER_COMPILE_ERROR	// OBSOLETE!
    } MARKERTYPE;

    ////////////////////////////////////////////////////////////////////////////
    // ENUMMARKERFLAGS enum
    //
    // Options for the IVsTextStream::EnumMarkers and IVsTextLines::EnumMarkers methods.
    ////////////////////////////////////////////////////////////////////////////
    typedef enum _enummarkerflags
    {
		EM_DEFAULT			= 0x00000000,   // default settings
        EM_ENTIREBUFFER     = 0x00000001,   // ignore iPos and iLen parameters
        EM_ALLTYPES         = 0x00000002,   // ignore iMarkerType parameter
        EM_SORTDESCENDING   = 0x00000004,   // sort in descending order
        EM_SORTPRIORITY     = 0x00000008,   // sort by marker priority
        EM_GLYPHINSPAN      = 0x00000010,   // return markers that 1) have a margin glyph & 2) start at the same line at the specified span
        EM_INCLUDEINVISIBLE = 0x00000020,    // includes invisible markers; normally they are excluded
        // discludes any marker whos span is not fully contained in the given span.  Ex: marker from col 0-1 and maker form col 1-3.  Given span 0-1 you will only get marker1. 
        // Given span 1-2 you will only get marker 2.  Given span 0-2 you will get both.
        EM_CONTAINED        = 0x00000040  
    } ENUMMARKERFLAGS;

    ////////////////////////////////////////////////////////////////////////////
    // FINDMARKERFLAGS enum
    //
    // Options for the IVsTextBuffer::FindMarkerByPosition method.
    ////////////////////////////////////////////////////////////////////////////
    typedef enum _findmarkerflags
    {
        FM_FORWARD      = 0x00000000, // search forward (implicit)
        FM_BACKWARD     = 0x00000001, // search backward
        // FUTURE: could have other flags to prevent looping, etc.
    } FINDMARKERFLAGS;

    ////////////////////////////////////////////////////////////////////////////
    // BUFFERSTATEFLAGS enum
    //
    // Options for the IVsTextBuffer::Get/SetStateFlags methods.
    ////////////////////////////////////////////////////////////////////////////
    typedef enum _bufferstateflags
    {
        BSF_USER_READONLY       = 0x00000001, // user marked it as read only -- no editing allowed at all
        BSF_FILESYS_READONLY    = 0x00000002, // RO on filesystem; possibly under SCC
        BSF_MODIFIED            = 0x00000004, // whether it's been modified  UNDONE: what if one undoes all actions?
        BSF_SUPPRESS_UI         = 0x00000008, // whether to prevent the buffer from showing UI (off by default)

        BSF_RESERVED            = ~(BSF_USER_READONLY | BSF_FILESYS_READONLY | BSF_MODIFIED)
    } BUFFERSTATEFLAGS;

    ////////////////////////////////////////////////////////////////////////////
    // BufferLockFlags enum
    //
    // Options for the IVsTextBuffer/IVsTextLayer::Lock/UnlockBufferEx methods.
    ////////////////////////////////////////////////////////////////////////////

    typedef enum _BufferLockFlags
    {
        BLF_READ            =   0x0,    // causes writes from other threads to block, but allows reads
        BLF_READ_AND_WRITE  =   0x1     // causes writes and reads from other threads to block (implies BLF_READ)
    } BufferLockFlags;


    typedef enum _textbufferinitflags
    {
        BIF_DEFAULT         =   0x0,
        BIF_CUSTOMSTORAGE   =   0x1,
        BIF_INITTEXT        =   0x2
        // FUTURE: could specify threading preference here
    } TextBufferInitFlags;

    typedef struct
    {
        DWORD dwFlags;          // ORing of TextBufferInitFlags enum
        IUnknown *pStorage;     // relevant if BIF_CUSTOMSTORAGE specified
        const WCHAR *pszText;   // relevant if BIF_INITTEXT specified
        long iLength;           // relevant if BIF_INITTEXT specified
    } BUFFERINITEX;

    ////////////////////////////////////////////////////////////////////////////
    // IVsTextBufferTempInit interface
    //
    // Temporary interface for special initialization.
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsTextBufferTempInit)
    ]
	interface IVsTextBufferTempInit : IUnknown
	{
		// new initialization methods
		HRESULT		InitializeContentEx(
			[in] BUFFERINITEX *pInit);
	};


    ////////////////////////////////////////////////////////////////////////////
    // IVsTextBuffer interface
    //
    // Abstraction over a block of (Unicode) text.
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsTextBuffer)
    ]
    interface IVsTextBuffer : IUnknown
    {
        // [Un]LockBuffer() deprecated in Dev10.  IVsTextBuffer should be accessed from the UI thread.
        HRESULT     LockBuffer (void);
        HRESULT     UnlockBuffer (void);

        // Initialize content (will fail unless called on brand new untitled buffer)
        HRESULT     InitializeContent ([in] const WCHAR *pszText, [in] long iLength);

        // state flags include: modified, read-only, read-only on disk
        HRESULT     GetStateFlags ([out] DWORD *pdwReadOnlyFlags); // bitwise union of BUFFERSTATEFLAGS values
        HRESULT     SetStateFlags ([in] DWORD dwReadOnlyFlags); // bitwise union of BUFFERSTATEFLAGS values

        // NOTE:  These methods could be expensive, depending upon the underlying
        // implementation of the buffer (i.e. it could be very difficult to
        // calculate the size of the buffer if it is a virtual-line-oriented
        // implementation as VB's, etc.).  The only methods used heavily by views
        // and that should be reasonably efficient by all implementations are
        // GetLineCount() and GetLengthOfLine().

        HRESULT     GetPositionOfLine([in] long iLine, [out] long *piPosition);
        HRESULT     GetPositionOfLineIndex([in] long iLine, [in] CharIndex iIndex, [out] long *piPosition);
        HRESULT     GetLineIndexOfPosition([in] long iPosition, [out] long *piLine, [out] CharIndex *piColumn);
        HRESULT     GetLengthOfLine ([in] long iLine, [out] long *piLength);
        HRESULT     GetLineCount ([out] long *piLineCount);
        HRESULT     GetSize ([out] long *piLength);

        HRESULT     GetLanguageServiceID ([out] GUID *pguidLangService);
        HRESULT     SetLanguageServiceID ([in] REFGUID guidLangService);

        HRESULT     GetUndoManager ([out] IOleUndoManager **ppUndoManager);

        HRESULT     Reserved1(void);
        HRESULT     Reserved2(void);

        HRESULT     Reserved3(void);
        HRESULT     Reserved4(void);

        HRESULT     Reload([in] BOOL fUndoable);

        // new, more general locking mechanism
        // [Un]LockBufferEx() deprecated in Dev10.  IVsTextBuffer should be accessed from the UI thread.
        HRESULT     LockBufferEx([in] DWORD dwFlags); // dwFlags is an ORing of BufferLockFlags (presently either BLF_READ or BLF_WRITE)
        HRESULT     UnlockBufferEx([in] DWORD dwFlags); // dwFlags is an ORing of BufferLockFlags (presently either BLF_READ or BLF_WRITE)

        HRESULT     GetLastLineIndex ([out] long *piLine, [out] long *piIndex); // gets length of last line; shortcut for frequent pattern of calling GetLineCount & then GetLengthOfLine on that line

        // we reserve these slots in the vtbl for future use
        HRESULT     Reserved5(void);
        HRESULT     Reserved6(void);
        HRESULT     Reserved7(void);
        HRESULT     Reserved8(void);
        HRESULT     Reserved9(void);
        HRESULT     Reserved10(void);
    };

    ////////////////////////////////////////////////////////////////////////////
    // CHARFMT enum -- file encoding format
    ////////////////////////////////////////////////////////////////////////////
    typedef enum _CHARFMT
    {
        CHARFMT_UNI,        // Unicode
        CHARFMT_UNI_SWAP,   // Byte-swapped Unicode
        CHARFMT_MBCS,       // MBCS
        CHARFMT_UTF8        // UTF-8 with file signature
    } CHARFMT;

    ////////////////////////////////////////////////////////////////////////////
    // EOLTYPE -- identifies the thing that terminated a given line
    ////////////////////////////////////////////////////////////////////////////
    typedef enum _EOLTYPE
    {
        eolCRLF = 0,        // MS-DOS \r\n carriage-return/linefeed
        eolCR,              // Mac    \r
        eolLF,              // Unix   \n
        eolUNI_LINESEP,     // Unicode line separator
        eolUNI_PARASEP,     // Unicode paragraph separator
        eolEOF,             // End of file
        eolNONE,            // Artificial ending point (e.g. word-wrapped line)
        MAX_EOLTYPES
    } EOLTYPE;

    ////////////////////////////////////////////////////////////////////////////
    // LINEDATAEXFLAGS -- add'l info about a line
    ////////////////////////////////////////////////////////////////////////////
    typedef enum _LINEDATAEXFLAGS
    {
        ldfDefault      = 0x0,  // nothing unusual
        ldfMarkers      = 0x1,  // markers do inline coloring of the text of this line
        ldfNoReadLock   = 0x2  // no locking was done for this line data
    } LINEDATAEXFLAGS;

    ////////////////////////////////////////////////////////////////////////////
    // LINEDATA structure
    //
    // Used to pass direct-access to line data in a buffer through IVsTextLines
    ////////////////////////////////////////////////////////////////////////////
    typedef struct _linedata
    {
        long            iLength;            // # of plain text characters, excluding EOL
#ifdef PROXYSTUB_BUILD
        // _linedata structure is used as out parameter by some interfaces, so it can not have
        // const member, otherwise the midl compiler will complain creating the proxy/stub code
              WCHAR     *pszText;           // NOTE:  NOT NULL TERMINATED!  Use iLength to determine end of text
              ULONG     *pAttributes;
#else
        const WCHAR     *pszText;           // NOTE:  NOT NULL TERMINATED!  Use iLength to determine end of text
        const ULONG     *pAttributes;
#endif
        EOLTYPE         iEolType;
        BOOL            fMarkers;
    } LINEDATA;


    ////////////////////////////////////////////////////////////////////////////
    // AtomicText structure
    //
    // Describes an embedded object within a LINEDATAEX (see below for that).
    ////////////////////////////////////////////////////////////////////////////

    typedef struct _tag_AtomicText AtomicText;

    struct _tag_AtomicText
    {
        AtomicText       *pNext;
        CharIndex        iIndex;  // index of position into line
#ifdef PROXYSTUB_BUILD
        // This structure is used as out parameter, so it can't have const members.
              WCHAR      *pszAtomicText;
#else
        const WCHAR      *pszAtomicText;
#endif
        IUnknown         *punkAtom; // IUnknown on originating object for any custom processing
    };

    ////////////////////////////////////////////////////////////////////////////
    // LINEDATAEX structure
    //
    // Like LINEDATA, but used by GetLineDataEx
    ////////////////////////////////////////////////////////////////////////////
    typedef struct _linedataex
    {
        long            iLength;            // # of plain text characters, excluding EOL
#ifdef PROXYSTUB_BUILD
        // This struct is used as out parameter, so it can't have const members.
              WCHAR   * pszText;            // NOTE:  NOT NULL TERMINATED!  Use iLength to determine end of text
#else
        const WCHAR   * pszText;            // NOTE:  NOT NULL TERMINATED!  Use iLength to determine end of text
#endif
        EOLTYPE         iEolType;
#ifdef PROXYSTUB_BUILD
        // This struct is used as out parameter, so it can't have const members.
              ULONG   * pAttributes;
#else
        const ULONG   * pAttributes;
#endif
        USHORT          dwFlags;            // formerly fMarkers field; now an ORing of LINEDATAFLAGS enum
        USHORT          dwReserved;         // reserved for use by IVsTextLines implementation
        AtomicText * pAtomicTextChain;      // list of embedded objects within the line
    } LINEDATAEX;

    typedef enum _paintingrestrictions
    {
        PR_NONE = 0, // no restrictions
        PR_NO_MARGIN // no widget margin available
    } PAINTINGRESTRICTIONS;

    ////////////////////////////////////////////////////////////////////////////
    // MARKERDATA structure
    //
    // Used to pass information about markers that involves lines in a given
    // range.  For each n < iCount, rgpMarker[n] STARTS on line rgiLine[n].  The
    // array is guaranteed to be sorted by priority lowest to highest.  As an
    // optimization in GetLineData, for each n : iTopLine <= n <= iBottomLine,
    // rgfLineMarker[n - iTopLine] is TRUE if a marker involved line n.
    ////////////////////////////////////////////////////////////////////////////

    typedef struct _tag_MARKERDATA MARKERDATA;

    struct _tag_MARKERDATA
    {
        long                   iTopLine;           // Top line of range
        long                   iBottomLine;        // Bottom line of range
        long                   iCount;             // Number of markers contained
        IVsTextLayerMarker     **rgpMarker;        // Marker instance
        BOOL                   *rgfLineMarked;     // Used by GetLineData for optimization
        IVsTextLayer           *pLayer;            // The layer originating this information
        MARKERDATA             *pNext;             // Next entry in our linked list
    };

    /*
        GLDE_FLAGS enum

        Used as params to GetLineDataEx
    */
    typedef enum _GLDE_FLAGS
    {
        gldeDefault         =   0x00000000,    // default behavior: whole line, no attributes, regular locking
        gldeSubset          =   0x00000001,    // get info only for line subset defined by iStartIndex & iEndIndex (does what GetLineSubsetData did)
        gldeColorizerState  =   0x00000002,    // NO LONGER USED!!!
        gldeSyntaxAttr      =   0x00000004,    // return syntax coloring attributes (as GetLineData2 did) and colorizer state
        gldeMarkerAttr      =   0x00000008,    // return marker coloring attributes plus other attributes
        gldeFullAttr        =   gldeSyntaxAttr | gldeMarkerAttr,

        /*
            WARNING: gldeNoReadLock tells GetLineDataEx/ReleaseLineDataEx to skip locking entirely.  This is only
            safe to do if you have separately put a read (or read/write) lock on the buffer beforehand, and keep
            it locked until you've released the LINEDATAEX structure again via ReleaseLineDataEx.

            This allows a fast iteration over an entire set of lines, factoring out the locking overhead (which
            becomes significant if you're iterating over many lines).
        */
        gldeNoReadLock      =   0x00000010,
        
        gldeNoWidgetMargin  =   0x00000020,   // means there's no widget margin, so appropriate markers can color text
    } GLDE_FLAGS;

    /*
        REPLACE_TEXT_FLAGS
    */
    typedef enum _REPLACE_TEXT_FLAGS
    {
        rtfDefault                  = 0x0000, // does newline normalization
        rtfKeepMarkers              = 0x0001,
        rtfDoNotNormalizeNewlines   = 0x0002,
        rtfNormalizeTabsAndSpaces   = 0x0004, // not yet supported
        rtfSyntacticReformat        = 0x0008, // not yet supported
        rtfClientSuppressFormatting = 0x0010, // Stop OnReplace() listeners from formatting code
        rtfInterimText              = 0x0020  // The last character of the inserted text 
                                              //   is an interim character from the IME
    } REPLACE_TEXT_FLAGS;

    ////////////////////////////////////////////////////////////////////////////
    // IVsTextLines interface
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsTextLines)
    ]
    interface IVsTextLines : IVsTextBuffer
    {
        // Same as IVsOLDTextLines...
        HRESULT     GetMarkerData     ([in] long iTopLine, [in] long iBottomLine, [out] MARKERDATA *pMarkerData);
        HRESULT     ReleaseMarkerData ([in] MARKERDATA *pMarkerData);
        HRESULT     GetLineData       ([in] long iLine, [out] LINEDATA *pLineData, [in] MARKERDATA *pMarkerData);
        HRESULT     ReleaseLineData   ([in] LINEDATA *pLineData);

        // Puts the specified span of text into a BSTR; it is the caller's responsibility to free the BSTR.
        HRESULT     GetLineText(
            [in] long       iStartLine,  // starting line
            [in] CharIndex  iStartIndex, // starting character index within the line (must be <= length of line)
            [in] long       iEndLine,    // ending line
            [in] CharIndex  iEndIndex,   // ending character index within the line (must be <= length of line)
            [out] BSTR *    pbstrBuf);     // text to insert, if any

        // Puts the specified span of text into a caller-allocated buffer; this will 
        // copy up to cchBuf characters, and if the buffer wasn't big enough, returns
        // BUFFER_E_DEST_TOO_SMALL and sets *pcchBuf to the required size.
        // To just get the required size, you can pass in NULL for pszBuf.
        // NOTE: CopyLineText does NOT append NULL to the output string.
        HRESULT     CopyLineText(
            [in] long       iStartLine,  // starting line
            [in] CharIndex  iStartIndex, // starting character index within the line (must be <= length of line)
            [in] long       iEndLine,    // ending line
            [in] CharIndex  iEndIndex,   // ending character index within the line (must be <= length of line)
            [in] LPWSTR     pszBuf,      // text to insert, if any
            [in, out] long *pcchBuf);    // NOTE: this is a count of UNICODE CHARACTERS, *not* BYTES!!!

        // Stream-like line editing -- handles line breaking/joining, etc.
       HRESULT     ReplaceLines (
            [in] long       iStartLine,  // starting line
            [in] CharIndex  iStartIndex, // starting character index within the line (must be <= length of line)
            [in] long       iEndLine,    // ending line
            [in] CharIndex  iEndIndex,   // ending character index within the line (must be <= length of line)
            [in] LPCWSTR    pszText,     // text to insert, if any
            [in] long       iNewLen,     // # of chars to insert, if any
            [out] TextSpan *pChangedSpan);  // range of characters changed

       HRESULT     CanReplaceLines(
            [in] long       iStartLine,  // starting line
            [in] CharIndex  iStartIndex, // starting character index within the line (must be <= length of line)
            [in] long       iEndLine,    // ending line
            [in] CharIndex  iEndIndex,   // ending character index within the line (must be <= length of line)
            [in] long       iNewLen);    // # of chars to insert, if any

        // Markers -- note that these are line-oriented markers -- use IVsTextStream
        // to create stream-oriented ones
        HRESULT     CreateLineMarker (
            [in]  long       iMarkerType,
            [in]  long       iStartLine,   // starting line
            [in]  CharIndex  iStartIndex,  // starting character index within the line (must be <= length of line)
            [in]  long       iEndLine,     // ending line
            [in]  CharIndex  iEndIndex,    // ending character index within the line (must be <= length of line)
            [in]  IVsTextMarkerClient * pClient,
            [out] IVsTextLineMarker ** ppMarker); // if this is NULL, it means that the marker is buffer-owned

        // IVsTextLines::EnumMarkers enumerates ALL markers, but gets their IVsTextLineMarker interface via IVsEnumLineMarkers.
        HRESULT     EnumMarkers(
            [in]  long       iStartLine,   // starting line
            [in]  CharIndex  iStartIndex,  // starting character index within the line (must be <= length of line)
            [in]  long       iEndLine,     // ending line
            [in]  CharIndex  iEndIndex,    // ending character index within the line (must be <= length of line)
            [in]  long       iMarkerType,
            [in]  DWORD      dwFlags,      // ORing of ENUMMARKERFLAGS
            [out] IVsEnumLineMarkers ** ppEnum);
        HRESULT     FindMarkerByLineIndex ([in] long iMarkerType, [in] long iStartingLine, [in] CharIndex iStartingIndex, [in] DWORD dwFlags, [out] IVsTextLineMarker **ppMarker);

        // event advisement/unadvisement

        // not implemented (QI for IConnectionPointContainer and use IConnectionPointContainer::FindConnectionPoint)
        HRESULT     AdviseTextLinesEvents([in] IVsTextLinesEvents *pSink, [out] DWORD *pdwCookie);
        // not implemented (QI for IConnectionPointContainer and use IConnectionPointContainer::FindConnectionPoint)
        HRESULT     UnadviseTextLinesEvents([in] DWORD dwCookie);

        // OBSOLETE: Do not implement
        HRESULT     GetPairExtents([in] const TextSpan *pSpanIn, [out] TextSpan *pSpanOut);

        /*
            ReloadLines indicates that the text should be replaced, but that markers should not be deleted.
            You should only use this interface in special circumstances, such as when a buffer is being
            reloaded from disk or when a Wizard is substituting a particular section of code.
        */
        HRESULT     ReloadLines (
            [in]  long       iStartLine,   // starting line
            [in]  CharIndex  iStartIndex,  // starting character index within the line (must be <= length of line)
            [in]  long       iEndLine,     // ending line
            [in]  CharIndex  iEndIndex,    // ending character index within the line (must be <= length of line)
            [in]  LPCWSTR    pszText,      // text to insert, if any
            [in]  long       iNewLen,      // # of chars to insert, if any
            [out] TextSpan * pChangedSpan);// range of characters changed

        // Like GetLineData, but gets attributes without marker info.
        // Only the bits in COLOR_INDEX_MASK|HUMAN_TEXT_ATTR are guaranteed to be valid.
        // When fAttributes is false, this is the same as GetLineData(iLine, &ld, NULL);
        HRESULT     IVsTextLinesReserved1( /* formerly GetLineData2, which is now obsolete */
            [in]  long       iLine,
            [out] LINEDATA * pLineData,
            [in]  BOOL       fAttributes  // You want color with that?
            );

        // End VS6 compatibility section

        // the mother of all GetLineData calls
        HRESULT     GetLineDataEx ([in] DWORD dwFlags, [in] long iLine, [in] long iStartIndex, [in] long iEndIndex, [out] LINEDATAEX *pLineData, [in] MARKERDATA *pMarkerData);
        HRESULT     ReleaseLineDataEx ([in] LINEDATAEX *pLineData); // releases LINEDATAEX

		HRESULT     CreateEditPoint ([in] long iLine, [in] CharIndex iIndex, [out] IDispatch **ppEditPoint);

        // Line editing -- handles line breaking/joining, etc.
        HRESULT     ReplaceLinesEx (
            [in] DWORD      dwFlags,     // special handling; ORing of REPLACE_TEXT_FLAGS enum
            [in] long       iStartLine,  // starting line
            [in] CharIndex  iStartIndex, // starting character index within the line (must be <= length of line)
            [in] long       iEndLine,    // ending line
            [in] CharIndex  iEndIndex,   // ending character index within the line (must be <= length of line)
            [in] LPCWSTR    pszText,     // text to insert, if any
            [in] long       iNewLen,     // # of chars to insert, if any
            [out] TextSpan *pChangedSpan);  // range of characters changed

		HRESULT     CreateTextPoint ([in] long iLine, [in] CharIndex iIndex, [out] IDispatch **ppTextPoint);
    };

    ////////////////////////////////////////////////////////////////////////////
    // IVsTextColorState interface
    //
    // Implemented by the standard text buffer, consumed by IVsColorizer instances
    // or any other outside party instigating a change to the color states of lines
    // in a text buffer (without necessarily changing the contents of the buffer itself).
    //
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsTextColorState)
    ]
    interface IVsTextColorState : IUnknown
    {
        // Colorizers that need to signal changes in color status of a set of lines
        // will call this. The buffer's implementation will be color calculate the
        // color state at the end of each line from iTopLine to iBottomLine, and
        // continue calculating EOL states until a line reports the same color state
        // (as it does today following a content change).  The buffer will then fire
        // OnChangeAttributes to relay this color change to listening views.
        // iTopLine = -1, iBottomLine = -1 is a special case that means colorize all lines
        HRESULT ReColorizeLines ([in] long  iTopLine, [in] long iBottomLine);

        // Returns the buffer's cached state for the start of the given line.
        // You may not call this method if you return FALSE for IVsColorizer::GetStateMaintenanceFlag().

        // WARNING 1: may result in callbacks to colorize previous lines if the state isn't
        // already in the buffer's cache.

        // WARNING 2: this function will not work correctly if called from within an
        // IVsTextLinesEvent::OnChangeLineText() handler, because that event is called
        // before the associated event to update colorization.  If you want to use this
        // from within an IVsTextLinesEvent::OnChangeLineText() handler, you first need
        // call the above ReColorizeLines() method on the line(s) you're interested in
        // to make sure the colorization state is in place.

        // WARNING 3: the same applies to IVsFinalTextChangeCommitEvents::OnChangesCommitted() as
        // applies to IVsTextLinesEvent::OnChangeLineText(), since in the case where it's only a
        // CCG_MULTILINE_CHANGE gesture (e.g. automation or some random component partied on the
        // document) the colorization info still wouldn't be ready yet.
        HRESULT GetColorStateAtStartOfLine([in] long iLine, [out] long *piState);
    }

/*
	TextLineChange structure

*/
	typedef struct _TextLineChange
	{
        CharIndex   iStartIndex;
        long        iStartLine;
        CharIndex   iOldEndIndex;
        long        iOldEndLine;
        CharIndex   iNewEndIndex;
        long        iNewEndLine;
	} TextLineChange;

    ////////////////////////////////////////////////////////////////////////////
    // IVsTextLinesEvents interface
    //
    // Events fired by line-oriented text buffers
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsTextLinesEvents)
    ]
    interface IVsTextLinesEvents : IUnknown
    {
#ifdef PROXYSTUB_BUILD
        HRESULT OnChangeLineText(
            [in] const TextLineChange *pTextLineChange,
            [in] BOOL fLast);

        HRESULT OnChangeLineAttributes ([in] long iFirstLine,
                                        [in] long iLastLine);
#else
        void OnChangeLineText(
            [in] const TextLineChange *pTextLineChange,
            [in] BOOL fLast);

        void        OnChangeLineAttributes ([in] long iFirstLine,
                                            [in] long iLastLine);
#endif
    };


    ////////////////////////////////////////////////////////////////////////////
    // IVsTextStream interface
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsTextStream)
    ]
    interface IVsTextStream : IVsTextBuffer
    {
        // Text retrieval (NOTE:  Was GetText(); no retrieval of attributes here)
        HRESULT     GetStream ([in] long iPos, [in] long iLength, [out] WCHAR *pszDest); // be sure to allocate a buffer of iLength+1 since this call appends a NULL

        // Editing
        HRESULT     ReplaceStream ([in] long iPos,
                                   [in] long iOldLen,
                                   [in] LPCOLESTR pszText,
                                   [in] long iNewLen);

        HRESULT     CanReplaceStream ([in] long iPos,
                                      [in] long iOldLen,
                                      [in] long iNewLen);

        // Markers -- note that these are stream-oriented markers -- use IVsTextLines
        // to create line markers
        HRESULT     CreateStreamMarker ([in] long iMarkerType, [in] long iPos, [in] long iLength, [in] IVsTextMarkerClient *pClient, [out] IVsTextStreamMarker **ppMarker); // if ppMarker is NULL, it means that the marker is buffer-owned

		// IVsTextStream::EnumMarkers enumerates ALL markers, but gets their IVsTextStreamMarker interface via IVsEnumStreamMarkers.
        HRESULT     EnumMarkers ([in] long iPos, [in] long iLen, [in] long iMarkerType, [in] DWORD dwFlags, [out] IVsEnumStreamMarkers **ppEnum);
        HRESULT     FindMarkerByPosition([in] long iMarkerType, [in] long iStartingPos, [in] DWORD dwFlags, [out] IVsTextStreamMarker **ppMarker);

		// not implemented 'til VS99 (QI for IConnectionPointContainer and use IConnectionPointContainer::FindConnectionPoint)
		HRESULT		AdviseTextStreamEvents([in] IVsTextStreamEvents *pSink, [out] DWORD *pdwCookie);
		// not implemented 'til VS99 (QI for IConnectionPointContainer and use IConnectionPointContainer::FindConnectionPoint)
		HRESULT		UnadviseTextStreamEvents([in] DWORD dwCookie);

        /*
			ReloadStream indicates that the text should be replaced, but that markers should not be deleted.
			You should only use this interface in special circumstances, such as when a buffer is being
			reloaded from disk or when a Wizard is substituting a particular section of code.
		*/
        HRESULT     ReloadStream (
			[in] long iPos,
            [in] long iOldLen,
            [in] const WCHAR *pszText,
            [in] long iNewLen);

		HRESULT     CreateEditPoint ([in] long iPosition, [out] IDispatch **ppEditPoint);

        // more general version of ReplaceStream/ReloadStream
        HRESULT     ReplaceStreamEx (
                    [in] DWORD dwFlags,     // special handling; ORing of REPLACE_TEXT_FLAGS enum
                    [in] long iPos,
                    [in] long iOldLen,
                    [in] const WCHAR *pszText,
                    [in] long iNewLen,
                    [out] long *piActualLen);

		HRESULT     CreateTextPoint ([in] long iPosition, [out] IDispatch **ppTextPoint);
    };



    /////////////////////////////////////////////////////////////////////////
    // IVsEnumStreamMarkers interface
    /////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsEnumStreamMarkers)
    ]
    interface IVsEnumStreamMarkers : IUnknown
    {
        HRESULT     Reset(void);
        HRESULT     Next([out, retval] IVsTextStreamMarker** ppRetval);
        HRESULT     GetCount([out] long *pcMarkers);
    };

    /////////////////////////////////////////////////////////////////////////
    // IVsEnumLineMarkers interface
    /////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsEnumLineMarkers)
    ]
    interface IVsEnumLineMarkers : IUnknown
    {
        HRESULT     Reset(void);
        HRESULT     Next([out, retval] IVsTextLineMarker** ppRetval);
        HRESULT     GetCount([out] long *pcMarkers);
    };

    /////////////////////////////////////////////////////////////////////////
    // IVsEnumLayerMarkers interface
    /////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsEnumLayerMarkers)
    ]
    interface IVsEnumLayerMarkers : IUnknown
    {
        HRESULT     Reset(void);
        HRESULT     Next([out] IVsTextLayerMarker** ppRetval);
        HRESULT     GetCount([out] long *pcMarkers);
    };

    typedef enum _MarkerCommandValues
    {
        mcvFirstContextMenuCommand   = 0x000,
        mcvLastContextMenuCommand    = 0x009,
        mcvGlyphSingleClickCommand   = 0x101, // fired for a _single_ click on the glyph (if one exists)
        mcvBodyDoubleClickCommand    = 0x102, // fired for a _double_ click on the body text
        mcvGlyphDoubleClickCommand   = 0x103  // fired for a _double_ click on the glyph (if one exists)
    } MarkerCommandValues;


    /////////////////////////////////////////////////////////////////////////
    // IVsTextMarker interface
    //
    // A "text marker" tracks edits in its owning buffer and maintains the
    // position data so that interested parties can query the new position
    // information post-edit.  Note that if any part of the range specified
    // in the creation of the marker is involved in an edit, the marker
    // becomes invalid.
    /////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsTextMarker)
    ]
    interface IVsTextMarker : IUnknown
    {
        // Marker type
        HRESULT     GetType ([out] long *piMarkerType);
        HRESULT     SetType ([in] long iMarkerType);

		// Visual style
		HRESULT		GetVisualStyle([out] DWORD *pdwFlags);
        HRESULT     SetVisualStyle([in] DWORD dwFlags); // NOTE: if you call this, the settings are lost if SetType is called!!

        // To prevent it from appearing in UI, even if there are lingering references to it, call this
        HRESULT     Invalidate(void);

        // Draws a glyph in the given DC & RECT
        HRESULT     DrawGlyph([in] HDC hdc, [in] RECT *pRect);

		// Text to display in a tip.
		HRESULT		GetTipText([out, optional] BSTR *pbstrText);

		// Unadvise the client, if any
		HRESULT		UnadviseClient(void);

		// Commands -- see MarkerCommandValues for meaning of iItem param
		HRESULT		GetMarkerCommandInfo([in] long iItem, [out, custom(uuid_IVsTextMarker, "optional")] BSTR * pbstrText, [out] DWORD* pcmdf);
		HRESULT		ExecMarkerCommand([in] long iItem);

        // Marker behavior
        HRESULT     GetBehavior ([out] DWORD *pdwBehavior);
        HRESULT     SetBehavior ([in] DWORD dwBehavior);

        // Priority index.  Highest value gets topmost placement.
        HRESULT     GetPriorityIndex ([out] long *piPriorityIndex);
	};


    ////////////////////////////////////////////////////////////////////////////
    // IVsTextStreamMarker
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsTextStreamMarker)
    ]
    interface IVsTextStreamMarker : IVsTextMarker
    {
        // Access to associated buffer
        HRESULT     GetStreamBuffer ([out] IVsTextStream **ppBuffer);

        // Reset position
        HRESULT     ResetSpan ([in] long iNewPos, [in] long iNewLen);

        // Get position information
        HRESULT     GetCurrentSpan ([out] long *piPos, [out] long *piLen);
	};

    ////////////////////////////////////////////////////////////////////////////
    // IVsTextLineMarker
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsTextLineMarker)
    ]
    interface IVsTextLineMarker : IVsTextMarker
    {
        // Access to associated buffer
        HRESULT     GetLineBuffer([out] IVsTextLines **ppBuffer);

        // Reset position
        HRESULT     ResetSpan (
			[in] long      iStartLine,	// starting line
			[in] CharIndex iStartIndex,	// starting character index within the line (must be <= length of line)
			[in] long      iEndLine,	// ending line
			[in] CharIndex iEndIndex	// ending character index within the line (must be <= length of line)
			);

        // Current position
        HRESULT     GetCurrentSpan ([out] TextSpan *pSpan);
	};


    ////////////////////////////////////////////////////////////////////////////
    // IVsTextLayerMarker
    ////////////////////////////////////////////////////////////////////////////

    /*
        This is an interface exposed by marker objects that live in an arbitrary layer.  They are
        a more general concept than a buffer marker.  Buffer markers are by definition layer markers,
        but some layers that are not buffers can also originate markers.  If you have an IVsTextLineMarker
        or IVsTextStreamMarker * it is guaranteed that you can QI for IVsTextLayerMarker, but not vice
        versa.  (This will be true for buffer-originated markers however.)
    */

    [
        uuid(uuid_IVsTextLayerMarker)
    ]
    interface IVsTextLayerMarker : IVsTextMarker
    {
        // Access to associated layer
        HRESULT     GetTextLayer([out] IVsTextLayer **ppLayer);

        // Reset position
        HRESULT     ResetSpan (
			[in] long      iStartLine,	// starting line
			[in] CharIndex iStartIndex,	// starting character index within the line (must be <= length of line)
			[in] long      iEndLine,	// ending line
			[in] CharIndex iEndIndex	// ending character index within the line (must be <= length of line)
			);

        // Current position
        HRESULT     GetCurrentSpan ([out] TextSpan *pSpan);

        HRESULT     IsInvalidated(void); // whether marker was invalidated: S_OK == yes, S_FALSE == no (i.e. Invalidate() called or buffer freed)
#ifdef PROXYSTUB_BUILD
        HRESULT     QueryClientInterface([in] REFIID iid, [out, iid_is(iid)] void **ppClient);
#else
        HRESULT     QueryClientInterface([in] REFIID iid, [out] void **ppClient);
#endif

        HRESULT     DrawGlyphEx(
			[in] DWORD dwFlags, // ORing of GLYPHDRAWFLAGS
			[in] HDC hdc, 
			[in] RECT *pRect, 
			[in] long iLineHeight);
   };


    /////////////////////////////////////////////////////////////////////////
    // IVsTextMarkerType interface
    //
    // This interface presents a uniform way to talk to any marker type, be it
    // predefined by the editor or registered by a package.
    //
    /////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsTextMarkerType)
    ]
    interface IVsTextMarkerType : IUnknown
    {
        // Visual type for this marker (foreground/background color, or line)
        HRESULT     GetVisualStyle ([out] DWORD* pdwVisualFlags); // a bitwise union of MARKERVISUAL enum values

        // Default foreground/background colors for this marker
        HRESULT     GetDefaultColors ([out] COLORINDEX *piForeground, [out] COLORINDEX *piBackground);

        // Default line attributes for this marker
        HRESULT     GetDefaultLineStyle ([out] COLORINDEX *piLineColor, [out] LINESTYLE *piLineIndex);

        // Draws a glyph in the given DC & RECT
        HRESULT     DrawGlyph([in] HDC hdc, [in] RECT *pRect);

        // Behavior flags.  For now, only streaming and line-spanning are supported.
        HRESULT     GetBehaviorFlags([out] DWORD *pdwFlags);

        // Priority index.  Highest value gets topmost placement.
        HRESULT     GetPriorityIndex ([out] long *piPriorityIndex);

		// Displayable name
        HRESULT     GetDisplayName ([out] BSTR *pbstrName); // SHOULD be localized

        // Draws a glyph in the given DC & RECT
        HRESULT     DrawGlyphEx(
			[in] DWORD dwFlags,  // ORing of GLYPHDRAWFLAGS
			[in] HDC hdc, 
			[in] RECT *pRect, 
			[in] long iLineHeight);
    };

    /////////////////////////////////////////////////////////////////////////
    // IVsTextMarkerColorSet interface
    //
    // Passed to IVsPackageDefinedTextMarkerType::DrawGlyphWithColors() to
    // allow a marker type to sneak a look at other marker types in case the
    // glyph has colors tied to other types.
    //
    /////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsTextMarkerColorSet)
    ]
    interface IVsTextMarkerColorSet : IUnknown
    {
        HRESULT     GetMarkerColors([in] long iMarkerType, [out] COLORREF *pclrFore, [out] COLORREF *pclrBack);
    };

    /////////////////////////////////////////////////////////////////////////
    // IVsPackageDefinedTextMarkerType interface
    //
    // When a package registers an external marker type, this interface is
    // implemented for each marker type.
	//
	// NOTE: implementors of this interface MUST ALSO IMPLEMENT IVsMergeableUIItem.
    //
    /////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsPackageDefinedTextMarkerType)
    ]
    interface IVsPackageDefinedTextMarkerType : IUnknown
    {
        // Visual type for this marker (foreground/background color, or line)
        HRESULT     GetVisualStyle ([out] DWORD* pdwVisualFlags); // a bitwise union of MARKERVISUAL enum values

        // Default foreground/background colors for this marker
        HRESULT     GetDefaultColors ([out] COLORINDEX *piForeground, [out] COLORINDEX *piBackground);

        // Default line attributes for this marker
        HRESULT     GetDefaultLineStyle ([out] COLORINDEX *piLineColor, [out] LINESTYLE *piLineIndex);

        // Default font flags for this marker
        HRESULT     GetDefaultFontFlags ([out] DWORD *pdwFontFlags); // see FONTFLAGS enum

        // Draws a glyph in the given DC & RECT using the provided colors
        HRESULT     DrawGlyphWithColors(
            [in] HDC hdc, 
            [in] RECT *pRect, 
            [in] long iMarkerType, 
            [in] IVsTextMarkerColorSet *pMarkerColors,
            [in] DWORD dwGlyphDrawFlags, // ORing of GLYPHDRAWFLAGS
            [in] long iLineHeight); // reserved for future use; pass zero if calling

        // Behavior flags.  For now, only streaming and line-spanning are supported.
        HRESULT     GetBehaviorFlags([out] DWORD *pdwFlags);

        // Priority index.  Highest value gets topmost placement.
        HRESULT     GetPriorityIndex ([out] long *piPriorityIndex);
    };

    /////////////////////////////////////////////////////////////////////////
    // IVsTextMarkerTypeProvider interface
    //
    // When a package registers an external marker type, this interface is
    // implemented once by the specified service.
    //
    /////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsTextMarkerTypeProvider)
    ]
    interface IVsTextMarkerTypeProvider : IUnknown
    {
        HRESULT GetTextMarkerType([in] GUID *pguidMarker, [out] IVsPackageDefinedTextMarkerType **ppMarkerType);
    };


    /////////////////////////////////////////////////////////////////////////////////
    // IVsTextMarkerClient interface
    //
    // Receives callbacks from a marker.
    /////////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsTextMarkerClient)
    ]
    interface IVsTextMarkerClient : IUnknown
    {
        // MarkerInvalidated is called when the text of a marker is deleted via a user action, but
        // not when the buffer is closed; OnBeforeBufferClose is called in that case.
#ifdef PROXYSTUB_BUILD
        HRESULT MarkerInvalidated(void);
#else
        void    MarkerInvalidated(void);
#endif

        HRESULT GetTipText([in] IVsTextMarker* pMarker, [out, optional] BSTR *pbstrText);
        
        //pszFileName is so you know if the buffer has been saved to a different
        //name, in certain types of buffers, this may not be applicable, in which
        //case the parameter may be NULL
#ifdef PROXYSTUB_BUILD
        HRESULT OnBufferSave(LPCOLESTR pszFileName);
#else
        void    OnBufferSave(LPCOLESTR pszFileName);
#endif

        // called before the buffer goes away due to its being closed; clients may still grab
        // span information from the marker in response to this
#ifdef PROXYSTUB_BUILD
        HRESULT OnBeforeBufferClose(void);
#else
        void    OnBeforeBufferClose(void);
#endif

        // Commands -- see MarkerCommandValues for meaning of iItem param
        HRESULT GetMarkerCommandInfo([in] IVsTextMarker* pMarker, [in] long iItem, [out, custom(uuid_IVsTextMarkerClient, "optional")] BSTR * pbstrText, [out] DWORD* pcmdf);
        HRESULT ExecMarkerCommand([in] IVsTextMarker* pMarker, [in] long iItem);

        // OnAfterSpanReload is called when someone calls IVsTextLines::ReloadLines or IVsTextStream::ReloadStream.
        // This means that the text under the marker has been altered, but it's been requested that the marker not
        // be deleted.  Thus the marker's position may not be appropriate.  This is your chance to correct it if
        // needed.
#ifdef PROXYSTUB_BUILD
        HRESULT OnAfterSpanReload(void);
#else
        void    OnAfterSpanReload(void);
#endif

        HRESULT OnAfterMarkerChange([in] IVsTextMarker* pMarker);
    }


    ////////////////////////////////////////////////////////////////////////////
    // IVsMouseCursorProvider interface
    ////////////////////////////////////////////////////////////////////////////

    /*
        If a marker has MV_GLYPH_HOVER_CURSOR turned on for its visual style bits, the 
        IVsTextMarkerClient * that is the marker client will be QI'd for this interface.
        This allows a marker to alter the mouse cursor when it's over its glyph.  This
        flag is ignored for markers that don't have MV_GLYPH specified.
    */
    [
        uuid(uuid_IVsMouseCursorProvider)
    ]
    interface IVsMouseCursorProvider : IUnknown
    {
	    HRESULT SetMouseCursor([in] DWORD dwReserved); // implementor should call SetCursor()
	}


    ////////////////////////////////////////////////////////////////////////////
    // CUSTOM_DROP_HANDLER_FLAGS enum
    ////////////////////////////////////////////////////////////////////////////

    // CUSTOM_DROP_HANDLER_FLAGS are used by IVsTextMarkerGlyphDropHandler
	typedef enum _CUSTOM_DROP_HANDLER_FLAGS
	{
		CDH_DEFAULT      = 0,   // success -- means that a drop can proceed, or already did so successfully
		CDH_OVER_SELF    = 1,   // means that the drop would be over the origin, thus a no-op
		CDH_INVALID_DEST = 2    // means the destination is unacceptable for a drop
	} CUSTOM_DROP_HANDLER_FLAGS;
    

    ////////////////////////////////////////////////////////////////////////////
    // IVsTextMarkerGlyphDropHandler interface
    ////////////////////////////////////////////////////////////////////////////

    /*
        When MV_DRAGGABLE_GLYPH is specified, the marker client will be QI'd for this interface when
        a drag/drop is underway.
    */
    [
        uuid(uuid_IVsTextMarkerGlyphDropHandler)
    ]
    interface IVsTextMarkerGlyphDropHandler : IUnknown
    {
        // DrawCandidateOutlineGlyph draws a "shadow" of the glyph in the widget margin at a potential destination line.
        // Draw the same glyph without regard for whether the destination is valid or not; that feedback will be given
        // by the mouse cursor.
        HRESULT DrawCandidateOutlineGlyph([in] DWORD dwReserved, [in] HDC hdc, [in] RECT *pRect, [in] COLORREF clrref);

        // QueryDropLocation is a way of asking whether a given location is a valid drop destination.
        HRESULT QueryDropLocation(
            [in] DWORD dwReserved,              // ignore
            [in] IVsTextView *pDestView,        // proposed destination view
            [in] IVsTextLines *pDestBuffer,     // proposed destination buffer
            [in] long iLine,                    // proposed buffer line
            [in] CharIndex iIndex,              // proposed buffer char index
            [out] DWORD *pdwDropResult);        // ORing of CUSTOM_DROP_HANDLER_FLAGS

        // DropAtLocation tells the client to handle the glyph being dropped at the given location.
        HRESULT DropAtLocation(
            [in] DWORD dwReserved,              // ignore
            [in] IVsTextView *pDestView,        // destination view
            [in] IVsTextLines *pDestBuffer,     // destination buffer
            [in] long iLine,                    // buffer line
            [in] CharIndex iIndex,              // buffer char index
            [out] DWORD *pdwDropResult);        // ORing of CUSTOM_DROP_HANDLER_FLAGS
	}


    /*/////////////////////////////////////////////////////////////////////////
        IVsTextTrackingPoint interface

        The best way to explain this interface is to explain the problem that
        it solves.  When tracking certain positions, such as the current
        selection, one needs to track a location in layer-generated text (e.g.
        that produced by the synthetic text layer), but still be able to track
        it even if that layer goes away.  The solution: a track point object,
        which is like a marker except that it is guaranteed to keep tracking -- 
        possibly in a different layer -- for as long as the buffer lives.

        Put another way, a multi-layer track point is similar to a zero-length
        marker, but it is guaranteed to always have a meaningful location in
        SOME layer, provided the buffer continues to exist.

        A track point it never shows any UI, and its position may not be reset.
        The only things you can do with them are create them and query their
        layer and current line/index.

        This interface is used only in special-purpose scenarios; unless you
        need to track a point which may exist in a synthetic text region, you
        don't need to worry about this interface.  Clients should use normally
        use ordinary text markers on the buffer.
    /////////////////////////////////////////////////////////////////////////*/

    [
        uuid(uuid_IVsTextTrackingPoint)
    ]
    interface IVsTextTrackingPoint : IUnknown
    {
        HRESULT GetTextLayer([out] IVsTextLayer **ppLayer);
        HRESULT GetCurrentLineIndex([out] long *piLine, [out] long *piIndex);
        HRESULT(GetBehavior)([out] DWORD *pdwBehavior);
        HRESULT(SetBehavior)([in] DWORD dwBehavior);	
    };

    /////////////////////////////////////////////////////////////////////////
    // IVsFullTextScanner interface
    //
    // This is a special-purpose interface exposed by text buffers that is
    // used by entities like compilers that need immediate access to the
	// entire buffer.  It differs from IVsTextScanner above in that it cannot
	// ever return a portion of the buffer; it will always return all or
	// nothing.  In addition, it differs from IVsTextScanner in that multiple
	// clients may have IVsFullTextScanner sessions in progress, whereas
	// IVsTextScanner cannot cope with this.
    /////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsFullTextScanner)
    ]
    interface IVsFullTextScanner : IUnknown
    {
        // Open the buffer for scanning.  This will lock the buffer and do a
        // garbage collection pass (read: EXPENSIVE!!), so don't use this in
        // a QueryStatus handler or other speed-intensive scenario.
        HRESULT     OpenFullTextScan (void);

        // Does the actual scan.
        //
        // piLength is filled with the length of text pointed to by *ppszText.
        //
#ifdef PROXYSTUB_BUILD
        // out parameter can not be const.
        HRESULT     FullTextRead ([out] WCHAR **ppszText, [out] long *piLength);
#else
        HRESULT     FullTextRead ([out] const WCHAR **ppszText, [out] long *piLength);
#endif

        // Close the buffer for scanning.  Writable buffer implementations
        // use this to re-allow writing to the buffer, so don't forget to
        // call this guy!
        HRESULT     CloseFullTextScan (void);
    };


    /////////////////////////////////////////////////////////////////////////
    // IVsTextScanner interface
    //
    // This is a special-purpose interface exposed by text buffers that is
    // used by entities like compilers that need fast, stream-oriented,
    // sequential access to the text in the buffer.
	//
	// Right now, this interface is just as slow as IVsFullTextScanner, but
	// prevents multiple clients from using it.  In the future, this might
	// change so as to only send back a line at a time.  If you normally
	// only want a full buffer back, please use IVsFullTextScanner instead.
    /////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsTextScanner)
    ]
    interface IVsTextScanner : IUnknown
    {
        // "Open" the buffer for scanning.  Scan functions are successful
        // only after calling this and before calling Close, and only for
        // the calling thread.
        HRESULT     OpenScan (void);

        // Scan text.  The block provided is guaranteed valid until the next
        // call to Read, or Close().  piLength is filled with the length of text
        // pointed to by *ppszText -- if 0, there is no more text.  In the
        // most efficient of implementations, the entire buffer will be
        // provided by one call to Read.
#ifdef PROXYSTUB_BUILD
        // out parameter can not be const
        HRESULT     Read ([out] WCHAR **ppszText, [out] long *piLength);
#else
        HRESULT     Read ([out] const WCHAR **ppszText, [out] long *piLength);
#endif

        // Close the buffer for scanning.  Writable buffer implementations
        // use this to re-allow writing to the buffer, so don't forget to
        // call this guy!
        HRESULT     CloseScan (void);
    };

    /////////////////////////////////////////////////////////////////////////
    // Definition of text find / replace flags shared by both the buffer
    // and view.
    /////////////////////////////////////////////////////////////////////////
    typedef enum _TextFindMode
    {
        TFIND_BACKWARDS     = 1,
        TFIND_MATCH_CASE    = 2,
        TFIND_WHOLE_WORD    = 4,
        TFIND_REG_EXPR      = 8,
        TFIND_WRAP_SEARCH   = 16,
        TFIND_IN_SELECTION  = 32,
        TFIND_NEW_SEARCH    = 64
    } TextFindMode;

    /////////////////////////////////////////////////////////////////////////
    // IVsTextFind interface
    // 
    // Find a given hunk of text in the buffer
    /////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsTextFind)
    ]
    interface IVsTextFind : IUnknown
    {
        HRESULT     Find (
			[in] const WCHAR *pszText, 
			[in] long iStartLine,	// starting line
			[in] CharIndex iStartIndex,	// starting character index within the line (must be <= length of line)
			[in] long iEndLine,		// ending line
			[in] CharIndex iEndIndex,	// ending character index within the line (must be <= length of line)
			[in] long iFlags, [out] long *piLine, [out] long *piCol);
    };

    /////////////////////////////////////////////////////////////////////////
    // IVsTextBufferEvents interface
    //
    // Events fired by text buffers
    /////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsTextBufferEvents)
    ]
    interface IVsTextBufferEvents : IUnknown
    {
        // New language service has been associated with this buffer
#ifdef PROXYSTUB_BUILD
        HRESULT     OnNewLanguageService ([in] REFGUID sidLangServiceID);
#else
        void        OnNewLanguageService ([in] REFGUID sidLangServiceID);
#endif
    };

    /////////////////////////////////////////////////////////////////////////
    // IVsTextBufferDataEvents interface
    /////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsTextBufferDataEvents)
    ]
    interface IVsTextBufferDataEvents : IUnknown
    {
        // This event forwards the IVsFileChangeEvents::FilesChanged notification that the TextBuffer monitors to other
        // interested parties. Non-TextEditorView (e.g. a Form view) will want to hook up to this event to manage whether
        // "[ReadOnly]" should be included in the document window caption (VSFPROPID_EditorCaption).
        // Note: dwFileAttrs is only valid if VSFILECHG_Attr is set in which case it returns the result of WinAPI GetFileAttributes().
        // This is useful to check for (dwFileAttrs & FILE_ATTRIBUTE_READONLY) to know if the file's ReadOnly status changes.
#ifdef PROXYSTUB_BUILD
        HRESULT     OnFileChanged([in] DWORD grfChange, [in] DWORD dwFileAttrs);
#else
        void        OnFileChanged([in] DWORD grfChange, [in] DWORD dwFileAttrs);
#endif
        // This event is fired after the buffer is first initialized with data either by a call to IVsPersistDocData::LoadDocData, 
        // IPersistStream::Load, IVsTextBuffer::InitializeContent, IPersistFile::Load/InitNew. This event is also fired if the 
        // buffer executes a reload of its file in response to a OnFileChanged event (i.e. file edited outside of the Environment).
		// In the non-reload case, if ANY of the event sinks return an error HRESULT from OnLoadCompleted, this will cause the
		// corresponding Load[DocData] call to return with that same error HRESULT.  In the reload scenario, the return value will
		// be ignored.
        HRESULT		OnLoadCompleted([in] BOOL fReload);
    };

    /////////////////////////////////////////////////////////////////////////
    // IVsTextStreamEvents interface
    //
    // Events fired by stream-oriented text buffers
    /////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsTextStreamEvents)
    ]
    interface IVsTextStreamEvents : IUnknown
    {
#ifdef PROXYSTUB_BUILD
        HRESULT     OnChangeStreamText ([in] long iPos,
                                        [in] long iOldLen,
                                        [in] long iNewLen,
                                        [in] BOOL fLast);

        HRESULT     OnChangeStreamAttributes ([in] long iPos,
                                              [in] long iLength);
#else
        void        OnChangeStreamText ([in] long iPos,
                                        [in] long iOldLen,
                                        [in] long iNewLen,
                                        [in] BOOL fLast);

        void        OnChangeStreamAttributes ([in] long iPos,
                                              [in] long iLength);
#endif
    }

    typedef enum _splitnotifycode
    {
        SNC_BEGINSIZE,
        SNC_ENDSIZE,
        SNC_ANCESTORDETACHED,
        SNC_ANCESTORATTACHED,
        SNC_LBUTTONDBLCLK,		// splitter was double clicked
    } SPLITNOTIFYCODE;

    typedef enum _splitflags
    {
        SF_HORIZONTAL = 0x0000,         // (default)
        SF_VERTICAL   = 0x0001,

        SF_MAKESECONDARY = 0x0000,      // (default)
        SF_MAKEPRIMARY   = 0x0002,

        SF_ADJUSTABLE = 0x0000,         // (default)
        SF_FIXED      = 0x0004
    } SPLITFLAGS;

    typedef enum _paneflags
    {
        PF_SUNKEN     = 0x0000,         // Default border style
        PF_RAISED     = 0x0001,
        PF_ETCHED     = 0x0002,
        PF_BUMP       = 0x0003,
		PF_SHALLOW    = 0x0004,
        PF_BORDERMASK = 0x0007,
        PF_BORDER     = 0x0008,           // Border types are ignored unless this is set
        PF_ELASTICX   = 0x0010,           // Pane "prefers" elasticity when sized horizontally
        PF_ELASTICY   = 0x0020,           // Pane "prefers" elasticity when sized vertically

        /*
            There is a slight misnomer with PF_NOFOCUS.  If a pane specifies PF_NOFOCUS it can still
            get the focus via the mouse, but it will never participate in F6-style pane hopping.
        */
        PF_NOFOCUS    = 0x0040
    } PANEFLAGS;

    typedef enum _paneevents
    {
        PE_GOTFOCUS = 1,
        PE_CLOSED,
        PE_FLAGSCHANGED,
        PE_DETACHED,
        PE_FOCUS_TO_EDIT_PANE  // puts focus on an edit pane
    } PANEEVENTS;


    ////////////////////////////////////////////////////////////////////////////
    // IVsSplitPane interface
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsSplitPane)
    ]
    interface IVsSplitPane : IUnknown
    {
        // Set/Get the parent splitter for this pane
        HRESULT     SetParentSplitter ([in] IVsSplitter *pSplitter);
        HRESULT     GetParentSplitter ([out] IVsSplitter **ppSplitter);

        // Set focus on this pane
        HRESULT     SetFocus (void);

        // Set/Get position relative to parent HWND client area
        HRESULT     SetPosition ([in] long iLeft, [in] long iTop, [in] long iRight, [in] long iBottom);
        HRESULT     GetPosition ([out] long *piLeft, [out] long *piTop, [out] long *piRight, [out] long *piBottom);

        // Get mins and maxes for this pane (E_NOTIMPL is allowed; 0 and full screen are defaults)
        HRESULT     GetSizeExtents ([out] long *piMinHorz, [out] long *piMaxHorz, [out] long *piMinVert, [out] long *piMaxVert);

        // Get the parent window of this pane.  All panes have the same parent window,
        // which is the parent of all child windows created by leaf-node panes
        HRESULT     GetParentWindow ([out] HWND *phwndParent);

        // Pane flags
        HRESULT     GetPaneFlags ([out] DWORD *pdwPaneFlags);

        // Close this pane
        HRESULT     ClosePane (void);

        // Notification of splitter adjustment
        HRESULT     NotifyPane ([in] SPLITNOTIFYCODE iCode);

        // Detach this pane from its parent splitter, without closing
        HRESULT     DetachPane (void);
    };

    ////////////////////////////////////////////////////////////////////////////
    // IVsSplitter interface
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsSplitter)
    ]
    interface IVsSplitter : IVsSplitPane
    {
        // Get the indicated pane (index can be 0 (primary), or 1 (secondary))
        HRESULT     GetPane ([in] long iIndex, [out] IVsSplitPane **ppPane);

        // Called by child panes when they get focus, close, other events
        HRESULT     NotifySplitter ([in] IVsSplitPane *pPane, [in] PANEEVENTS iEvent);

        // S_OK indicates given pane is primary; S_FALSE means secondary
        HRESULT     IsPanePrimary ([in] IVsSplitPane *pPane);

        // Handle mouse-oriented message
        HRESULT     HandleMessage ([in] UINT iMsg, [in] WPARAM wParam, [in] LPARAM lParam);

        // Split the indicated pane of this splitter.  The provided pane can
        // become either the primary or secondary pane of the newly created
        // splitter pane, which replaces the indicated pane.  iSize refers to
        // the size of the new pane, regardless of if it is becoming the primary
        // or secondary pane.
        HRESULT     SplitPane ([in] IVsSplitPane *pNewPane, [in] long iIndex, [in] long iSize, [in] DWORD dwFlags, [out] IVsSplitter **ppSplitter);
    };

    typedef enum _panetype
    {
        GP_FOCUS  =  1,
        GP_NEXT,
        GP_PREV
    } PANETYPE;

    ////////////////////////////////////////////////////////////////////////////
    // IVsSplitRoot interface
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsSplitRoot)
    ]
    interface IVsSplitRoot : IUnknown
    {
        HRESULT     GetRootSplitter ([out] IVsSplitter **ppPane);
        HRESULT     GetWindowHandle ([out] HWND *phwnd);
        HRESULT     GetPane([in] PANETYPE paneType, [out] IVsSplitPane **ppPane);
    };

	// Parameter to IVsCodeWindow::GetEditorCaption
    typedef enum _READONLYSTATUS 
    {
        ROSTATUS_NotReadOnly 	=  0,
        ROSTATUS_ReadOnly		=  1,
        ROSTATUS_Unknown		= -1,	// determine status by checking with the associated TextBuffer
    } READONLYSTATUS;


    ////////////////////////////////////////////////////////////////////////////
    // IVsCodeWindow interface
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsCodeWindow)
    ]
    interface IVsCodeWindow : IUnknown
    {
        HRESULT     SetBuffer ([in] IVsTextLines *pBuffer);
        HRESULT     GetBuffer ([out] IVsTextLines **ppBuffer);
        HRESULT     GetPrimaryView ([out] IVsTextView **ppView);
        HRESULT     GetSecondaryView ([out] IVsTextView **ppView);

        // The code window by default uses CLSID_VsTextView for the edit panes.
        // Use these methods to query/change the text view class to use.
        HRESULT     SetViewClassID ([in] REFCLSID clsidView);
        HRESULT     GetViewClassID ([out] CLSID *pclsidView);

		// Used by editors to append custom text to the editor caption.

        // NOTE: the LPCOLESTR * in this method is basically a design flaw, but use it for now.
        //       There's too much code relying on the current behavior.
        HRESULT     SetBaseEditorCaption([in] LPCOLESTR *pszBaseEditorCaption);
        HRESULT     GetEditorCaption([in] READONLYSTATUS dwReadOnly, [out] BSTR *pbstrEditorCaption);

        // UNDONE:  Remove when IWindowPane gets a Close() method
        HRESULT     Close (void);

		HRESULT     GetLastActiveView ([out] IVsTextView **ppView);
    };

    ////////////////////////////////////////////////////////////////////////////
    // IVsCodeWindowManager interface
    //
    // NOTE:  To get the code window manager attached to an instance of
    // IVsCodeWindow, QS it for SID_SVsCodeWindowManager and the interface you want
    // on it.  It is inappropriate for any external entity (other than the
    // code window itself) to call IVsCodeWindowManager methods, but private
    // interfaces may be exposed on the code window manager that may be useful
    // to other parties.
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsCodeWindowManager)
    ]
    interface IVsCodeWindowManager : IUnknown
    {
        // Called by a code window to provide opportunity to add adornments
        // (additional split panes) to the code window, etc.

        /*
            Note: this is a convenient place for the following operations:
            - Adding a dropdown bar (IVsDropdownBar).
            - Adding attributes/context to the current user context (in some situations).
            - Updating an editor caption by calling IVsCodeWindow::SetBaseEditorCaption/GetEditorCaption,
              then using IVsFindTarget to get the window frame & then using the window frame to set the
              actual window frame's editor caption.
        */
        HRESULT     AddAdornments (void);

        // The language has changed, or the code window is going away; this
        // code win mgr needs to now remove its adornments
        HRESULT     RemoveAdornments (void);

        // A new text view has been created in the code window; now's your
        // chance to provide a filter for it.
        HRESULT     OnNewView ([in] IVsTextView *pView);
    };


    // DROPDOWNFONTATTR is an enum used by IVsDropdownBarClient to describe the appearance of text entries.
    enum DROPDOWNFONTATTR 
    { 
        FONTATTR_PLAIN     = 0,  // plain text
        FONTATTR_BOLD       = 1, // bold text
        FONTATTR_ITALIC     = 2, // italicized text
        FONTATTR_UNDERLINE  = 4,  // underlined text
		FONTATTR_GRAY		= 8	 // grayed out text
    };

    // DROPDOWNENTRYTYPE is used by IVsDropdownBarClient to pick the drawing protocol requested for a combo.
    enum DROPDOWNENTRYTYPE
    { 
        ENTRY_TEXT   = 1, // plain text only (IVsDropdownBarClient::GetText will be called)
        ENTRY_ATTR   = 2, // text that may have bold/italic/underline attributes (IVsDropdownBarClient::GetAttributes will be called)
        ENTRY_IMAGE  = 4  // a glyph is drawn to the left of the entries (IVsDropdownBarClient::GetImage will be called)
    };

    ////////////////////////////////////////////////////////////////////////////
    // IVsDropdownBarClient interface
    //
    // NOTE: the HANDLE * from GetComboAttributes obviously cannot be marshalled across machines.
    //
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsDropdownBarClient)
    ]
    interface IVsDropdownBarClient : IUnknown
    {
        /*
            SetDropdownBar is called by the dropdownbar to hook itself up to the client.  The reason
            this callback is necessary rather than relying on a return value from
            IVsDropdownBarManager::AddDropdownBar is that client callbacks are required as a result
            of attaching the combo bar, before IVsDropdownBarManager::AddDropdownBar even returns!
            SetDropdownBar should be called exactly once.
        */
        HRESULT SetDropdownBar([in] IVsDropdownBar *pDropdownBar);

        // called whenever info about a combo is needed; any of the out parameters are allowed to be passed in as NULL ptrs if not needed
        HRESULT GetComboAttributes(
            [in] long iCombo,
            [out] ULONG *pcEntries,
            [out] ULONG *puEntryType,  // ORing of DROPDOWNENTRYTYPE enum
            [out] HANDLE *phImageList  // actually an HIMAGELIST
            );

        // called for ENTRY_TEXT
        HRESULT GetEntryText([in] long iCombo, [in] long iIndex, [out] WCHAR **ppszText);

        // called for ENTRY_ATTR
        HRESULT GetEntryAttributes([in] long iCombo, [in] long iIndex, [out] ULONG *pAttr); // ORing of DROPDOWNFONTATTR enum values

        /*
            GetImage will only be called if you specified ENTRY_IMAGE for the entry attributes of the given combo.
            There are two expected return codes from GetImage:
                S_OK:       Draw the glyph indicated in *piImageIndex. Use this for entries that should have a glyph.
                S_FALSE:    Set aside space for a glyph, but don't draw anything. Use this for entries that don't have
                            a glyph but might have sibling entries in the same combo with glyphs.
                Other:      Some terrible failure occured.

            It is presently assumed that your image lists will all be of the same height.
        */
        HRESULT GetEntryImage([in] long iCombo, [in] long iIndex, [out] long *piImageIndex);

        HRESULT OnItemSelected([in] long iCombo, [in] long iIndex);
        HRESULT OnItemChosen([in] long iCombo, [in] long iIndex);
        HRESULT OnComboGetFocus([in] long iCombo);

        // GetComboTipText returns a tooltip for an entire combo
        HRESULT GetComboTipText([in] long iCombo, [out] BSTR *pbstrText);
    };

    ////////////////////////////////////////////////////////////////////////////
    // IVsDropdownBar interface
    //
    // Used to provide dropdowns at the top of a code window like in VB.  To get
    // one of these, use IVsDropdownBarManager.
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsDropdownBar)
    ]
    interface IVsDropdownBar : IUnknown
    {
        /*
            Attach is called by IVsDropdownBarManager::AddDropdownBar.  This function
            creates the window and dropdown combos and sets up a link between the dropdown
            bar and its client.  Do not call this function unless you're bypassing
            IVsDropdownBarManager.
        */
        HRESULT Attach(
            [in] HWND hwndParent, 
            [in] long cCombos, 
            [in] IVsDropdownBarClient *pClient);
            
        /*
            Detach is called by IVsDropdownBarManager::RemoveDropdownBar.  This function
            breaks the link between the dropdown bar and its client.  Do not call this
            function unless you're bypassing IVsDropdownBarManager and in the process of
            removing the dropdown bar from the window.
        */
#ifdef PROXYSTUB_BUILD
        HRESULT Detach(void);
#else
        void Detach(void);
#endif

        // GetCurrentSelection tells you what entry is currently selected in a given
        // combo.  Note that mouse moves change the highlight but not the selection.
        HRESULT GetCurrentSelection([in] long iCombo, [out] long *piCurSel);

        // RefreshCombo is used to force a repaint of a combo, specifying the new selection.
        HRESULT RefreshCombo([in] long iCombo, [in] long iNewSelection);

        // GetClient sends back the client associated with this dropdown bar.
        HRESULT GetClient([out] IVsDropdownBarClient **ppClient);

		// Sets the current selection in the given combo
        HRESULT SetCurrentSelection([in] long iCombo, [in] long iNewSelection);

    };

    ////////////////////////////////////////////////////////////////////////////
    // IVsDropdownBarManager interface
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsDropdownBarManager)
    ]
    interface IVsDropdownBarManager : IUnknown
    {
        // AddDropdownBar lets you add a set of combo dropdowns to a code window.  This call
        // wraps the call to IVsDropdownBar::Attach.  If there is already a dropdown bar
        // attached to the code window it returns E_UNEXPECTED.  In general you should call
        // GetDropdownBar first before calling AddDropdownBar to make sure there isn't already
        // a dropdown bar associated with the given code window.
        HRESULT AddDropdownBar([in] long cCombos, 
            [in] IVsDropdownBarClient *pClient);

        // GetDropdownBar sends back the dropdown bar associated with the code window, if
        // if any.  If there is one, it returns S_OK and sends back an AddRef'd ptr to it.
        // If there isn't one, it returns S_FALSE and nulls out the out param.
        HRESULT GetDropdownBar([out] IVsDropdownBar **ppDropdownBar);

        // RemoveDropdownBar removes a dropdown bar from a code window.
        HRESULT RemoveDropdownBar(void);
    };   

    ////////////////////////////////////////////////////////////////////////////
    // IVsButtonBarClient interface
    //
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsButtonBarClient)
    ]
    interface IVsButtonBarClient : IUnknown
    {
        /*
            SetButtonBar is called by the Buttonbar to hook itself up to the client.  The reason
            this callback is necessary rather than relying on a return value from
            IVsButtonBarManager::AddButtonBar is that client callbacks are required as a result
            of attaching the combo bar, before IVsButtonBarManager::AddButtonBar even returns!
            SetButtonBar should be called exactly once.
        */
        HRESULT SetButtonBar([in] IVsButtonBar *pButtonBar);

        // GetButtonTipText sends back text for a tooltip over the button
        HRESULT GetButtonTipText([in] long iButton, [out] BSTR *pbstrTip);

        // OnButtonPressed is fired whenever a new button is pressed.
        HRESULT OnButtonPressed([in] long iButton);
    };

    /////////////////////////////////////////////////////////////////////////////////////////////////////
    // IVsButtonBar interface
    //
    // Used to provide buttons at the bottom of a code window like in VB for fn-at-a-time view toggling.
    //////////////////////////////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsButtonBar)
    ]
    interface IVsButtonBar : IUnknown
    {
        /*
            Attach is called by IVsButtonBarManager::AddButtonBar.  This function
            creates the window and Button combos and sets up a link between the Button
            bar and its client.  Do not call this function unless you're bypassing
            IVsButtonBarManager.  Each bmp in the image list MUST be 16x16.
        */
        HRESULT Attach(
            [in] HWND hwndParent, 
            [in] long cButtons,
            [in] HANDLE hImageList,
            [in] IVsButtonBarClient *pClient);

        /*
            Detach is called by IVsButtonBarManager::RemoveButtonBar.  This function
            breaks the link between the button bar and its client, dropping the reference
            that the button bar has on the client.
        */
#ifdef PROXYSTUB_BUILD
        HRESULT Detach(void);
#else
        void Detach(void);
#endif

        HRESULT SetHeight([in] long iHeight); // this is called by the parent; clients need not call this unless writing another owner for it
        HRESULT GetSize([out] long *piWidth, long *piHeight); // the width is a fn of height

        // SetCurrentSelection specifies which button is selected
        HRESULT SetCurrentSelection([in] long iCurButton);
        // GetCurrentSelection tells you what button is currently pressed.
        HRESULT GetCurrentSelection([out] long *piCurButton);

        // GetClient sends back the client associated with this Button bar.
        HRESULT GetClient([out] IVsButtonBarClient **ppClient);
    };


    ////////////////////////////////////////////////////////////////////////////
    // IVsButtonBarManager interface
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsButtonBarManager)
    ]
    interface IVsButtonBarManager : IUnknown
    {
        // AddButtonBar lets you add a set of combo Buttons to a code window.  This call
        // wraps the call to IVsButtonBar::Attach.  If there is already a Button bar
        // attached to the code window it returns E_UNEXPECTED.  In general you should call
        // GetButtonBar first before calling AddButtonBar to make sure there isn't already
        // a button bar associated with the given code window.
        HRESULT AddButtonBar(
            [in] long cButtons,
            [in] HANDLE hImageList, // actually an HIMAGELIST
            [in] IVsButtonBarClient *pClient);

        // GetButtonBar sends back the Button bar associated with the code window, if
        // if any.  If there is one, it returns S_OK and sends back an AddRef'd ptr to it.
        // If there isn't one, it returns S_FALSE and nulls out the out param.
        HRESULT GetButtonBar([out] IVsButtonBar **ppButtonBar);

        // RemoveButtonBar removes a Button bar from a code window.
        HRESULT RemoveButtonBar(void);
    };   


    ////////////////////////////////////////////////////////////////////////////
    // IVsDefaultButtonBarImages interface
    //
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsDefaultButtonBarImages)
    ]
    interface IVsDefaultButtonBarImages : IUnknown
    {
        HRESULT GetButtonCount([out] long *pcButtons);

        /*
            Do not attempt to free this image list that you get back; the implementor of this interface will do that.
        */
        HRESULT GetImageList([out] HANDLE *phImageList);
    }


    typedef enum
    {
        MOVESELECTION_REL_CHARACTER = 1,
        MOVESELECTION_REL_WORD,
        MOVESELECTION_REL_LINE,
        MOVESELECTION_REL_PAGE
    } MOVESELECTION_REL_TYPE;

    typedef enum
    {
        MOVESELECTION_ABS_FIRSTCOLUMN = 1,
        MOVESELECTION_ABS_FIRSTTEXTCOLUMN,
        MOVESELECTION_ABS_LASTCOLUMN,
        MOVESELECTION_ABS_FIRSTLINE,
        MOVESELECTION_ABS_LASTLINE
    } MOVESELECTION_ABS_TYPE;

    typedef enum
    {
        CASESELECTION_UPPER = 1,
        CASESELECTION_LOWER,
        CASESELECTION_TITLE
    } CASESELECTION_TYPE;

    ////////////////////////////////////////////////////////////////////////////
    // IVsTextMacroHelper interface
    //
    // Used to emit macro recording code.  An action performed in the editor
    // should be captured by recording automation code that can later be
    // replayed by the user to repeat the action.
    ////////////////////////////////////////////////////////////////////////////

    [
        uuid(uuid_IVsTextMacroHelper)
    ]
    interface IVsTextMacroHelper : IUnknown
    {
        // Typing into file
        HRESULT RecordNewLine();
        HRESULT RecordTypeChar(OLECHAR wchChar, BOOL fIsOvertype);
        HRESULT RecordTypeChars(LPCOLESTR pwszChars, BOOL fIsOvertype);
        HRESULT RecordRemovePreviousTyping(LPCOLESTR pwszPrevChars);

        // Deleting
        HRESULT RecordDelete(BOOL fLeft, UINT uiReps);
        HRESULT RecordDeleteSpace(BOOL fVertical);

        // Selection changes
        HRESULT RecordMoveSelectionRel(MOVESELECTION_REL_TYPE mst, BOOL fBackwards, BOOL fExtend);
        HRESULT RecordMoveSelectionAbs(MOVESELECTION_ABS_TYPE mst, BOOL fExtend);
        HRESULT RecordCollapseSelection();
        HRESULT RecordSelectAll();
        HRESULT RecordSwapAnchor();
        HRESULT RecordEnterBoxMode();
        HRESULT RecordActivateDocument();
        HRESULT RecordGotoLine(long iLine, BOOL fExtend);

        // Clipboard
        HRESULT RecordCut();
        HRESULT RecordCopy();
        HRESULT RecordPaste();

        // Bookmarks
        HRESULT RecordBookmarkClearAll();
        HRESULT RecordBookmarkSetClear(BOOL fSet);
        HRESULT RecordBookmarkNextPrev(BOOL fNext);

        // Formatting
        HRESULT RecordChangeCase(CASESELECTION_TYPE cst);
        HRESULT RecordIndentUnindent(BOOL fIndent);
        HRESULT RecordFormatSelection();
        HRESULT RecordTabifyUntabify(BOOL fTabify);

		// Misc. file manipulation
		HRESULT RecordInsertFile(LPCOLESTR pwszName);
    };

    ////////////////////////////////////////////////////////////////////////////
    // IVsUserData interface
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsUserData)
    ]
    interface IVsUserData : IUnknown
    {
        HRESULT     GetData ([in] REFGUID riidKey, [out] VARIANT *pvtData);
        HRESULT     SetData ([in] REFGUID riidKey, [in] VARIANT vtData);
    };

    ////////////////////////////////////////////////////////////////////////////
    // IVsUserDataEvents interface
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsUserDataEvents)
    ]
    interface IVsUserDataEvents : IUnknown
    {
#ifdef PROXYSTUB_BUILD
        HRESULT     OnUserDataChange ([in] REFGUID riidKey, [in] VARIANT vtNewValue);
#else
        void        OnUserDataChange ([in] REFGUID riidKey, [in] VARIANT vtNewValue);
#endif
    };

    ////////////////////////////////////////////////////////////////////////////
    // IVsUndoUnit interface
    //
    // Interface an IOleUndoUnit exposes if it wants to be able to put UI-only
    // undo items (like text selection and/or caret movements) on the undo stack
    // which will NOT blow away the redo stack. The VS implementation of
    // IOleUndoManager looks for this interface and if found calls fChangeData()
    // to determine whether this is a UI-only undo unit (fChangeData returns FALSE).
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsUndoUnit)
    ]
    interface IVsUndoUnit : IUnknown
    {
        // does this undo unit change data? - if so, undo mgr blows redo stack
#ifdef PROXYSTUB_BUILD
        // NOTE: Check if this change is safe on 64bits platforms.
        HRESULT fChangeData(void);     
#else
        BOOL fChangeData(void);     
#endif
    };

    ////////////////////////////////////////////////////////////////////////////
    // IVsUndoTrackingEvents interface
    //
    // Interface an IOleUndoManager client can expose to be told by the undo
	// manager the undo stack has returned to an unmodified state (i.e. no
	// data-changing mods exist).  This is how the "remove modified star after
	// undo" feature works.
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsUndoTrackingEvents)
    ]
    interface IVsUndoTrackingEvents : IUnknown
    {
        // tells the client that we've returned to a clean state
#ifdef PROXYSTUB_BUILD
        HRESULT OnReturnToCleanState(void);
#else
        void    OnReturnToCleanState(void);
#endif
    };

    ////////////////////////////////////////////////////////////////////////////
    // IVsChangeTrackingUndoManager interface
    //
    // Interface an IOleUndoManager implementation can expose to help clients
	// know when the undo stack has returned to an unmodified state (i.e. no
	// data-changing mods exist).  This is how the "remove modified star after
	// undo" feature works.
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsChangeTrackingUndoManager)
    ]
    interface IVsChangeTrackingUndoManager : IUnknown
    {
        // tell the undo manager that we're at an unmodified point (e.g. called after a save operation)
        HRESULT MarkCleanState(void);

		// find out whether we're at an umodified state (no particular need, but seems like it would be useful)
		HRESULT QueryCleanState([out] BOOL *pfClean);

		/*
			These calls manage an event interface to be told when we return to unmodified state.

			IMPORTANT: These interfaces *DO NOT* call AddRef/Release on pUndoTrackingEvents so as to avoid
			circular reference problems.  Therefore you should be sure to call UnadviseTrackingClient()
			before you release your reference to the undo manager, or the undo manager will assert.
		*/
		HRESULT AdviseTrackingClient([in] IVsUndoTrackingEvents *pUndoTrackingEvents);
		HRESULT UnadviseTrackingClient(void);
    };


    [
        uuid(uuid_IVsLinkedUndoClient)
    ]
    interface IVsLinkedUndoClient : IUnknown
    {
        /*
            When this method is called, it means that your undo manager has a non-linked action on
            top of its undo or redo stack which is blocking another undo manager from executing its
            linked action.

            If possible, you should do the following in response to this call:
                1) Activate a window with a view on the corresponding data using the undo manager.
                2) Put up a message box with the provided localized error string or put up your own
                   custom UI.

            If you CAN do the above two so that the user knows what happened, return S_OK.  Otherwise,
            you must return E_FAIL, which will cause the undo to fail and break all transaction links
            to that document.
        */
        HRESULT OnInterveningUnitBlockingLinkedUndo(void);
    }

    [
        uuid(uuid_IVsLinkCapableUndoManager)
    ]
    interface IVsLinkCapableUndoManager : IUnknown
    {
		/*
			These calls manage an event interface to be told when we need to put focus on the owner of
            the given undo manager.

            Implicit linked undos will only work for undo managers where AdviseLinkedUndoClient has
            been called!

			IMPORTANT: These interfaces *DO NOT* call AddRef/Release on pClient so as to avoid
			circular reference problems.  Therefore you should be sure to call UnadviseLinkedUndoClient()
			before you release your reference to the undo manager, or the undo manager will assert.
		*/
		HRESULT AdviseLinkedUndoClient([in] IVsLinkedUndoClient *pClient);
		HRESULT UnadviseLinkedUndoClient(void);
    };

    [
        uuid(uuid_IVsLifetimeControlledObject)
    ]
    interface IVsLifetimeControlledObject : IUnknown
    {
        HRESULT SeverReferencesToOwner(void); // indicates that it should clear all stacks & be zombified
    };


    /*
        IVsLinkedUndoTransactionManager

        This is a service used to implement the linked undo stacks feature.  To get this, use
        QueryService(SID_SVsLinkedUndoManager, IID_IVsLinkedUndoTransactionManager).

        The contract here is the same as IVsCompoundAction.  The string passed into OpenLinkedUndo identifies
        the action in the UI if this is the outermost multi doc undo.  After calling OpenLinkedUndo you must
        later call CloseLinkedUndo or AbortLinkedUndo.

        Note that there is only one multi doc undo service; one session can, however, contain another.
    */

    typedef enum _LinkedTransactionFlags
    {
        mdtDefault                  = 0x0, // non-strict transaction
        mdtStrict                   = 0x1  // strict transaction
    } LinkedTransactionFlags;

    [
        uuid(uuid_IVsLinkedUndoTransactionManager)
    ]
    interface IVsLinkedUndoTransactionManager : IUnknown
    {
        HRESULT     OpenLinkedUndo(
            [in] DWORD dwFlags, // ORing of LinkedTransactionFlags enum values
            [in] const WCHAR *pszDescription); // Localized string that describes this action; appears in the undo/redo dropdowns.  May NOT be NULL!!

        HRESULT     CloseLinkedUndo(void); // successful completion

        /*
            WARNING: in vs7, AbortLinkedUndo does not roll back the most recently opened subtransaction.  Instead,
                     it marks the ENTIRE transaction for death when the outermost CloseLinkedUndo/AbortLinkedUndo
                     is called.
        */
        HRESULT     AbortLinkedUndo(void); // unsuccessful completion; rolls back all actions done since OpenLinkedUndo was called

        HRESULT     IsAborted(BOOL *pfAborted);
        HRESULT     IsStrict(BOOL *pfStrict);
        HRESULT     CountOpenTransactions(long *pCount);
    };

/*

    IVsLimitedLinkedUndoTransactionManager
    ========================================

    This interface is not planned to be implemented for vs7.  But when/if the need arises for non-global
    (or, more accurately, non-implicit) linked undo transactions, it can very easily be exposed via the
    following interface.  Since this is a natural complement to IVsLinkedUndoTransactionManager, this
    interface should stay here for future reference in case it needs to be used someday.

    [
        uuid(uuid_IVsLimitedLinkedUndoTransactionManager)
    ]
    interface IVsLimitedLinkedUndoTransactionManager : IUnknown
    {
        HRESULT CreateLimitedLinkedUndo(
            [in] DWORD dwFlags, // ORing of LinkedTransactionFlags enum values
            [in] const WCHAR *pszDescription, // Localized string that describes this action; appears in the undo/redo dropdowns.  May NOT be NULL!!
            [out] DWORD *pdwCookie); // DWORD describing transaction

        HRESULT AddToLimitedLinkedUndo(
            [in] DWORD dwCookie,
            [in] IOleUndoManager *pUndoMgr);

        HRESULT CloseLimitedLinkedUndo(
            [in] DWORD dwCookie);
    };
*/

    /*
        ChangeClusterFlags
        
        Flags used for IVsChangeClusterEvents.
    */
    typedef enum _ChangeClusterFlags
    {
        CCE_BEFORE_OPEN     = 0x0001, // indicates that the notification is being fired before a cluster has opened
        CCE_BEFORE_CLOSE    = 0x0002, // indicates that the notification is being fired before a cluster has closed
        CCE_AFTER_CLOSE     = 0x0004, // indicates that the notification is being fired after a cluster has closed

        CCE_UNDO            = 0x0008, // indicates that a cluster is an undo operation
        CCE_REDO            = 0x0010, // indicates that a cluster is a redo operation

        CCE_FLUSH           = 0x0020, // indicates an early notification was prompted by an explicit flush request

        CCE_ABORTED         = 0x0100 // indicates that a cluster has been aborted
    } ChangeClusterFlags;


    /*
        IVsChangeClusterEvents is used to bracket a series of changes from an undo manager.  To get it, QI an
        undo manager for IConnectionPointContainer and go from there.

        A cluster is a series of edits that is grouped into an undo action.

        NOTE: This event set, which is used internally for the text buffer's commit event, is being exposed for a
        very specific purpose by the edit & continue group.  Listening to this event set imposes nontrivial
        overhead for every modification made to a text buffer.  You may look at this interface and be tempted to
        use it for many different things, but this is not encouraged.  Do not use this interface unless you have
        talked to the text editor team and have confirmed that you have no other options.  In particular,
        IVsPreliminaryTextChangeCommitEvents (which is built on top of this event) should be able to address the
        needs of most clients without needing to listen to IVsChangeClusterEvents.
    */
    [
        uuid(uuid_IVsChangeClusterEvents)
    ]
    interface IVsChangeClusterEvents : IUnknown
    {
#ifdef PROXYSTUB_BUILD
        HRESULT OnChangeClusterOpening([in] DWORD dwFlags);
        HRESULT OnChangeClusterClosing([in] DWORD dwFlags);
#else
        void OnChangeClusterOpening([in] DWORD dwFlags);
        void OnChangeClusterClosing([in] DWORD dwFlags);
#endif
    };


    ////////////////////////////////////////////////////////////////////////////
    // VsUserData coclass
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_coclass_VsLocalUserData),
		helpstring("VsLocalUserData Class")
    ]
    coclass VsLocalUserData
    {
        interface IVsUserData;
    };

    ////////////////////////////////////////////////////////////////////////////
    // VsUserData coclass
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_coclass_VsUserData),
		helpstring("VsUserData Class")
    ]
    coclass VsUserData
    {
        interface IVsUserData;
    };

    ////////////////////////////////////////////////////////////////////////////
    // VsCodeWindow coclass
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_coclass_VsCodeWindow),
		helpstring("VsCodeWindow Class")
    ]
    coclass VsCodeWindow
    {
        interface IVsCodeWindow;
    };

    ////////////////////////////////////////////////////////////////////////////
    // VsSplitRoot coclass
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_coclass_VsSplitRoot),
		helpstring("VsSplitRoot Class")
    ]
    coclass VsSplitRoot
    {
        interface IVsSplitRoot;
    };

	/////////////////////////////////////////////////////////////////////////
	// VsDropdownBar class
	[
		uuid(uuid_coclass_VsDropdownBar),
		helpstring("VsDropdownBar Class")
	]
	coclass VsDropdownBar
	{
		[default] interface IVsDropdownBar;
	};

    ////////////////////////////////////////////////////////////////////////////
    // VsTextBuffer coclass
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_coclass_VsTextBuffer),
		helpstring("VsTextBuffer Class")
    ]
    coclass VsTextBuffer
    {
        interface IVsTextBuffer;
		interface IVsTextLines;
    };

    ////////////////////////////////////////////////////////////////////////////
    // VsTextLineStorage coclass
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_coclass_VsTextLineStorage),
		helpstring("VsTextLineStorage Class")
    ]
    coclass VsTextLineStorage
    {
        interface IVsTextStorage;
		interface IVsPersistentTextImage;
    };

    ////////////////////////////////////////////////////////////////////////////
    // VsTextManager coclass
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_coclass_VsTextManager),
		helpstring("VsTextManager Class")
    ]
    coclass VsTextManager
    {
        interface IVsTextManager;
    };

    ////////////////////////////////////////////////////////////////////////////
    // VsTextView coclass
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_coclass_VsTextView),
		helpstring("VsTextView Class")
    ]
    coclass VsTextView
    {
        interface IVsTextView;
    };

    ////////////////////////////////////////////////////////////////////////////
    // VsTextPackage coclass
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_coclass_VsTextPackage),
		helpstring("VsTextPackage Class")
    ]
    coclass VsTextPackage
    {
        interface IVsTextManager;
    };

    ////////////////////////////////////////////////////////////////////////////
    // VsUndoPackage coclass
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_coclass_VsUndoPackage),
		helpstring("VsUndoPackage Class")
    ]
    coclass VsUndoPackage
    {
        interface IVsLinkedUndoTransactionManager;
    };

    ////////////////////////////////////////////////////////////////////////////
    // VsUndoUnit coclass
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_coclass_VsUndoUnit),
		helpstring("VsUndoUnit Class")
    ]
    coclass VsUndoUnit
    {
        interface IVsUndoUnit;
    };

    ////////////////////////////////////////////////////////////////////////////
    // VsMethodTipWindow coclass
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_coclass_VsMethodTipWindow),
		helpstring("VsMethodTipWindow Class")
    ]
    coclass VsMethodTipWindow
    {
        interface IVsMethodTipWindow;
    };

    ////////////////////////////////////////////////////////////////////////////
    // VsTextTipWindow coclass
    ////////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_coclass_VsTextTipWindow),
		helpstring("VsTextTipWindow Class")
    ]
    coclass VsTextTipWindow
    {
        interface IVsTextTipWindow;
    };

    /*
		VsHiddenTextLayer coclass
    */
	  [
		  uuid(uuid_coclass_VsHiddenTextLayer)
	  ]
	  coclass VsHiddenTextLayer
	  {
		  interface IVsHiddenTextSession;
	  };

    /*
		VsDefaultButtonBarImages coclass
    */
    [
        uuid(uuid_coclass_VsDefaultButtonBarImages)
    ]
    coclass VsDefaultButtonBarImages
    {
        interface IVsDefaultButtonBarImages;
    };

	  [
		  uuid(uuid_coclass_VsSyntheticTextLayer)
	  ]
	  coclass VsSyntheticTextLayer
	  {
		  interface IVsSyntheticTextSession;
	  };


	  [
		  uuid(uuid_coclass_VsDiffLayer)
	  ]
	  coclass VsDiffLayer
	  {
      interface IUnknown;
	  };

/*-------------*/

    cpp_quote("#define SID_SVsTextManager CLSID_VsTextManager")
    cpp_quote("#define SID_SVsLanguageFilter IID_IVsTextViewFilter")
    cpp_quote("#define SID_SVsCodeWindowManager IID_IVsCodeWindowManager")
    cpp_quote("#define SID_SVsCodeWindow IID_IVsCodeWindow")
    cpp_quote("#define SID_SVsLinkedUndoTransactionManager IID_IVsLinkedUndoTransactionManager")

    ////////////////////////////////////////////////////////////////////////////
    // Buffer-defined UserData GUIDs
    //
    ////////////////////////////////////////////////////////////////////////////

    //--------------------------------------------------------------------------
    // GUID_VsBufferMoniker  VT_BSTR
    cpp_quote("#define GUID_VsBufferMoniker IID_IVsUserData")
    
    //--------------------------------------------------------------------------
    // GUID_VsBufferIsDiskFile  VT_BOOL {D9126592-1473-11d3-BEC6-0080C747D9A0}
    //
    // VARIANT_TRUE if buffer is a file on disk
    // You cannot set this property. 
    //
    cpp_quote("extern const __declspec(selectany) GUID GUID_VsBufferIsDiskFile = { 0xd9126592, 0x1473, 0x11d3, { 0xbe, 0xc6, 0x0, 0x80, 0xc7, 0x47, 0xd9, 0xa0 } };")

    //--------------------------------------------------------------------------
    // GUID_VsBufferEncoding  VT_UI4  {212729AC-D6BB-11d0-AE75-00C04FB68006}
    //
    // Obsolete- Should use GUID_VsBufferEncodingVSTFF
    //
    // CHARFMT in the low word, codepage in the high word
    //
    // CHARFMT charfmt; // CHARFMT_UNI, CHARFMT_UNI_SWAP, CHARFMT_MBCS, CHARFMT_UTF8
    // UINT codepage;   // Affects persistence format only when charfmt == CHARFMT_MBCS
    // DWORD dwBufferEncoding;
    //
    // dwBufferEncoding = MAKELONG(charfmt,codepage); // to create
    // codepage = HIWORD(dwBufferEncoding);           // to extract codepage
    // charfmt = (CHARFMT)LOWORD(dwBufferEncoding);   // to extract CHARFMT
    //
    cpp_quote("extern const __declspec(selectany) GUID GUID_VsBufferEncoding = {0x212729ac,0xd6bb,0x11d0,{0xae,0x75,0x0,0xc0,0x4f,0xb6,0x80,0x6}};")

    //--------------------------------------------------------------------------
    // GUID_VsBufferEncodingVSTFF  VT_UI4  {16417F39-A6B7-4c90-89FA-770D2C60440B}
    //
    // DWORD dwBufferVSTFF;
    //
    // dwBufferVSTFF = vstff; // to create
    // codepage = dwBufferVSTFF & VSTFF_CPMASK;           // to extract codepage
    // vstffFlags = dwBufferVSTFF & VSTFF_FLAGSMASK;   // to extract CHARFMT
    //
    cpp_quote("extern const __declspec(selectany) GUID GUID_VsBufferEncodingVSTFF = { 0x16417f39, 0xa6b7, 0x4c90, { 0x89, 0xfa, 0x77, 0xd, 0x2c, 0x60, 0x44, 0xb }};")

    //--------------------------------------------------------------------------
    // GUID_VsBufferEncodingPromptOnLoad  VT_UI4  {99EC03F0-C843-4c09-BE74-CDCA5158D36C}
    //
    // Contact editor team with questions if you think you may want to use this.
    // This data is only for a set purpose.  You cannot get the value of this back.
    // This should only be used by editor factories that want to specify a codepage on loading from the openwith dialog.
    //
    // DWORD dwPromptOnLoadFlag;  PROMPTONLOADFLAGS: Set to codepageNoPrompt = 0x000000000 to detect or codepagePrompt = 0x000000001 to prompt for encoding on load
    //
    cpp_quote("extern const __declspec(selectany) GUID GUID_VsBufferEncodingPromptOnLoad = { 0x99ec03f0, 0xc843, 0x4c09, { 0xbe, 0x74, 0xcd, 0xca, 0x51, 0x58, 0xd3, 0x6c }};")


    //--------------------------------------------------------------------------
    // GUID_VsBufferDetectCharSet  VT_BOOL  {36358D1F-BF7E-11d1-B03A-00C04FB68006}
    //
    // When DetectCharSet is TRUE, and the current BufferEncoding is CHARFMT_MBCS, the buffer
    // runs it's HTML charset tag detection code to determine a codepage to load and
    // save the file. The detected codepage overrides any codepage set in CHARFMT_MBCS.
    //
    // This is forced on in the buffer's IPersistFileFormat::LoadDocData when it sees an
    // HTML type of file, according to the extension mapping in 
    // HKLM\Visual Studio\<ver>\Languages\File Extensions
    //
    cpp_quote("extern const __declspec(selectany) GUID GUID_VsBufferDetectCharSet = {0x36358d1f,0xbf7e,0x11d1,{0xb0,0x3a,0x0,0xc0,0x4f,0xb6,0x80,0x6}};")

    //--------------------------------------------------------------------------
    // GUID_VsBufferDetectLangSID  VT_BOOL  {17F375AC-C814-11d1-88AD-0000F87579D2}
    //
    // When DetectLangSID is VARIANT_TRUE, a change to the buffer's moniker will cause the buffer
	// to change the language service based on the moniker when the moniker is believed to
	// represent a disk file.  By default this is VARIANT_TRUE.
    //
    cpp_quote("extern const __declspec(selectany) GUID GUID_VsBufferDetectLangSID = { 0x17f375ac, 0xc814, 0x11d1, { 0x88, 0xad, 0x0, 0x0, 0xf8, 0x75, 0x79, 0xd2 } };")


    //--------------------------------------------------------------------------
    // GUID_PropertyBrowserSID  VT_BSTR  
    // 
    // 
    // This property will be used to set the SEID_PropertyBrowserSID element of the selection
	// for text views.  This is only used if you have a custom property browser.  If this
	// property is not set, the standard property browser will be associated with the view.
    //
    cpp_quote("extern const __declspec(selectany) GUID GUID_PropertyBrowserSID = { 0xce6ddbba, 0x8d13, 0x11d1, { 0x88, 0x89, 0x0, 0x0, 0xf8, 0x75, 0x79, 0xd2 }};")

    //--------------------------------------------------------------------------
    // GUID_UserReadOnlyErrorString  VT_BSTR  
    // 
    // 
    // This property is used to allow the buffer to provide specific rich error info in the
	// case where the buffer originates the BUFFER_E_READONLY error.  Set this BSTR to be
	// the (localized) text you want displayed by the UI.  Note that the buffer itself doesn't
	// put up UI, but only sets rich error info so that the calling UI can do so.
    //
    cpp_quote("extern const __declspec(selectany) GUID GUID_UserReadOnlyErrorString = { 0xa3bcfe56, 0xcf1b, 0x11d1, { 0x88, 0xb1, 0x0, 0x0, 0xf8, 0x75, 0x79, 0xd2 }};")

    //--------------------------------------------------------------------------
    // GUID_BufferStorage  VT_UNKNOWN
    // 
    // This property is used to get access to the buffer's storage object.  The returned
    // pointer can be QI'd for IVsTextStorage and IVsPersistentTextImage.  This is a get-only
    // property.  To set the storage, use the buffer's InitializeContentEx method.
    //
    // {D97F167A-638E-11d2-88F6-0000F87579D2}
    cpp_quote("extern const __declspec(selectany) GUID GUID_BufferStorage = { 0xd97f167a, 0x638e, 0x11d2, { 0x88, 0xf6, 0x0, 0x0, 0xf8, 0x75, 0x79, 0xd2 } };")

	/*
		General text editor GUIDs
	*/

	cpp_quote("extern const __declspec(selectany) GUID CLSID_TextEditorFactory = { 0x8B382828, 0x6202, 0x11d1, { 0x88, 0x70, 0x00, 0x00, 0xF8, 0x75, 0x79, 0xD2 }};")
	cpp_quote("extern const __declspec(selectany) GUID CMDUIGUID_TextEditor = { 0x8B382828, 0x6202, 0x11d1, { 0x88, 0x70, 0x00, 0x00, 0xF8, 0x75, 0x79, 0xD2 }};")

    struct TabStop
    {
        long *iCol;
        ULONG cEl;
        UINT iRepeatWidth;
        DWORD dwFlags;
    };
    enum TabStopFlags
    {
        USE_DEFAULT_REPEAT = 0x00000001
    };


    [
        uuid(uuid_IVsDynamicTabProvider)
    ]
    interface IVsDynamicTabProvider : IUnknown
    {
        HRESULT GetTabStopElements(
            [in] IVsTextLines *pBuffer,
            [in] long iLine,
            [out] UINT *cEl);

        HRESULT GetTabStop(
            [in] IVsTextLines *pBuffer,
            [in] long iLine,
            [out] struct TabStop *sTabStop);
    };

	////////////////////////////////////////////////////////////////////////////
	// IVsLastChangeTimeProvider
	//
	// Allows an object to tell clients when its last change occured.  Presently
	// used by the default text buffer implementation.
	////////////////////////////////////////////////////////////////////////////
	[
		uuid(uuid_IVsLastChangeTimeProvider),
	]
	interface IVsLastChangeTimeProvider : IUnknown
	{
		HRESULT GetLastChangeTime([out] FILETIME *pFileTime);
	};

    // IVsEnumTextSpans
	[
		uuid(uuid_IVsEnumTextSpans)
	]
    interface IVsEnumTextSpans : IUnknown
    {
        HRESULT     Reset(void);
        HRESULT     Next([in] ULONG cEl, [out, size_is(cEl)] TextSpan *ppOut, [out] ULONG *pcElFetched);
        HRESULT     GetCount([out] ULONG *pcSpans);
    };

    typedef enum _MapLocalSpanFlags
    {
        // compatibility names
        MLS_VISIBLE_ONLY               = 0x00000,  // omits concealed and collapsed text
        MLS_INCLUDE_USER_EXPANDABLE    = 0x00001,  // omits concealed text but includes collapsed text (collapsible text that's in the collapsed state)
        MLS_NEVER_COMBINE_SPANS        = 0x00002,  // keeps adjacent spans from being combined into a single underlying span

        // compatibility names
        mlsVisibleOnly              = MLS_VISIBLE_ONLY,
        mlsIncludeUserExpandable    = MLS_INCLUDE_USER_EXPANDABLE,
        mlsNeverCombineSpans		= MLS_NEVER_COMBINE_SPANS
    } MapLocalSpanFlags;

    typedef enum _DeeperLayerLineIndexToLocalFlags
    {
        DLI_DEFAULT             = 0x00000000, // fail with VIEW_E_LOCATION_HIDDEN if deeper text is hidden
        DLI_CLOSEST             = 0x00000001, // send back the closest available local coordinates
        DLI_RIGHTMOST           = 0x00000002, // opts for rightmost in case of ambiguity; by default we opt for leftmost in case of ambiguity

        /*
            DLI_AVOID_OUTER_EDGE is a "request", not "requirement" flag.  It is used to tell a layer that during
            the conversion it should avoid converting the coordinate to a local coordinate that is on the "outer"
            edge of a visible region ("outer" meaning the right edge if DLI_RIGHTMOST is specified, and meaning
            the left edge otherwise).
        */
        DLI_AVOID_OUTER_EDGE    = 0x00000004, // try to enclose outer edge

        // compatibility names
        dliDefault              = DLI_DEFAULT,
        dliClosest              = DLI_CLOSEST,
        dliRightmost            = DLI_RIGHTMOST
    } DeeperLayerLineIndexToLocalFlags;

	/*
		IVsTextLayer

		Used to handle layout between a base buffer and a view.
	*/
	[
		uuid(uuid_IVsTextLayer)
	]
	interface IVsTextLayer : IUnknown
	{
		/*
			Coordinate conversion functions

			For these two it's OK to pass in NULL for coordinates you don't care about.

			Expected return values:
				S_OK: coordinates transformed, everything's fine.
				VIEW_E_LOCATION_HIDDEN: the coordinates you requested exist, but are hidden in the UI at present.
				E_INVALIDARG: bad [in] params.
		*/
		HRESULT		LocalLineIndexToBase([in] long iLocalLine, [in] CharIndex iLocalIndex, [out] long *piBaseLine, [out] CharIndex *piBaseIndex);
		HRESULT		BaseLineIndexToLocal([in] long iBaseLine, [in] CharIndex iBaseIndex, [out] long *piLocalLine, [out] CharIndex *piLocalIndex);

        HRESULT     LocalLineIndexToDeeperLayer([in] IVsTextLayer *pTargetLayer, [in] long iLocalLine, [in] CharIndex iLocalIndex, [out] long *piTargetLine, [out] CharIndex *piTargetIndex);
		HRESULT		DeeperLayerLineIndexToLocal(
            [in] DWORD dwFlags, // ORing of DeeperLayerLineIndexToLocalFlags enum
            [in] IVsTextLayer *pTargetLayer, 
            [in] long iLayerLine, 
            [in] CharIndex iLayerIndex, 
            [out] long *piLocalLine, 
            [out] CharIndex *piLocalIndex);

        HRESULT		GetBaseBuffer([out] IVsTextLines **ppiBuf); // NOTE: ppiBuf is AddRef'd

		/* stuff from IVsTextBuffer */
        // [Un]LockBufferEx() deprecated in Dev10.  IVsTextLayer should be accessed from the UI thread.
        HRESULT     LockBufferEx([in] DWORD dwFlags); // dwFlags is an ORing of BufferLockFlags (presently either BLF_READ or BLF_WRITE)
        HRESULT     UnlockBufferEx([in] DWORD dwFlags); // dwFlags is an ORing of BufferLockFlags (presently either BLF_READ or BLF_WRITE)

        HRESULT     GetLengthOfLine ([in] long iLine, [out] long *piLength);
        HRESULT     GetLineCount ([out] long *piLineCount);
        HRESULT     GetLastLineIndex ([out] long *piLine, [out] long *piIndex); // gets length of last line; shortcut for frequent pattern of calling GetLineCount & then GetLengthOfLine on that line

		/* stuff similar to IVsTextLines */
        HRESULT     GetMarkerData ([in] long iTopLine, [in] long iBottomLine, [out] MARKERDATA *pMarkerData);
        HRESULT     ReleaseMarkerData ([in] MARKERDATA *pMarkerData);

		// the mother of all GetLineData calls
		HRESULT		GetLineDataEx ([in] DWORD dwFlags, [in] long iLine, [in] long iStartIndex, [in] long iEndIndex, [out] LINEDATAEX *pLineData, [in] MARKERDATA *pMarkerData);
		HRESULT		ReleaseLineDataEx ([in] LINEDATAEX *pLineData); // releases LINEDATAEX

		// Puts the specified span of text into a BSTR; it is the caller's responsibility to free the BSTR.
		HRESULT		GetLineText(
			[in] long      iStartLine,	// starting line
			[in] CharIndex iStartIndex,	// starting character index within the line (must be <= length of line)
			[in] long      iEndLine,	// ending line
			[in] CharIndex iEndIndex,	// ending character index within the line (must be <= length of line)
			[out] BSTR *   pbstrBuf);   // text of span

		// Puts the specified span of text into a caller-allocated buffer; this will copy up to cchBuf characters, and
		// if the buffer wasn't big enough, returns BUFFER_E_DEST_TOO_SMALL and sets *pcchBuf to the required size.
		// To just get the required size, you can pass in NULL for pszBuf.
		HRESULT		CopyLineText(
			[in] long      iStartLine,	// starting line
			[in] CharIndex iStartIndex,	// starting character index within the line (must be <= length of line)
			[in] long      iEndLine,	// ending line
			[in] CharIndex iEndIndex,	// ending character index within the line (must be <= length of line)
            [in] LPWSTR    pszBuf,	    // text to insert, if any
			[in, out] long * pcchBuf);  // NOTE: this is a count of UNICODE CHARACTERS, *not* BYTES!!!

        // Stream-like line editing -- handles line breaking/joining, etc.
       HRESULT     ReplaceLines (
			[in] long      iStartLine,	// starting line
			[in] CharIndex iStartIndex,	// starting character index within the line (must be <= length of line)
			[in] long      iEndLine,	// ending line
			[in] CharIndex iEndIndex,	// ending character index within the line (must be <= length of line)
            [in] LPCWSTR   pszText,     // text to insert, if any
            [in] long      iNewLen,     // # of chars to insert, if any
			[out] TextSpan * pChangedSpan);	// range of characters changed

       HRESULT     CanReplaceLines(
			[in] long      iStartLine,	// starting line
			[in] CharIndex iStartIndex,	// starting character index within the line (must be <= length of line)
			[in] long      iEndLine,		// ending line
			[in] CharIndex iEndIndex,	// ending character index within the line (must be <= length of line)
            [in] long      iNewLen);        // # of chars to insert, if any
								
        // to create a zero-length tracking point (similar to a zero-length marker)
        HRESULT     CreateTrackingPoint (
			[in] long      iLine,	// line
			[in] CharIndex iIndex,	// character index within the line (must be <= length of line)
			[out] IVsTextTrackingPoint ** ppMarker);

		// IVsTextLayer::EnumLayerMarkers enumerates ALL markers, but gets their IVsTextLineMarker interface via IVsEnumLineMarkers.
        HRESULT     EnumLayerMarkers(
			[in] long      iStartLine,	// starting line
			[in] CharIndex iStartIndex,	// starting character index within the line (must be <= length of line)
			[in] long      iEndLine,	// ending line
			[in] CharIndex iEndIndex,	// ending character index within the line (must be <= length of line)
			[in] long      iMarkerType,
			[in] DWORD     dwFlags,     // ORing of ENUMMARKERFLAGS
			[out] IVsEnumLayerMarkers ** ppEnum);

        // Line editing -- handles line breaking/joining, etc.
        HRESULT     ReplaceLinesEx (
            [in] DWORD      dwFlags,     // special handling; ORing of REPLACE_TEXT_FLAGS enum
            [in] long       iStartLine,  // starting line
            [in] CharIndex  iStartIndex, // starting character index within the line (must be <= length of line)
            [in] long       iEndLine,    // ending line
            [in] CharIndex  iEndIndex,   // ending character index within the line (must be <= length of line)
            [in] LPCWSTR    pszText,     // text to insert, if any
            [in] long       iNewLen,     // # of chars to insert, if any
            [out] TextSpan *pChangedSpan);  // range of characters changed

        /*
            MapLocalSpansToTextOriginatingLayer will take a set of local spans & map them down to the shallowest
            layer that originates text.  So you aren't guaranteed that you'll get back the layer that actually
            originates a given set of text, but you are guaranteed that you'll get the shallowest layer that
            originates "real" text (which excludes non-text atoms).
        */
        HRESULT MapLocalSpansToTextOriginatingLayer(
            [in] DWORD dwFlags, // one of MapLocalSpanFlags values
            [in] IVsEnumTextSpans *pLocalSpanEnum, 
            [out] IVsTextLayer **ppTargetLayer,
            [out] IVsEnumTextSpans **ppTargetSpanEnum);        
	};

   	typedef enum _tag_LAYER_MODULE_CAPABILITIES
	{
        LMC_TEXTFIND        = 0x01,   // shallow text find operations (e.g. ISearch)
        LMC_TEXTPRINT       = 0x02,   // printing
        LMC_TEXTORIGINATE   = 0x04    // originates text
	} LAYER_MODULE_CAPABILITIES;


    /*///////////////////////////////////////////////////////////////////////
        Synthetic text interfaces
    ///////////////////////////////////////////////////////////////////////*/

    typedef struct _NewSyntheticRegion
    {
        // general information
        long        iMarkerType;    // standard marker type; display characteristics (coloring, glyph) to show for this region (has no effect on base buffer)
        DWORD       dwBehavior;     // currently unused; must be zero

        // the text to display (can be >1 line)
        LPCWSTR     pszText;        // any WCHAR* will do; the synthetic text session will make a copy of this

        // iAnchorLine/iAnchorIndex define where the text will show up; these are in base buffer coordinates
        long        iAnchorLine;    // the zero-based line #
        CharIndex   iAnchorIndex;   // the zero-based char index (must not be in virtual space)

        DWORD       dwClient;       // client-defined DWORD; this can be retrieved via IVsSyntheticRegion::GetClientData

        // iSerialValue is used to sort adjacent regions; if you expect adjacent regions, you should set this to ensure good sorting.
        // Otherwise, set iSerialValue to zero for everything and adjacent regions will be sorted by time (last added -> last logical position)
        long        iSerialValue;
    }
    NewSyntheticRegion;

    [
        uuid(uuid_IVsSyntheticRegion)
    ]
    interface IVsSyntheticRegion : IUnknown
    {
        // Permanent properties
        HRESULT GetMarkerType ([out] long *piMarkerType); // see SYNTHETIC_REGION_TYPE enum
        HRESULT GetBehavior ([out] DWORD *pdwBehavior); // see SYNTHETIC_REGION_BEHAVIOR enum

        HRESULT GetText([out] BSTR *pbstrText);  // NOTE: this allocates a new BSTR which must be freed by the caller!
        HRESULT SetText([in] LPCWSTR pszText);    // NOTE: Synthetic text mgr allocates a new string

        HRESULT GetBaseBufferAnchor([out] long *piAnchorLine, [out] long *piAnchorIndex); // returns the current base buffer location of the region
        HRESULT SetBaseBufferAnchor([in] long iAnchorLine, [in] long iAnchorIndex);       // changes the current base buffer location of the region

        HRESULT GetClientData([out] DWORD_PTR *pdwData); // returns the dwClient DWORD associated with the region
        HRESULT SetClientData([in] DWORD_PTR dwData);    // changes the dwClient DWORD associated with the region

        // Deletion management
        HRESULT Invalidate([in] DWORD dwUpdate);  // dwUpdateFlags is ORing of CHANGE_SYNTHETIC_REGION_FLAGS enum; this causes the region to go away; i.e. the text becomes exposed & normal
        HRESULT IsValid([out] BOOL *pfValid); // valid if TRUE, FALSE if not

        // Layer, text image interaction
        HRESULT GetTextLayer([out] IVsTextLayer **ppLayer); // *ppLayer will be AddRef'd
        HRESULT GetSyntheticLayerSpan([out] TextSpan *pSpan); // returns the extent of the region in coordinates of the owning layer
        HRESULT GetTextImage([out] IVsTextImage **ppImage); // a relative text image that encompasses only the synthetic region's text
    };


    [
        uuid(uuid_IVsEnumSyntheticRegions)
    ]
    interface IVsEnumSyntheticRegions : IUnknown
    {
        HRESULT     Reset(void);
        HRESULT     Next([in] ULONG cEl, [out, size_is(cEl)] IVsSyntheticRegion** ppOut, [out] ULONG *pcElFetched);
        HRESULT     GetCount([out] ULONG *pcRegions);
    };


    typedef enum _syntheticregionevent
    {
        sreRegionReloaded = 0,      // the text of a Synthetic region was reloaded and may no longer be at an appropriate location
    } SYNTHETIC_REGION_EVENT;

    [
        uuid(uuid_IVsSyntheticTextClient)
    ]
    interface IVsSyntheticTextClient : IUnknown
    {
#ifdef PROXYSTUB_BUILD
        HRESULT OnSyntheticRegionChange(
            [in] IVsSyntheticRegion *pSynthReg,         // the synthetic region in question
            [in] SYNTHETIC_REGION_EVENT EventCode);     // SYNTHETIC_REGION_EVENT value
#else
        void OnSyntheticRegionChange(
            [in] IVsSyntheticRegion *pSynthReg,         // the synthetic region in question
            [in] SYNTHETIC_REGION_EVENT EventCode);     // SYNTHETIC_REGION_EVENT value
#endif

        HRESULT GetTipText(  // returns tip text for hovering
            [in] IVsSyntheticRegion *pSynthReg,  // the synthetic region in question
            [out, optional] BSTR *pbstrText);              // a BSTR that returns the text to display

        // GetErrorText is not yet utilized, pending investigation of how best to handle editing scenarios
        HRESULT GetErrorText(  // returns tip text for hovering
            [in] DWORD dwReason,                 // reason for the call
            [in] IVsSyntheticRegion *pSynthReg,  // the synthetic region in question
            [out] BSTR *pbstrText);              // a BSTR that returns the text to display

		// Commands -- see MarkerCommandValues for meaning of iItem param
        HRESULT	GetMarkerCommandInfo(
            [in] IVsSyntheticRegion *pSynthReg, // the synthetic region in question
            [in] long iItem,                    // which command (see MarkerCommandValues)
            [out, custom(uuid_IVsSyntheticTextClient, "optional")] BSTR * pbstrText,              // [optional to set] title for command
            [out] DWORD* pcmdf);                // command flags for visibility, being enabled, etc.
        HRESULT	ExecMarkerCommand(
            [in] IVsSyntheticRegion *pSynthReg, // the synthetic region in question
            [in] long iItem);                   // which command (see MarkerCommandValues)

#ifdef PROXYSTUB_BUILD
        HRESULT OnBeforeSessionEnd(void);       // a notification that the synthetic text session is ending
#else
        void    OnBeforeSessionEnd(void);       // a notification that the synthetic text session is ending
#endif
    };

    typedef enum _tag_FIND_SYNTHETIC_REGION_FLAGS
    {
        FSR_ALL_REGIONS      = 0x0, // if you want to find every region, specify *ONLY* this flag

        // dwCookie group
        FSR_BY_CLIENT_DATA    = 0x1, // find region with matching client DWORD

        // span param group (mutually exclusive)
        FSR_WITHIN_SPAN      = 0x4, // find all regions within the given span
        FSR_EXACT_SPAN       = 0x8, // find only regions whose base span exactly matches the given span

    } FIND_SYNTHETIC_REGION_FLAGS;


    typedef enum _tag_CHANGE_SYNTHETIC_REGION_FLAGS
    {
        CSR_DEFAULT         = 0x0, // undoable
        CSR_NONUNDOABLE     = 0x1 // not added to undo/redo stack (e.g. for initial presentation)
    } CHANGE_SYNTHETIC_REGION_FLAGS;

    [
        uuid(uuid_IVsSyntheticTextSession)
    ]
    interface IVsSyntheticTextSession : IUnknown
    {
        HRESULT AddSyntheticRegions(
                [in] DWORD dwUpdateFlags,  // ORing of CHANGE_SYNTHETIC_REGION_FLAGS enum
                [in] long cRegions,         // how many regions you want to add
                [in, size_is(cRegions)] NewSyntheticRegion *rgSynthReg, // array of (cRegions) structs defining the new regions
                [out] IVsEnumSyntheticRegions **ppEnum);    // may be NULL; if non-NULL, returns an enum of the new regions

        /*
            EnumSyntheticRegions returns a static snapshot list of Synthetic regions.
        */
        HRESULT EnumSyntheticRegions(
                [in] DWORD dwFindFlags,     // tells how to find region; ORing of FIND_SYNTHETIC_REGION_FLAGS enum
                [in] DWORD_PTR dwCookie,        // extra search parameter; can be used to search for specific client DWORD
                [in] TextSpan *ptsRange,    // search paramter for finding text
                [out] IVsEnumSyntheticRegions **ppEnum); // the resulting enumeration

        HRESULT UnadviseClient(void); // tells the session to sever its link (and drop its COM reference) to the client (i.e. you)
        HRESULT Terminate(void);    // immediately kills the synthetic text session
    };

	[
		uuid(uuid_IVsSyntheticTextManager)
	]
    interface IVsSyntheticTextManager : IUnknown
    {
        // GetSyntheticTextSession asks the owning object whether a synthetic text session currently exists
        HRESULT GetSyntheticTextSession(
            [in] IUnknown *pOwningObject,   // the owning object (normally the buffer)
            [out] IVsSyntheticTextSession **ppSession); // an existing session

        HRESULT CreateSyntheticTextSession(
            [in] DWORD dwFlags, // currently unused; must be zero
            [in] IUnknown *pOwningObject,  // the owning object (normally the buffer)
            [in] IVsSyntheticTextClient *pClient, // your client interface
            [out] IVsSyntheticTextSession **ppState); // the new session
    };


/*
    Hidden text interfaces
*/

	/*
		IVsTextHidingLayerModule

		This interface is implemented by any layer module that hides text on the layer below.  In other words,
        if a given layer can ever return VIEW_E_LOCATION_HIDDEN, it must implement this interface to allow the
        text to be made visible if some user action (e.g. the "Go To Line" command) makes it necessary.

        When MakeBaseSpanVisible is called, the layer should make the text visible at its layer if it knows
        how.  If it fails, the layout module will be destroyed!  Layers that don't hide text must not implement
        this interface.  However, when MakeBaseSpanVisible is called, layers can assume (and are welcome to
        ASSERT) that the base span has already been made visible by the layer below.

        Finally, there is one very important semantic detail wrt MakeBaseSpanVisible's pBaseSpan parameter.
        This parameter indicates that ALL the base text therein should be made visible, not merely that the
        begin & end should be made visible.  For example, if I have hidden text in the middle of a line and
        pass the start & end of the line as the param to MakeBaseSpanVisible, it's not sufficient to ensure
        that only the start & end of the line are visible.  EVERY CHARACTER in the span must be visible!!
        Therefore, this must be used carefully.  In some cases (e.g. highlighting a find hit) you want to use
        this on a span of text.  In others (e.g. the "Go To Line" command), you only want to ensure that the
        beginning of the physical line is visible, but you don't want to force the entire contents of the
        physical line to be revealed.

        The required side effect of this function succeeding is that a call to BaseLineIndexToLocal on any
        character within *pBaseSpan must succeed and not return VIEW_E_LOCATION_HIDDEN.
	*/
	[
		uuid(uuid_IVsTextHidingLayerModule)
	]
	interface IVsTextHidingLayerModule : IUnknown
	{
        /*
            MakeBaseSpanVisible return codes:
                S_OK: the span was hidden but is now visible
                S_FALSE: the span wasn't hidden by this layer
                E_FAIL: the span is hidden but the layer doesn't know how to unhide it (will result in the layer being destroyed)
        */
        HRESULT MakeBaseSpanVisible(TextSpan *pBaseSpan); // make EVERY CHARACTER of the span visible
	};

    typedef enum _hidden_region_state
    {
        hrsDefault                  = 0x0, // implies it's collapsed
        hrsExpanded                 = 0x1  // expanded
    } HIDDEN_REGION_STATE;

    typedef enum _hidden_region_type
    {
        hrtConcealed                = 0x0,
        hrtCollapsible              = 0x1
    } HIDDEN_REGION_TYPE;

    /*
        Hidden region behavior flags
        ============================

        hrbClientControlled vs. hrbEditorControlled: 
        
        To fully control every aspect of a hidden text region, you can use hrbClientControlled to get
        notifications for a variety of events.  If you just want to do outlining-type hiding of a region
        & want the editor to take responsibility for the appearance, behavior, and lifetime of the hidden
        region, use hrbEditorControlled.  Here are the pieces of information that you can explicitly
        control if you use hrbClientControlled, along with their default implementation:

        - Banner text:
            hrbClientControlled: specified via NewHiddenRegion and IVsHiddenRegion::SetBanner()
            hrbEditorControlled: always a fixed string, probably something like "..."
        - Tip text
            hrbClientControlled: specified via IVsHiddenTextClient::GetTipText()
            hrbEditorControlled: the first N non-whitespace text of the hidden text, truncated for presentability
        - Command negotiation
            hrbClientControlled: you can expose/handle context menu commands via IVsHiddenTextClient::GetMarkerCommandInfo()/ExecMarkerCommand()
            hrbEditorControlled: always fixed to "expand"/"collapse" and "stop hiding" (or whatever they wind up be called)
        - Event notification
            hrbClientControlled: you get lots of notifications via IVsHiddenTextClient about when the hidden region is deleted, state changes, etc.
            hrbEditorControlled: you get no such notifications (editor handles them internally)

        If you want to do simple outlining, use hrbEditorControlled.  If you want more detailed control over
        how the hidden regions behave, use hrbClientControlled.
    */

    typedef enum _hidden_region_behavior
    {
        hrbClientControlled         = 0x0,
        hrbEditorControlled         = 0x1
    } HIDDEN_REGION_BEHAVIOR;

    typedef enum _tag_CHANGE_HIDDEN_REGION_FLAGS
    {
        chrDefault         = 0x0, // undoable
        chrNonUndoable     = 0x1 // not added to undo/redo stack (e.g. for initial presentation)
    } CHANGE_HIDDEN_REGION_FLAGS;


	// NewHiddenRegion
	//------------------------------------------------------------------------------
	typedef struct _tag_NewHiddenRegion
	{
        // These members reflect permanent properties of the hidden region
        long            iType;          // see HIDDEN_REGION_TYPE enum
        DWORD           dwBehavior;     // ORing of HIDDEN_REGION_BEHAVIOR enum values

        // These members reflect changeable properties of the hidden region
        DWORD           dwState;        // State bits (e.g. expand/collapse state) -- see HIDDEN_REGION_STATE enum
		TextSpan	    tsHiddenText;   // Span of hidden text

        // pszBanner is ignored unless hrbClientControlled is specified for dwBehavior
		LPCWSTR         pszBanner;      // Banner; NOTE: text hiding mgr will alloc a new string
        DWORD_PTR       dwClient;       // Opaque client-defined information (e.g. array index or ptr to retrieve internal data)
	} NewHiddenRegion;


    [
        uuid(uuid_IVsHiddenRegion)
    ]
    interface IVsHiddenRegion : IUnknown
    {
        // Permanent properties
        HRESULT GetType ([out] long *piHiddenRegionType); // see HIDDEN_REGION_TYPE enum
        HRESULT GetBehavior ([out] DWORD *pdwBehavior); // see HIDDEN_REGION_BEHAVIOR enum

        // Changeable properties
        HRESULT GetState([out] DWORD *dwState);
        HRESULT SetState(
            [in] DWORD dwState,     // ORing of HIDDEN_REGION_STATE values
            [in] DWORD dwUpdate);   // ORing of CHANGE_HIDDEN_REGION_FLAGS values

        HRESULT GetBanner([out] BSTR *pbstrBanner);  // NOTE: this allocates a new BSTR which must be freed by the caller!
        HRESULT SetBanner([in] LPCWSTR pszBanner);    // NOTE: hidden text mgr allocates a new string

        HRESULT GetSpan([out] TextSpan *pSpan);
        HRESULT SetSpan([in] TextSpan *pSpan);

        HRESULT GetClientData([out] DWORD_PTR *pdwData);
        HRESULT SetClientData([in] DWORD_PTR dwData);

        // Deletion management
        HRESULT Invalidate([in] DWORD dwUpdate);  // dwUpdateFlags is ORing of CHANGE_HIDDEN_REGION_FLAGS enum; this causes the region to go away; i.e. the text becomes exposed & normal
        HRESULT IsValid(void); // S_OK: yes; S_FALSE: no

        // Layer, text image interaction
        HRESULT GetBaseBuffer([out] IVsTextLines **ppBuffer); // *ppBuffer will be AddRef'd
    };


    /////////////////////////////////////////////////////////////////////////
    // IVsEnumHiddenRegions interface
    /////////////////////////////////////////////////////////////////////////
    [
        uuid(uuid_IVsEnumHiddenRegions)
    ]
    interface IVsEnumHiddenRegions : IUnknown
    {
        HRESULT     Reset(void);
        HRESULT     Next([in] ULONG cEl, [out, size_is(cEl)] IVsHiddenRegion** ppOut, [out] ULONG *pcElFetched);
        HRESULT     GetCount([out] ULONG *pcRegions);
    };

    typedef enum _hiddenregionevent
    {
        hreRegionDeleted = 0,   // region deleted by a text edit
        hreRegionResurrected,   // was deleted, but restored by an undo or redo
        hreRegionReloaded,      // the text of a hidden region was reloaded and may no longer be at an appropriate location
        hreBeforeRegionExpanded,      // a region with user-controlled visibility will be expanded
        hreAfterRegionExpanded,      // a region with user-controlled visibility was expanded
        hreBeforeRegionCollapsed,      // a region with user-controlled visibility will be collapsed
        hreAfterRegionCollapsed      // a region with user-controlled visibility was collapsed
    } HIDDEN_REGION_EVENT;

    /*
        IVsHiddenTextClient

        Passed into IVsHiddenTextManager::CreateHiddenTextSession().
    */
	[
		uuid(uuid_IVsHiddenTextClient)
	]
	interface IVsHiddenTextClient : IUnknown
	{
        /*
            OnHiddenRegionChange is only fired in response to "external" churn on the view or buffer.  It is not fired in
            response to calls on IVsHiddenTextState.

            NOTE: Clients should not add or remove hidden regions in response to this call!
        */
#ifdef PROXYSTUB_BUILD
        HRESULT OnHiddenRegionChange(
            [in] IVsHiddenRegion *pHidReg,
            [in] HIDDEN_REGION_EVENT EventCode,     // HIDDENREGIONEVENT value
            [in] BOOL fBufferModifiable); // whether it's safe to change the buffer in response to this event
#else
        void OnHiddenRegionChange(
            [in] IVsHiddenRegion *pHidReg,
            [in] HIDDEN_REGION_EVENT EventCode,     // HIDDENREGIONEVENT value
            [in] BOOL fBufferModifiable); // whether it's safe to change the buffer in response to this event
#endif

        HRESULT GetTipText([in] IVsHiddenRegion *pHidReg, [out, optional] BSTR *pbstrText); // tip text for hovering (different from banner)

		// Commands -- see MarkerCommandValues for meaning of iItem param, but note that mcvGlyphCommand is never sent here
		HRESULT		GetMarkerCommandInfo([in] IVsHiddenRegion *pHidReg, [in] long iItem, [out, custom(uuid_IVsHiddenTextClient, "optional")] BSTR * pbstrText, [out] DWORD* pcmdf);
		HRESULT		ExecMarkerCommand([in] IVsHiddenRegion *pHidReg, [in] long iItem);

        /*
            MakeBaseSpanVisible is used for visibility control.  If the user does something that requires a
            piece of hidden text to be visible (e.g. Goto line command, debugger stepping, find in files hit,
            etc.) then we will turn around and call this for regions that the text hiding manager cannot
            automatically make visible.  (In the current implementation this will only happen for concealed
            regions; collapsible ones will be automatically expanded.)  This CANNOT fail!!  You must either
            destroy the hidden region by calling IVsHiddenRegion::Remove() or else reset its range so that
            it is no longer hiding the hidden text.  It is OK to add/remove other regions when this is called.
        */
        HRESULT     MakeBaseSpanVisible([in] IVsHiddenRegion *pHidReg, [in] TextSpan *pBaseSpan);

#ifdef PROXYSTUB_BUILD
        HRESULT OnBeforeSessionEnd(void);
#else
        void    OnBeforeSessionEnd(void);
#endif
    };


    typedef enum _tag_FIND_HIDDEN_REGION_FLAGS
    {
        FHR_ALL_REGIONS      = 0x0, // if you want to find every region, specify *ONLY* this flag

        // dwCookie group (mutually exclusive)
        FHR_BY_CLIENT_DATA   = 0x1, // find region with matching client DWORD
        FHR_BY_TYPE          = 0x2, // finds by type; cast marker type to DWORD & put in dwCookie

        // span param group (mutually exclusive)
        FHR_INTERSECTS_SPAN      = 0x4, // find all regions intersecting the given span
        FHR_EXACT_SPAN       = 0x8, // find only regions whose base span exactly matches the given span

        // behavior filter group (mutually exclusive)
        FHR_EDITOR_CONTROLLED_ONLY     = 0x10,
        FHR_CLIENT_CONTROLLED_ONLY     = 0x20,

        // another span param (mutually exclusive with others)
        FHR_ENTIRELY_WITHIN_SPAN = 0x40, // finds regions that are *entirely* within the given span, not simply intersecting with it

        // FHR_INNERMOST can be used along with other conditions; it finds the most deeply nested region
        FHR_INNERMOST    = 0x80, // finds one region that is the most deeply nested at the given location

        FHR_VISIBLE_ONLY = 0x100, // excludes regions inside a collapsed region

        FHR_PREFER_START_IN_SPAN = 0x200, // gives a region starting within the span higher priority than one ending
                                          // in the span. Only has effect with FHR_INNERMOST specified.

        FHR_MUST_START_IN_SPAN = 0x400, // like FHR_PREFER_START_IN_SPAN, except *only* regions starting within spans
                                        // will be returned

        // old compatibility flags
        fhrAllRegions      = FHR_ALL_REGIONS, // if you want to find every region, specify *ONLY* this flag

        // dwCookie group (mutually exclusive)
        fhrByClientData    = FHR_BY_CLIENT_DATA, // find region with matching client DWORD
        fhrByType          = FHR_BY_TYPE, // finds by type; cast marker type to DWORD & put in dwCookie

        // span param group (mutually exclusive)
        fhrWithinSpan      = FHR_INTERSECTS_SPAN, // find all regions within the given span
        fhrExactSpan       = FHR_EXACT_SPAN, // find only regions whose base span exactly matches the given span

        // behavior filter group (mutually exclusive)
        fhrEditorControlledOnly     = FHR_EDITOR_CONTROLLED_ONLY,
        fhrClientControlledOnly     = FHR_CLIENT_CONTROLLED_ONLY

    } FIND_HIDDEN_REGION_FLAGS;

	[
		uuid(uuid_IVsHiddenTextManager)
	]
    interface IVsHiddenTextManager : IUnknown
    {
        HRESULT GetHiddenTextSession([in] IUnknown *pOwningObject, [out] IVsHiddenTextSession **ppSession);
        HRESULT CreateHiddenTextSession(
            [in] DWORD dwFlags,
            [in] IUnknown *pOwningObject,
            [in] IVsHiddenTextClient *pClient,
            [out] IVsHiddenTextSession **ppState);
    };

	[
		uuid(uuid_IVsHiddenTextSession)
	]
    interface IVsHiddenTextSession : IUnknown
    {
        HRESULT AddHiddenRegions(
                [in] DWORD dwUpdateFlags,  // ORing of CHANGE_HIDDEN_REGION_FLAGS enum
                [in] long cRegions, 
                [in, size_is(cRegions)] NewHiddenRegion *rgHidReg,
                [out] IVsEnumHiddenRegions **ppEnum);

        /*
            EnumHiddenRegions returns a static snapshot list of hidden regions.
        */
        HRESULT EnumHiddenRegions(
                [in] DWORD dwFindFlags,     // tells how to find region; ORing of FIND_HIDDEN_REGION_FLAGS enum
                [in] DWORD_PTR dwCookie,
                [in] TextSpan *ptsRange,
                [out] IVsEnumHiddenRegions **ppEnum);

        HRESULT UnadviseClient(void);
        HRESULT Terminate(void);
    };

    /*
        Explicit outlining support.  These are handy wrappers that make it easy to do outlining in the view.
        Anything you can do with these methods can be done with the lower-level IVsHiddenTextSession methods,
        but these are simpler for outlining (but less flexible).
    */

	// NewOutlineRegion
	//------------------------------------------------------------------------------
	typedef struct _tag_NewOutlineRegion
	{
        DWORD           dwState;        // State bits (e.g. expand/collapse state) -- see HIDDEN_REGION_STATE values
		TextSpan	    tsHiddenText;   // Span of hidden text
	} NewOutlineRegion;

    typedef enum _tag_ADD_OUTLINE_REGION_FLAGS
    {
        AOR_DEFAULT             = 0x0,  // blasts away existing outlining regions (a fresh start)
        AOR_PRESERVE_EXISTING   = 0x1,  // leaves other regions, strictly adding these


        // AOR_NON_UNDOABLE indicates that the action is not part of the undo/redo stack (e.g. if outlining is done when
        // the document is first loaded)
        AOR_NON_UNDOABLE        = 0x100
    } ADD_OUTLINE_REGION_FLAGS;

	[
		uuid(uuid_IVsOutliningSession)
	]
    interface IVsOutliningSession : IUnknown
    {
        HRESULT AddOutlineRegions(
                [in] DWORD dwOutliningFlags,  // ORing of ADD_OUTLINE_REGION_FLAGS enum
                [in] long cRegions,           // count of regions
                [in, size_is(cRegions)] NewOutlineRegion *rgOutlnReg); // caller-allocated array of regions
    };

	[
		uuid(uuid_IVsOutliningCapableLanguage)
	]
    interface IVsOutliningCapableLanguage : IUnknown
    {
        HRESULT CollapseToDefinitions(
            [in] IVsTextLines *pTextLines,  // the buffer in question
            [in] IVsOutliningSession *pSession); // the interface you call back into in order to hide the text
    };

    typedef enum _tag_DATA_OBJECT_RENDER_HINT
    {
        DORH_DEFAULT             = 0x0000, // no information available
        DORH_MOVE_IN_SAME_DOC    = 0x0001, // rendering was a move in the same document
        DORH_DROP                = 0x0002, // a general drag/drop operation (includes drag/drop from toolbox as well as DORH_MOVE_IN_SAME_DOC)
        DORH_CLIPBOARD           = 0x0004, // a general paste from the system clipboard (e.g. ctrl+V)
        DORH_TOOLBOX             = 0x0008, // the user double-clicked an item from the toolbox
        DORH_PREVIEW             = 0x0010  // a tentative preview (e.g. doing ctrl+shift+V to cycle through the clipboard -- don't do anything slow in this case!)
    } DATA_OBJECT_RENDER_HINT;


    /*
        IVsTextLayerEvents

        Notifies a client that a layer's coordinate mapping is changing. 

        For example, sizing the window changes the word-wrap layer's 
        mapping. The view sinks these events to maintain the selection. 

        A client will generally convert all of it's local coordinates to 
        base buffer coordinates in OnMappingChange, then convert to the new 
        local coordinates in OnMappingChangeComplete. 

        IVsTextLayerEvents are purely changes in coordinate mapping. 
        If there is a change in the data, the layer should fire 
        IVsTextLinesEvents::OnChangeLineText.

    */
    [
        uuid(uuid_IVsTextLayerEvents),
    ]
    interface IVsTextLayerEvents : IUnknown
    {
#ifdef PROXYSTUB_BUILD
        HRESULT OnMappingChange(void);
        HRESULT OnMappingChangeComplete(void);
#else
        void OnMappingChange(void);
        void OnMappingChangeComplete(void);
#endif
    }

	/* Custom storage interfaces */

	// ChangeInput -- holds information about a pending change request *before* it has happened.
	//------------------------------------------------------------------------------
	typedef struct tag_ChangeInput
	{
		TextSpan	m_DelSpan;		// Span to delete
		long        m_iOldLen;        // Old length
		long        m_iNewLen;        // New length
		const WCHAR *m_pszNewText;	// Text to insert; memory owned by creator of struct
        DWORD       m_dwFlags;      // Flags that describe change (ORing of REPLACE_TEXT_FLAGS enum values)
	} ChangeInput;

	/*
		IVsTextStorage
		
		IVsTextStorage is REQUIRED for all storage objects.  It represents the range of text that is
		viewable and editable by text editor views.
	*/
	[
		uuid(uuid_IVsTextStorage)
	]
	interface IVsTextStorage : IUnknown
	{
		// storage methods concerning visible, editable text

		HRESULT	Storage_Attach ([in] IUnknown *pBuffer);
#ifdef PROXYSTUB_BUILD
		HRESULT Storage_Detach (void);

		HRESULT Storage_GetLength (void);
		HRESULT Storage_GetLineCount (void);
#else
		void	Storage_Detach (void);

		long	Storage_GetLength (void);
		long	Storage_GetLineCount (void);
#endif
		HRESULT	Storage_GetLengthOfLine ([in] long iLine, [out] long *piLength);

		HRESULT	Storage_GetPositionOfLineIndex ([in] long iLine, [in] CharIndex iIndex, [out] long *piPosition);
		HRESULT	Storage_GetLineIndexOfPosition ([in] long iPosition, [out] long *piLine, [out] CharIndex *piIndex);

		HRESULT	Storage_Replace  ([in] ChangeInput *pCI, [out] TextSpan *ptsOut);
		HRESULT Storage_CopyText ([in] long iStartLine, [in] CharIndex iStartIndex, [in] long iBufMax, [out] WCHAR *pszDest, [out] long *pcCharsCopied);
		HRESULT	Storage_GetCharsInSpan ([in] TextSpan *pSpanToMeasure, [out] long *piChars);

		HRESULT	Storage_GetLineDataEx (
			[in] DWORD dwFlags, 
			[in] long  iLine, 
			[in] long  iStartIndex, 
			[in] long  iEndIndex, 
			[out] LINEDATAEX * pLineData);
		HRESULT     Storage_ReleaseLineDataEx    ([in] LINEDATAEX *pLineData);
		HRESULT     Storage_GetLanguageServiceID ([out] GUID *pguidLangService);
		HRESULT     Storage_SetLanguageServiceID ([in] REFGUID guidLangService);
		HRESULT		Storage_RefreshColorization  ([in] long iTopLine, [in] long iBotLine, [out] long *piLastAffectedLine);

		HRESULT     Storage_Find (
			[in]  const WCHAR * pszText, 
			[in]  long          iStartLine,	 // starting line
			[in]  CharIndex     iStartIndex, // starting character index within the line (must be <= length of line)
			[in]  long          iEndLine,	 // ending line
			[in]  CharIndex     iEndIndex,	 // ending character index within the line (must be <= length of line)
			[in]  long          iFlags,
			[out] long       *  piLine, 
			[out] CharIndex  *  piCol);
	};

	typedef enum _StorageLoadFlags
	{
		slfDefault	=	0x0,
		slfReload	=	0x1
	} StorageLoadFlags;

	/*
		IVsPersistentTextImage
		
		IVsPersistentTextImage is REQUIRED for all storage objects.  It represents the image that is
		persisted and unpersisted.  This is not necessarily the same data that is exposed by IVsTextStorage.
	*/
	[
#ifdef PROXYSTUB_BUILD
        // MIDL2269
        local,
#endif
		uuid(uuid_IVsPersistentTextImage)
	]
	interface IVsPersistentTextImage : IUnknown
	{
		// storage methods concerning the docdata, i.e. the persistent disk image (may be different from the editable image)
		void *      Image_Alloc   ([in] int iSize);
		void *      Image_Realloc ([in,out] void *p, [in] int iSize);
		void        Image_Free    ([in] void *p);

		long		Image_GetLength(void); // Unicode chars
		// If Image_LoadText succeeds, storage assumes ownership of memory (allocated via Image_Alloc/Image_Realloc)
		HRESULT		Image_LoadText ([in] const WCHAR *pszText, [in] INT iLength, [in] DWORD dwFlags); // Initialization

		HRESULT		Image_OpenFullTextScan (void);
		HRESULT		Image_FullTextRead ([out] const WCHAR **ppszText, [out] long *piLength);
		HRESULT		Image_CloseFullTextScan (void);
	};

	/*
		IVsTextStorageColorState
		
		IVsTextStorageColorState is optional for storage objects.  If the storage talks to pluggable colorizers,
		it should expose this.  Otherwise, it need not do so.
	*/
	[
		uuid(uuid_IVsTextStorageColorState)
	]
	interface IVsTextStorageColorState : IUnknown
	{
		HRESULT GetColorStateAtStartOfLine([in] long iLine, [out] long *piState);
	};


    typedef enum _ChangeCommitGestureFlags
    {
        CCG_SAVE                        = 0x0001,
        CCG_MULTILINE_CHANGE            = 0x0002,
        CCG_CARET_ON_NEW_BUFFER_LINE    = 0x0010,
        CCG_MASS_REPLACE                = 0x0008,
        CCG_ENTER_COMMAND               = 0x0010,
        CCG_FIND_STARTING               = 0x0020,
        CCG_LOST_FOCUS                  = 0x0040,
        CCG_DESTRUCTIVEACTION           = 0x0080,
        CCG_PROGRAMMATIC_CHANGE         = 0x1000
    } ChangeCommitGestureFlags;

    /*
        IVsFinalTextChangeCommitEvents

        Language services or other parties who have total control over the editing experience
        are the only intended client of this interface.
    */
    [
        uuid(uuid_IVsFinalTextChangeCommitEvents)
    ]
    interface IVsFinalTextChangeCommitEvents : IUnknown
    {
#ifdef PROXYSTUB_BUILD
        HRESULT OnChangesCommitted([in] DWORD dwGestureFlags, [in] TextSpan *ptsChanged);
#else
        void OnChangesCommitted([in] DWORD dwGestureFlags, [in] TextSpan *ptsChanged);
#endif
    };
    
    /*
        IVsPreliminaryTextChangeCommitEvents is another incarnation of the "Tier 3" event, but
        is intended for extensibility and any other client that doesn't want to risk breaking
        VB & other pretty-listed languages.

        Extensibility event proxies should use this sink.  If in doubt, use this sink rather
        than IVsFinalTextChangeCommitEvents.
    */
    [
        uuid(uuid_IVsPreliminaryTextChangeCommitEvents)
    ]
    interface IVsPreliminaryTextChangeCommitEvents : IVsFinalTextChangeCommitEvents
    {
    };

    /*
        If you are not VB, do not even think about monitoring this event.

        It fires when an undo or redo cluster is closing, provided an intervening commit gesture
        occurred while it was open.

        Clients are explicitly forbidden from modifying the buffer in response to this event.
    */
    [
        uuid(uuid_IVsUndoRedoClusterWithCommitEvents)
    ]
    interface IVsUndoRedoClusterWithCommitEvents : IUnknown
    {
#ifdef PROXYSTUB_BUILD
        HRESULT OnUndoRedoClusterClosingWithCommitGesture([in] DWORD dwGestureFlags, [in] TextSpan *ptsChanged);
#else
        void OnUndoRedoClusterClosingWithCommitGesture([in] DWORD dwGestureFlags, [in] TextSpan *ptsChanged);
#endif
    };



    //================================================================
    [
        uuid(uuid_IVsTextImageEvents),
        version(1.0)
    ]
    interface IVsTextImageEvents : IUnknown
    {
#ifdef PROXYSTUB_BUILD
        HRESULT OnTextChange ([in] TextAddress taStart, [in] TextAddress taEnd, [in] TextAddress taNewEnd);
#else
        void OnTextChange ([in] TextAddress taStart, [in] TextAddress taEnd, [in] TextAddress taNewEnd);
#endif
    };

    /*
        IVsCommitGestureSink

        This is exposed by the tier 3 event manager to let clients indicate that some form of UI commit
        gesture has occurred.

        Because this is a many-to-one event rather than a one-to-many broadcast, this is just an
        interface that multiple clients QI for & call as necessary.
    */
    [
	uuid(uuid_IVsCommitGestureSink)
    ]
    interface IVsCommitGestureSink : IUnknown
    {
#ifdef PROXYSTUB_BUILD
        HRESULT OnCommitGesture([in] DWORD dwGestureFlags);
        HRESULT FlushCommitEventIfCurrentClusterIsOutermost(void);
#else
        void OnCommitGesture([in] DWORD dwGestureFlags);
        void FlushCommitEventIfCurrentClusterIsOutermost(void);
#endif
    };
    
    //================================================================
    // IVsTextImage
    //
    // Objects implementing this also implement IVsPersistentTextImage
    //
    // Implemented by the shell's IVsTextBuffer object.
    // Implemented by a class available in UniLib: see TxFactory.h, TxImgHlp.h
    //
    [
        uuid (67068DC0-C069-11d2-936C-D714766E8B50),
        version(1.0),
        pointer_default(unique)
    ]
    interface IVsTextImage : IUnknown
    {
        HRESULT GetCharSize    ([out, retval] LONG * pcch);     // count of chars
        HRESULT GetLineSize    ([out, retval] LONG * pcLines);  // count of lines

        HRESULT GetOffsetOfTextAddress  ([in] TextAddress ta, [out, retval] LONG * piOffset);
        HRESULT GetTextAddressOfOffset  ([in] LONG iOffset, [out, retval] TextAddress * pta);

        HRESULT Replace         ([in]               DWORD            dwFlags,
                                 [in]               const TextSpan * pts,
                                 [in]               LONG             cch,
                                 [in, size_is(cch)] LPCOLESTR        pchText, 
                                 [out, retval]      TextSpan *       ptsChanged);

        HRESULT GetSpanLength   ([in] const TextSpan * pts, [out, retval] LONG * pcch);
        HRESULT GetTextBSTR     ([in] const TextSpan * pts, [out, retval] BSTR * pbstrText);
        HRESULT GetText         ([in] const TextSpan * pts, [in] LONG cch, [out, size_is(cch)] LPOLESTR psz);

        HRESULT GetLineLength   ([in] LONG iLine, [out, retval] LONG * piLength);
        HRESULT GetLine         ([in] DWORD     grfGet, 
                                 [in] LONG      iLine, 
                                 [in] LONG      iStartIndex, 
                                 [in] LONG      iEndIndex, 
                                 [out, retval] LINEDATAEX * pLineData);
        HRESULT ReleaseLine     ([in] LINEDATAEX * pLineData);

        HRESULT AdviseTextImageEvents   ([in] IVsTextImageEvents * pSink, [out, retval] DWORD * pCookie);
        HRESULT UnadviseTextImageEvents ([in] DWORD Cookie);

        HRESULT LockImage      ([in] DWORD grfLock); // BLF_READ or BLF_READ_AND_WRITE
        HRESULT UnlockImage    ([in] DWORD grfLock); // BLF_READ or BLF_READ_AND_WRITE    
    };
    
    // IVsEditorGoBackLocations
// This is an optional interfce that can be QI'd from the IVsTextView interface.
//
//  The bool variable, fCurrentCaretPos, is to allow you to not specify the line and column, but to have the current caret position marked
//  If this is false, a valid base buffer line and column is required
[
    uuid(uuid_IVsEditorGoBackLocations)
]
interface IVsEditorGoBackLocations : IUnknown
{
    HRESULT SetNonMergeableGoBackLocation ([in] BOOL fCurrentCaretPos, [in] long iBaseLine, [in] long iBaseCol);
    HRESULT SetMergeableGoBackLocation ([in] BOOL fCurrentCaretPos, [in] long iBaseLine, [in] long iBaseCol);    
};

#ifndef INTEROPLIB
};
#endif



/////////////////////////////////////////////////////////////////////////
// IVsReplaceEvents interface
//
// This event tells you information about a change that is about to
// occur.
//
// WARNING: use of this interface is discouraged.  Do not use in new code.  Talk
// to the VS editor team if you have questions.
//
/////////////////////////////////////////////////////////////////////////
[
    uuid(uuid_IVsTextReplaceEvents)
]
interface IVsTextReplaceEvents : IUnknown
{
    // WARNING: use of this interface is discouraged.  Do not use in new code.  Talk
    // to the VS editor team if you have questions.
    //
	HRESULT OnReplace( [in] const ChangeInput* pCI );
};

//Flags to prompt user for an encoding on an open with specified codepage.  Should only be used by editor factories supporting this!!!
enum __PROMPTONLOADFLAGS {  
    codepageNoPrompt = 0x000000000,
    codepagePrompt = 0x000000001
    };
typedef DWORD PROMPTONLOADFLAGS;

enum __VSTFF { // VS Text File Format
	VSTFF_SIGNATURE      = 0x00010000,   // file signature (Byte Order Mark, UTF-8 sig.)
	VSTFF_DETECT         = 0x01000000,   // extra analysis to detect encoding
	VSTFF_HTML           = 0x02000000,   // HTML
	VSTFF_XML            = 0x04000000,   // XML
	VSTFF_BINARY         = 0x08000000,   // binary handling
	VSTFF_CPMASK         = 0x0000FFFF,   // mask for the codepage portion of VSTFF
	VSTFF_FLAGSMASK      = 0xFFFF0000    // mask for the flags portion of VSTFF
};
typedef DWORD VSTFF;


[
	uuid(uuid_IVsFormatFilterProvider)
]
interface IVsFormatFilterProvider : IUnknown
{
	//Provides the list of available extensions for Save As.
	//If no filter is provided, the default filter string is "All Files (*.*)\n*.*\nText Files (*.txt)\n*.txt\n"
	//This filter list should not contain the All Files filer or Text Files.  These will be added by the shell
	HRESULT GetFormatFilterList([out] BSTR *pbstrFilterList);

	//Provides the index to the filter matching the extension of the file passed in.  This is determined by the place
	//in the FormatFilterList of the filter matching the extension passed in.
	//For example, if ".*" was passed into the default filter above, 0 would be stored in iExtnIndex.  Likewise
	//a 1 would be stored for a ".txt" passed in.  You should only be concerned with your file extensions and
    //not the All Files or Text files.  If you don't match the file extension to one of yours, return E_FAIL
	HRESULT CurFileExtensionFormat([in]BSTR bstrFileName, [out] DWORD *pdwExtnIndex );

	//QueryInvalidEncoding allows the language service to supply an appropriate message
	//when the user has chosen an encoding htat is not supported by the language tools.
	//For example, if the compiler is unable to accept Unicode or UTF-8 source files, it is
	//appropriate to warn users that they have chosen an incompatable encoding.
	HRESULT QueryInvalidEncoding([in]VSTFF format, [out] BSTR * pbstrMessage);


};


enum _NavigableLocationResolverFlags
{
	NLR_ABSOLUTEPATH	= 0x00000001,
	NLR_PARTIALPATH	    = 0x00000002,
	NLR_URL			    = 0x00000010
};
typedef DWORD NavigableLocationResolverFlags;

[
uuid(uuid_IVsNavigableLocationResolver)
]
interface IVsNavigableLocationResolver: IUnknown
{
    HRESULT GetDisplayText(
        [in] DWORD dwReserved, 	  // for any unforeseen need
   	    [in] TextSpan *ptsBase, 	  //Current selection or caret location
        [in] IVsTextLines *pBuffer,   //Base buffer
        [out] NavigableLocationResolverFlags *dwOutFlags, //If current location is a URL
        [out,retval] BSTR * pbstrDisplayText); 	  //Text to display in context menu

	HRESULT GetPathFromLocation(
        [in] DWORD dwReserved, 	  // for any unforeseen need
   	    [in] TextSpan *ptsBase, 	  //Current selection or caret location
        [in] IVsTextLines *pBuffer,   //Base buffer
        [in] const WCHAR *pszDisplayText,  //Display Text from GetDisplayText
        [out] NavigableLocationResolverFlags *dwOutFlags,  //If current location is a URL
        [out,retval] BSTR * pbstrPath); 	  //As much of a path as possible or just the file name
};


[
uuid(uuid_IVsLanguageTextOps)
]
interface IVsLanguageTextOps : IUnknown
{
    //----------------------------------------------------------------
    // Get a data tip for the selection/point
    //
    // Return values:
    // S_OK      Determined a tip to display
    // S_FALSE   No tip
    //----------------------------------------------------------------
    HRESULT GetDataTip(
        [in]          IVsTextLayer   *pTextLayer,
        [in]          const TextSpan *ptsSel,       // selected text
        [out]         TextSpan       *ptsTip,       // bounding context of the tip
        [out, retval] BSTR           *pbstrText);   // text of the tip to display

    //----------------------------------------------------------------
    // Get position of the pair characters enclosing the caret.
    // Pair characters are braces, parens, quotes, brackets, etc.
    // 
    // Return values:
    // S_OK     Found enclosing pair
    // S_FALSE  Not found (no errors)
    //----------------------------------------------------------------
    HRESULT GetPairExtent(
        [in]          IVsTextLayer *pTextLayer,
        [in]          TextAddress   ta,
        [out, retval] TextSpan     *pts);

    //----------------------------------------------------------------
    // Get the extent of a word or token on or near the point.
    // 
    // Return values:
    // S_OK      Found the specified word or token
    // S_FALSE   Not found (no errors)
    //----------------------------------------------------------------
    HRESULT GetWordExtent(
        [in]          IVsTextLayer *pTextLayer,
        [in]          TextAddress   ta,
        [in]          WORDEXTFLAGS  flags,
        [out, retval] TextSpan     *pts);

    //----------------------------------------------------------------
    // Format the selected text
    //----------------------------------------------------------------
    HRESULT Format(
        [in] IVsTextLayer   *pTextLayer,
        [in] const TextSpan *ptsSel);
}


// flags for TextFromData
typedef enum _LTE_TEXTDATAFLAGS
{
    LTE_NORMAL      = 0x00000000,  // normal (stream) mode data
	LTE_BOX         = 0x00000001,  // box (column) mode data - text is inserted as a box
	LTE_LINE		= 0x00000002,  // line mode data - text is inserted as whole lines only
} LTE_TEXTDATAFLAGS;

[
uuid(uuid_IVsLanguageClipboardOps)
]
interface IVsLanguageClipboardOps : IUnknown
{
    //----------------------------------------------------------------
    // Create an IDataObject with lang-specific formats
    // 
    // The created data object must not hold a reference to pView or pTextLayer -
    // the data object can outlive them.
    // 
    // Return values:
    // S_OK     Created the data object
    // E_FAIL   Did not create a data object (no errors)
    //----------------------------------------------------------------
    HRESULT GetDataObject(
        [in]          IVsTextView  *pView,
        [in]          IVsTextLayer *pTextLayer,
        [out, retval] IDataObject **ppDO);

    //----------------------------------------------------------------
    // Does this data object contain data you can render into text?
    // 
    // Return values:
    // S_OK == Yes, S_FALSE = No
    //----------------------------------------------------------------
    HRESULT IsTextData(
        [in] IDataObject *pDO);

    //----------------------------------------------------------------
    // Render this data object to text
    //----------------------------------------------------------------
    HRESULT TextFromData(
        [in]          IVsTextLayer      *pTextLayer,
        [in]          IDataObject       *pDO,
        [out]         LTE_TEXTDATAFLAGS *ptdfFlags,
        [out, retval] BSTR              *pbstrText);

    HRESULT DataObjectRendered(
        [in] IVsTextLines *pTextLines,              // the buffer in question
        [in] DWORD         dwHint,                  // see DATA_OBJECT_RENDER_HINT values
        [in] TextSpan     *ptsInsertedText);        // text span in buffer coordinates of the newly inserted text
}

enum _QuerySendCommitFlags
{
    QSCF_DO_SEND_ENTER_COMMIT = 0x00000000,
    QSCF_DO_NOT_SEND_ENTER_COMMIT = 0x00000001
};
typedef DWORD QuerySendCommitFlags;

//  IVsQueryLineChangeCommit
// 
//  This is an optional interface that should be implemented by the IVsTextViewFilter to determine wether an CCG_CARET_ON_NEW_BUFFER_LINE 
//  committ event should be fired.  This only needs to happen if you don't always want this commit event on a Carriage Return/Line feed and if you listen to
//  IVsFinalTextChangeCommitEvents or IVsPreliminaryTextChangeCommitEvents


[
uuid(uuid_IVsQueryLineChangeCommit)
]
interface IVsQueryLineChangeCommit : IUnknown
{

    HRESULT QuerySendEnterLineCommit(
        [in] DWORD dwReserved, 
        [in] long iLineStart, 
        [in] long iLineEnd, 
        [out, retval] QuerySendCommitFlags *dwQuerySendCommitFlags);

};

// IVsCodeWindowEvents
// This is an optional interfce that can be QI'd from the IVsCodeWindow interface.  It sends code window type events to someone who doesn't have an IVsCodeWindowManager
[
    uuid(uuid_IVsCodeWindowEvents)
]
interface IVsCodeWindowEvents : IUnknown
{
    HRESULT OnNewView ([in] IVsTextView *pView);
    HRESULT OnCloseView ([in] IVsTextView *pView);
};

//----------------------------------------------------------------------------
// IVsFileBackup interface
//
// IVsFileBackup should be supported by components interested in being
// backed up.  Visual Studio File Recovery backs up all objects in the Running 
// Document Table that support IVsFileBackup and have unsaved changes.
//----------------------------------------------------------------------------

[
uuid(uuid_IVsFileBackup),
version(1.0),
pointer_default(unique)
]


interface IVsFileBackup : IUnknown
{
	//----------------------------------------------------------------------------
	// BackupFile() persists the object to a single file.  It must not
	// modify any internal state, but should clear the secondary dirty bit.
	// BackupFile() must return either E_STG_S_DATALOSS or STG_E_INVALIDCODEPAGE
	// if there is no way to persist to a file without data loss.
	//----------------------------------------------------------------------------

	HRESULT BackupFile([in] LPCOLESTR pszBackupFileName);
	
	//----------------------------------------------------------------------------
	// IVsFileBackup needs to keep track of a secondary dirty bit for the backup in 
	// order to avoid extra backups for cases where the file is dirty, but the 
	// backup matches the current state of the object.  This bit should be set when
	// the object is modified and cleared on calls to BackupFile() and any Save() 
	// method.  IsBackupFileObosolete() returns true if this bit is set, FALSE otherwise.
	//----------------------------------------------------------------------------

	HRESULT IsBackupFileObsolete([out] BOOL *pbObsolete);
};

[
uuid(uuid_IVsLineAttributes),
version(1.0),
pointer_default(unique)
]
interface IVsLineAttributes : IUnknown
{
    HRESULT SetLineSeparator([in] long *rgLines, [in] long cLines,  [in]BOOL fRemoveAll);
};
